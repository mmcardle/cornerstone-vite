(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str2, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str2.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
function normalizeStyle(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$4(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$4(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$4(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString$4(val) ? val : val == null ? "" : isArray$3(val) || isObject(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$4(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet$4(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray$3(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$_ = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn$4 = (val, key) => hasOwnProperty.call(val, key);
const isArray$3 = Array.isArray;
const isMap$4 = (val) => toTypeString(val) === "[object Map]";
const isSet$4 = (val) => toTypeString(val) === "[object Set]";
const isFunction$2 = (val) => typeof val === "function";
const isString$4 = (val) => typeof val === "string";
const isSymbol$3 = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$4(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str2) => {
    const hit = cache2[str2];
    return hit || (cache2[str2] = fn(str2));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str2) => {
  return str2.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str2) => str2.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize$1 = cacheStringFunction((str2) => str2.charAt(0).toUpperCase() + str2.slice(1));
const toHandlerKey = cacheStringFunction((str2) => str2 ? `on${capitalize$1(str2)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj2, key, value) => {
  Object.defineProperty(obj2, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this.active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target)) {
    const newLength = toNumber(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$4(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$4(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$3(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$3)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2 && targetIsArray && hasOwn$4(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$3(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$2 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$4(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn$4(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$3(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$3(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$l(target) {
  track(target, "iterate", isArray$3(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$2,
  deleteProperty,
  has: has$3,
  ownKeys: ownKeys$l
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$_({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto$3 = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto$3(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$3(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto$3(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$3(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$3(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$4(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add: add$3,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add: add$3,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$4(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy2 = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy2);
  return proxy2;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue$1[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue$1.length || !queue$1.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue$1.indexOf(job);
  if (i > flushIndex) {
    queue$1.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$3(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.pre) {
      queue$1.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue$1.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit$1(instance, event2, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString$4(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event2)] || props[handlerName = toHandlerKey(camelize(event2))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event2))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$_(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$_(normalized, raw);
  }
  if (isObject(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$4(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$4(options, hyphenate(key)) || hasOwn$4(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy: proxy2, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy2;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render2(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys4 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys4.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys4.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$4(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$3(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet$4(value) || isMap$4(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state2, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state2, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state2, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$3(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state2, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding2 = bindings[i];
    if (oldBindings) {
      binding2.oldValue = oldBindings[i].value;
    }
    let hook = binding2.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding2,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const NULL_DYNAMIC_COMPONENT = Symbol();
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$_(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick$1.bind(i.proxy)),
  $watch: (i) => instanceWatch.bind(i)
});
const hasSetupBinding = (state2, key) => state2 !== EMPTY_OBJ && !state2.__isScriptSetup && hasOwn$4(state2, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$4(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$4(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$4(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$4(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$4(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$4(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$4(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$4(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$4(normalizedProps, key) || hasOwn$4(ctx, key) || hasOwn$4(publicPropertiesMap, key) || hasOwn$4(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$4(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$3(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$4(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$_(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$_(extend$_(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$_(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$4(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn$4(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$4(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$4(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$4(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$4(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$4(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys4] = normalizePropsOptions(raw2, appContext, true);
      extend$_(normalized, props);
      if (keys4)
        needCastKeys.push(...keys4);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$2(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$4(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$_(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$4(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$4(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$4(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$4(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$3(existing) && remove(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$4(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$4(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len2 = arr.length;
  for (i = 0; i < len2; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$4(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$4(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$4(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray$3(style2)) {
        style2 = extend$_({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$4(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$_({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$3(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$_(extend$_({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version$1 = "3.2.45";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is3, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is3 ? { is: is3 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$4(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString$4(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$3(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean3 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean3 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean3 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event2, handler, options) {
  el.addEventListener(event2, handler, options);
}
function removeEventListener(el, event2, handler, options) {
  el.removeEventListener(event2, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event2 = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event2, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$3(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$4(value)) {
    return false;
  }
  return key in el;
}
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
/* @__PURE__ */ extend$_({}, BaseTransition.props, DOMTransitionPropsValidators);
const rendererOptions = /* @__PURE__ */ extend$_({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy2 = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy2;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$4(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const style = "";
const _imports_0 = "/vite.svg";
const _imports_1 = "/assets/vue-5532db34.svg";
const HelloWorld_vue_vue_type_style_index_0_scoped_a96fa91f_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-a96fa91f"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "card" };
const _hoisted_2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Edit "),
  /* @__PURE__ */ createBaseVNode("code", null, "components/HelloWorld.vue"),
  /* @__PURE__ */ createTextVNode(" to test HMR ")
], -1));
const _hoisted_3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Check out "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://vuejs.org/guide/quick-start.html#local",
    target: "_blank"
  }, "create-vue"),
  /* @__PURE__ */ createTextVNode(", the official Vue + Vite starter ")
], -1));
const _hoisted_4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Install "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://github.com/johnsoncodehk/volar",
    target: "_blank"
  }, "Volar"),
  /* @__PURE__ */ createTextVNode(" in your IDE for a better DX ")
], -1));
const _hoisted_5 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", { class: "read-the-docs" }, "Click on the Vite and Vue logos to learn more", -1));
const _sfc_main$1 = {
  __name: "HelloWorld",
  props: {
    msg: String
  },
  setup(__props) {
    const count = ref(0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("h1", null, toDisplayString(__props.msg), 1),
        createBaseVNode("div", _hoisted_1$1, [
          createBaseVNode("button", {
            type: "button",
            onClick: _cache[0] || (_cache[0] = ($event) => count.value++)
          }, "count is " + toDisplayString(count.value), 1),
          _hoisted_2
        ]),
        _hoisted_3,
        _hoisted_4,
        _hoisted_5
      ], 64);
    };
  }
};
const HelloWorld = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-a96fa91f"]]);
var Events$1;
(function(Events2) {
  Events2["CACHE_SIZE_EXCEEDED"] = "CACHE_SIZE_EXCEEDED";
  Events2["IMAGE_LOAD_ERROR"] = "IMAGE_LOAD_ERROR";
  Events2["CAMERA_MODIFIED"] = "CORNERSTONE_CAMERA_MODIFIED";
  Events2["CAMERA_RESET"] = "CORNERSTONE_CAMERA_RESET";
  Events2["VOI_MODIFIED"] = "CORNERSTONE_VOI_MODIFIED";
  Events2["ELEMENT_DISABLED"] = "CORNERSTONE_ELEMENT_DISABLED";
  Events2["ELEMENT_ENABLED"] = "CORNERSTONE_ELEMENT_ENABLED";
  Events2["IMAGE_RENDERED"] = "CORNERSTONE_IMAGE_RENDERED";
  Events2["IMAGE_VOLUME_MODIFIED"] = "CORNERSTONE_IMAGE_VOLUME_MODIFIED";
  Events2["IMAGE_LOADED"] = "CORNERSTONE_IMAGE_LOADED";
  Events2["IMAGE_LOAD_FAILED"] = "CORNERSTONE_IMAGE_LOAD_FAILED";
  Events2["VOLUME_VIEWPORT_NEW_VOLUME"] = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME";
  Events2["VOLUME_LOADED"] = "CORNERSTONE_VOLUME_LOADED";
  Events2["VOLUME_LOADED_FAILED"] = "CORNERSTONE_VOLUME_LOADED_FAILED";
  Events2["IMAGE_CACHE_IMAGE_ADDED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED";
  Events2["IMAGE_CACHE_IMAGE_REMOVED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED";
  Events2["VOLUME_CACHE_VOLUME_ADDED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED";
  Events2["VOLUME_CACHE_VOLUME_REMOVED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED";
  Events2["STACK_NEW_IMAGE"] = "CORNERSTONE_STACK_NEW_IMAGE";
  Events2["VOLUME_NEW_IMAGE"] = "CORNERSTONE_VOLUME_NEW_IMAGE";
  Events2["PRE_STACK_NEW_IMAGE"] = "CORNERSTONE_PRE_STACK_NEW_IMAGE";
  Events2["IMAGE_SPACING_CALIBRATED"] = "CORNERSTONE_IMAGE_SPACING_CALIBRATED";
  Events2["IMAGE_LOAD_PROGRESS"] = "CORNERSTONE_IMAGE_LOAD_PROGRESS";
  Events2["STACK_VIEWPORT_NEW_STACK"] = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK";
  Events2["STACK_VIEWPORT_SCROLL"] = "CORNERSTONE_STACK_VIEWPORT_SCROLL";
})(Events$1 || (Events$1 = {}));
const Events$2 = Events$1;
var RequestType;
(function(RequestType2) {
  RequestType2["Interaction"] = "interaction";
  RequestType2["Thumbnail"] = "thumbnail";
  RequestType2["Prefetch"] = "prefetch";
})(RequestType || (RequestType = {}));
const RequestType$1 = RequestType;
var ViewportType;
(function(ViewportType2) {
  ViewportType2["STACK"] = "stack";
  ViewportType2["ORTHOGRAPHIC"] = "orthographic";
  ViewportType2["PERSPECTIVE"] = "perspective";
  ViewportType2["VOLUME_3D"] = "volume3d";
})(ViewportType || (ViewportType = {}));
const ViewportType$1 = ViewportType;
var InterpolationType$4;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["NEAREST"] = 0] = "NEAREST";
  InterpolationType2[InterpolationType2["LINEAR"] = 1] = "LINEAR";
  InterpolationType2[InterpolationType2["FAST_LINEAR"] = 2] = "FAST_LINEAR";
})(InterpolationType$4 || (InterpolationType$4 = {}));
const InterpolationType$5 = InterpolationType$4;
var BlendMode$1 = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5
};
var FilterMode$1 = {
  OFF: 0,
  NORMALIZED: 1,
  RAW: 2
};
var Constants$d = {
  BlendMode: BlendMode$1,
  FilterMode: FilterMode$1
};
var BlendModes;
(function(BlendModes2) {
  BlendModes2[BlendModes2["COMPOSITE"] = 0] = "COMPOSITE";
  BlendModes2[BlendModes2["MAXIMUM_INTENSITY_BLEND"] = 1] = "MAXIMUM_INTENSITY_BLEND";
  BlendModes2[BlendModes2["MINIMUM_INTENSITY_BLEND"] = 2] = "MINIMUM_INTENSITY_BLEND";
  BlendModes2[BlendModes2["AVERAGE_INTENSITY_BLEND"] = 3] = "AVERAGE_INTENSITY_BLEND";
})(BlendModes || (BlendModes = {}));
const BlendModes$1 = BlendModes;
var OrientationAxis;
(function(OrientationAxis2) {
  OrientationAxis2["AXIAL"] = "axial";
  OrientationAxis2["CORONAL"] = "coronal";
  OrientationAxis2["SAGITTAL"] = "sagittal";
  OrientationAxis2["ACQUISITION"] = "acquisition";
})(OrientationAxis || (OrientationAxis = {}));
const OrientationAxis$1 = OrientationAxis;
const colormapsData = {
  hotIron: {
    name: "Hot Iron",
    numOfColors: 256,
    colors: [
      [0, 0, 0, 255],
      [2, 0, 0, 255],
      [4, 0, 0, 255],
      [6, 0, 0, 255],
      [8, 0, 0, 255],
      [10, 0, 0, 255],
      [12, 0, 0, 255],
      [14, 0, 0, 255],
      [16, 0, 0, 255],
      [18, 0, 0, 255],
      [20, 0, 0, 255],
      [22, 0, 0, 255],
      [24, 0, 0, 255],
      [26, 0, 0, 255],
      [28, 0, 0, 255],
      [30, 0, 0, 255],
      [32, 0, 0, 255],
      [34, 0, 0, 255],
      [36, 0, 0, 255],
      [38, 0, 0, 255],
      [40, 0, 0, 255],
      [42, 0, 0, 255],
      [44, 0, 0, 255],
      [46, 0, 0, 255],
      [48, 0, 0, 255],
      [50, 0, 0, 255],
      [52, 0, 0, 255],
      [54, 0, 0, 255],
      [56, 0, 0, 255],
      [58, 0, 0, 255],
      [60, 0, 0, 255],
      [62, 0, 0, 255],
      [64, 0, 0, 255],
      [66, 0, 0, 255],
      [68, 0, 0, 255],
      [70, 0, 0, 255],
      [72, 0, 0, 255],
      [74, 0, 0, 255],
      [76, 0, 0, 255],
      [78, 0, 0, 255],
      [80, 0, 0, 255],
      [82, 0, 0, 255],
      [84, 0, 0, 255],
      [86, 0, 0, 255],
      [88, 0, 0, 255],
      [90, 0, 0, 255],
      [92, 0, 0, 255],
      [94, 0, 0, 255],
      [96, 0, 0, 255],
      [98, 0, 0, 255],
      [100, 0, 0, 255],
      [102, 0, 0, 255],
      [104, 0, 0, 255],
      [106, 0, 0, 255],
      [108, 0, 0, 255],
      [110, 0, 0, 255],
      [112, 0, 0, 255],
      [114, 0, 0, 255],
      [116, 0, 0, 255],
      [118, 0, 0, 255],
      [120, 0, 0, 255],
      [122, 0, 0, 255],
      [124, 0, 0, 255],
      [126, 0, 0, 255],
      [128, 0, 0, 255],
      [130, 0, 0, 255],
      [132, 0, 0, 255],
      [134, 0, 0, 255],
      [136, 0, 0, 255],
      [138, 0, 0, 255],
      [140, 0, 0, 255],
      [142, 0, 0, 255],
      [144, 0, 0, 255],
      [146, 0, 0, 255],
      [148, 0, 0, 255],
      [150, 0, 0, 255],
      [152, 0, 0, 255],
      [154, 0, 0, 255],
      [156, 0, 0, 255],
      [158, 0, 0, 255],
      [160, 0, 0, 255],
      [162, 0, 0, 255],
      [164, 0, 0, 255],
      [166, 0, 0, 255],
      [168, 0, 0, 255],
      [170, 0, 0, 255],
      [172, 0, 0, 255],
      [174, 0, 0, 255],
      [176, 0, 0, 255],
      [178, 0, 0, 255],
      [180, 0, 0, 255],
      [182, 0, 0, 255],
      [184, 0, 0, 255],
      [186, 0, 0, 255],
      [188, 0, 0, 255],
      [190, 0, 0, 255],
      [192, 0, 0, 255],
      [194, 0, 0, 255],
      [196, 0, 0, 255],
      [198, 0, 0, 255],
      [200, 0, 0, 255],
      [202, 0, 0, 255],
      [204, 0, 0, 255],
      [206, 0, 0, 255],
      [208, 0, 0, 255],
      [210, 0, 0, 255],
      [212, 0, 0, 255],
      [214, 0, 0, 255],
      [216, 0, 0, 255],
      [218, 0, 0, 255],
      [220, 0, 0, 255],
      [222, 0, 0, 255],
      [224, 0, 0, 255],
      [226, 0, 0, 255],
      [228, 0, 0, 255],
      [230, 0, 0, 255],
      [232, 0, 0, 255],
      [234, 0, 0, 255],
      [236, 0, 0, 255],
      [238, 0, 0, 255],
      [240, 0, 0, 255],
      [242, 0, 0, 255],
      [244, 0, 0, 255],
      [246, 0, 0, 255],
      [248, 0, 0, 255],
      [250, 0, 0, 255],
      [252, 0, 0, 255],
      [254, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 2, 0, 255],
      [255, 4, 0, 255],
      [255, 6, 0, 255],
      [255, 8, 0, 255],
      [255, 10, 0, 255],
      [255, 12, 0, 255],
      [255, 14, 0, 255],
      [255, 16, 0, 255],
      [255, 18, 0, 255],
      [255, 20, 0, 255],
      [255, 22, 0, 255],
      [255, 24, 0, 255],
      [255, 26, 0, 255],
      [255, 28, 0, 255],
      [255, 30, 0, 255],
      [255, 32, 0, 255],
      [255, 34, 0, 255],
      [255, 36, 0, 255],
      [255, 38, 0, 255],
      [255, 40, 0, 255],
      [255, 42, 0, 255],
      [255, 44, 0, 255],
      [255, 46, 0, 255],
      [255, 48, 0, 255],
      [255, 50, 0, 255],
      [255, 52, 0, 255],
      [255, 54, 0, 255],
      [255, 56, 0, 255],
      [255, 58, 0, 255],
      [255, 60, 0, 255],
      [255, 62, 0, 255],
      [255, 64, 0, 255],
      [255, 66, 0, 255],
      [255, 68, 0, 255],
      [255, 70, 0, 255],
      [255, 72, 0, 255],
      [255, 74, 0, 255],
      [255, 76, 0, 255],
      [255, 78, 0, 255],
      [255, 80, 0, 255],
      [255, 82, 0, 255],
      [255, 84, 0, 255],
      [255, 86, 0, 255],
      [255, 88, 0, 255],
      [255, 90, 0, 255],
      [255, 92, 0, 255],
      [255, 94, 0, 255],
      [255, 96, 0, 255],
      [255, 98, 0, 255],
      [255, 100, 0, 255],
      [255, 102, 0, 255],
      [255, 104, 0, 255],
      [255, 106, 0, 255],
      [255, 108, 0, 255],
      [255, 110, 0, 255],
      [255, 112, 0, 255],
      [255, 114, 0, 255],
      [255, 116, 0, 255],
      [255, 118, 0, 255],
      [255, 120, 0, 255],
      [255, 122, 0, 255],
      [255, 124, 0, 255],
      [255, 126, 0, 255],
      [255, 128, 4, 255],
      [255, 130, 8, 255],
      [255, 132, 12, 255],
      [255, 134, 16, 255],
      [255, 136, 20, 255],
      [255, 138, 24, 255],
      [255, 140, 28, 255],
      [255, 142, 32, 255],
      [255, 144, 36, 255],
      [255, 146, 40, 255],
      [255, 148, 44, 255],
      [255, 150, 48, 255],
      [255, 152, 52, 255],
      [255, 154, 56, 255],
      [255, 156, 60, 255],
      [255, 158, 64, 255],
      [255, 160, 68, 255],
      [255, 162, 72, 255],
      [255, 164, 76, 255],
      [255, 166, 80, 255],
      [255, 168, 84, 255],
      [255, 170, 88, 255],
      [255, 172, 92, 255],
      [255, 174, 96, 255],
      [255, 176, 100, 255],
      [255, 178, 104, 255],
      [255, 180, 108, 255],
      [255, 182, 112, 255],
      [255, 184, 116, 255],
      [255, 186, 120, 255],
      [255, 188, 124, 255],
      [255, 190, 128, 255],
      [255, 192, 132, 255],
      [255, 194, 136, 255],
      [255, 196, 140, 255],
      [255, 198, 144, 255],
      [255, 200, 148, 255],
      [255, 202, 152, 255],
      [255, 204, 156, 255],
      [255, 206, 160, 255],
      [255, 208, 164, 255],
      [255, 210, 168, 255],
      [255, 212, 172, 255],
      [255, 214, 176, 255],
      [255, 216, 180, 255],
      [255, 218, 184, 255],
      [255, 220, 188, 255],
      [255, 222, 192, 255],
      [255, 224, 196, 255],
      [255, 226, 200, 255],
      [255, 228, 204, 255],
      [255, 230, 208, 255],
      [255, 232, 212, 255],
      [255, 234, 216, 255],
      [255, 236, 220, 255],
      [255, 238, 224, 255],
      [255, 240, 228, 255],
      [255, 242, 232, 255],
      [255, 244, 236, 255],
      [255, 246, 240, 255],
      [255, 248, 244, 255],
      [255, 250, 248, 255],
      [255, 252, 252, 255],
      [255, 255, 255, 255]
    ]
  },
  pet: {
    name: "PET",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 2, 1, 255],
      [0, 4, 3, 255],
      [0, 6, 5, 255],
      [0, 8, 7, 255],
      [0, 10, 9, 255],
      [0, 12, 11, 255],
      [0, 14, 13, 255],
      [0, 16, 15, 255],
      [0, 18, 17, 255],
      [0, 20, 19, 255],
      [0, 22, 21, 255],
      [0, 24, 23, 255],
      [0, 26, 25, 255],
      [0, 28, 27, 255],
      [0, 30, 29, 255],
      [0, 32, 31, 255],
      [0, 34, 33, 255],
      [0, 36, 35, 255],
      [0, 38, 37, 255],
      [0, 40, 39, 255],
      [0, 42, 41, 255],
      [0, 44, 43, 255],
      [0, 46, 45, 255],
      [0, 48, 47, 255],
      [0, 50, 49, 255],
      [0, 52, 51, 255],
      [0, 54, 53, 255],
      [0, 56, 55, 255],
      [0, 58, 57, 255],
      [0, 60, 59, 255],
      [0, 62, 61, 255],
      [0, 65, 63, 255],
      [0, 67, 65, 255],
      [0, 69, 67, 255],
      [0, 71, 69, 255],
      [0, 73, 71, 255],
      [0, 75, 73, 255],
      [0, 77, 75, 255],
      [0, 79, 77, 255],
      [0, 81, 79, 255],
      [0, 83, 81, 255],
      [0, 85, 83, 255],
      [0, 87, 85, 255],
      [0, 89, 87, 255],
      [0, 91, 89, 255],
      [0, 93, 91, 255],
      [0, 95, 93, 255],
      [0, 97, 95, 255],
      [0, 99, 97, 255],
      [0, 101, 99, 255],
      [0, 103, 101, 255],
      [0, 105, 103, 255],
      [0, 107, 105, 255],
      [0, 109, 107, 255],
      [0, 111, 109, 255],
      [0, 113, 111, 255],
      [0, 115, 113, 255],
      [0, 117, 115, 255],
      [0, 119, 117, 255],
      [0, 121, 119, 255],
      [0, 123, 121, 255],
      [0, 125, 123, 255],
      [0, 128, 125, 255],
      [1, 126, 127, 255],
      [3, 124, 129, 255],
      [5, 122, 131, 255],
      [7, 120, 133, 255],
      [9, 118, 135, 255],
      [11, 116, 137, 255],
      [13, 114, 139, 255],
      [15, 112, 141, 255],
      [17, 110, 143, 255],
      [19, 108, 145, 255],
      [21, 106, 147, 255],
      [23, 104, 149, 255],
      [25, 102, 151, 255],
      [27, 100, 153, 255],
      [29, 98, 155, 255],
      [31, 96, 157, 255],
      [33, 94, 159, 255],
      [35, 92, 161, 255],
      [37, 90, 163, 255],
      [39, 88, 165, 255],
      [41, 86, 167, 255],
      [43, 84, 169, 255],
      [45, 82, 171, 255],
      [47, 80, 173, 255],
      [49, 78, 175, 255],
      [51, 76, 177, 255],
      [53, 74, 179, 255],
      [55, 72, 181, 255],
      [57, 70, 183, 255],
      [59, 68, 185, 255],
      [61, 66, 187, 255],
      [63, 64, 189, 255],
      [65, 63, 191, 255],
      [67, 61, 193, 255],
      [69, 59, 195, 255],
      [71, 57, 197, 255],
      [73, 55, 199, 255],
      [75, 53, 201, 255],
      [77, 51, 203, 255],
      [79, 49, 205, 255],
      [81, 47, 207, 255],
      [83, 45, 209, 255],
      [85, 43, 211, 255],
      [86, 41, 213, 255],
      [88, 39, 215, 255],
      [90, 37, 217, 255],
      [92, 35, 219, 255],
      [94, 33, 221, 255],
      [96, 31, 223, 255],
      [98, 29, 225, 255],
      [100, 27, 227, 255],
      [102, 25, 229, 255],
      [104, 23, 231, 255],
      [106, 21, 233, 255],
      [108, 19, 235, 255],
      [110, 17, 237, 255],
      [112, 15, 239, 255],
      [114, 13, 241, 255],
      [116, 11, 243, 255],
      [118, 9, 245, 255],
      [120, 7, 247, 255],
      [122, 5, 249, 255],
      [124, 3, 251, 255],
      [126, 1, 253, 255],
      [128, 0, 255, 255],
      [130, 2, 252, 255],
      [132, 4, 248, 255],
      [134, 6, 244, 255],
      [136, 8, 240, 255],
      [138, 10, 236, 255],
      [140, 12, 232, 255],
      [142, 14, 228, 255],
      [144, 16, 224, 255],
      [146, 18, 220, 255],
      [148, 20, 216, 255],
      [150, 22, 212, 255],
      [152, 24, 208, 255],
      [154, 26, 204, 255],
      [156, 28, 200, 255],
      [158, 30, 196, 255],
      [160, 32, 192, 255],
      [162, 34, 188, 255],
      [164, 36, 184, 255],
      [166, 38, 180, 255],
      [168, 40, 176, 255],
      [170, 42, 172, 255],
      [171, 44, 168, 255],
      [173, 46, 164, 255],
      [175, 48, 160, 255],
      [177, 50, 156, 255],
      [179, 52, 152, 255],
      [181, 54, 148, 255],
      [183, 56, 144, 255],
      [185, 58, 140, 255],
      [187, 60, 136, 255],
      [189, 62, 132, 255],
      [191, 64, 128, 255],
      [193, 66, 124, 255],
      [195, 68, 120, 255],
      [197, 70, 116, 255],
      [199, 72, 112, 255],
      [201, 74, 108, 255],
      [203, 76, 104, 255],
      [205, 78, 100, 255],
      [207, 80, 96, 255],
      [209, 82, 92, 255],
      [211, 84, 88, 255],
      [213, 86, 84, 255],
      [215, 88, 80, 255],
      [217, 90, 76, 255],
      [219, 92, 72, 255],
      [221, 94, 68, 255],
      [223, 96, 64, 255],
      [225, 98, 60, 255],
      [227, 100, 56, 255],
      [229, 102, 52, 255],
      [231, 104, 48, 255],
      [233, 106, 44, 255],
      [235, 108, 40, 255],
      [237, 110, 36, 255],
      [239, 112, 32, 255],
      [241, 114, 28, 255],
      [243, 116, 24, 255],
      [245, 118, 20, 255],
      [247, 120, 16, 255],
      [249, 122, 12, 255],
      [251, 124, 8, 255],
      [253, 126, 4, 255],
      [255, 128, 0, 255],
      [255, 130, 4, 255],
      [255, 132, 8, 255],
      [255, 134, 12, 255],
      [255, 136, 16, 255],
      [255, 138, 20, 255],
      [255, 140, 24, 255],
      [255, 142, 28, 255],
      [255, 144, 32, 255],
      [255, 146, 36, 255],
      [255, 148, 40, 255],
      [255, 150, 44, 255],
      [255, 152, 48, 255],
      [255, 154, 52, 255],
      [255, 156, 56, 255],
      [255, 158, 60, 255],
      [255, 160, 64, 255],
      [255, 162, 68, 255],
      [255, 164, 72, 255],
      [255, 166, 76, 255],
      [255, 168, 80, 255],
      [255, 170, 85, 255],
      [255, 172, 89, 255],
      [255, 174, 93, 255],
      [255, 176, 97, 255],
      [255, 178, 101, 255],
      [255, 180, 105, 255],
      [255, 182, 109, 255],
      [255, 184, 113, 255],
      [255, 186, 117, 255],
      [255, 188, 121, 255],
      [255, 190, 125, 255],
      [255, 192, 129, 255],
      [255, 194, 133, 255],
      [255, 196, 137, 255],
      [255, 198, 141, 255],
      [255, 200, 145, 255],
      [255, 202, 149, 255],
      [255, 204, 153, 255],
      [255, 206, 157, 255],
      [255, 208, 161, 255],
      [255, 210, 165, 255],
      [255, 212, 170, 255],
      [255, 214, 174, 255],
      [255, 216, 178, 255],
      [255, 218, 182, 255],
      [255, 220, 186, 255],
      [255, 222, 190, 255],
      [255, 224, 194, 255],
      [255, 226, 198, 255],
      [255, 228, 202, 255],
      [255, 230, 206, 255],
      [255, 232, 210, 255],
      [255, 234, 214, 255],
      [255, 236, 218, 255],
      [255, 238, 222, 255],
      [255, 240, 226, 255],
      [255, 242, 230, 255],
      [255, 244, 234, 255],
      [255, 246, 238, 255],
      [255, 248, 242, 255],
      [255, 250, 246, 255],
      [255, 252, 250, 255],
      [255, 255, 255, 255]
    ]
  },
  hotMetalBlue: {
    name: "Hot Metal Blue",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 0, 2, 255],
      [0, 0, 4, 255],
      [0, 0, 6, 255],
      [0, 0, 8, 255],
      [0, 0, 10, 255],
      [0, 0, 12, 255],
      [0, 0, 14, 255],
      [0, 0, 16, 255],
      [0, 0, 17, 255],
      [0, 0, 19, 255],
      [0, 0, 21, 255],
      [0, 0, 23, 255],
      [0, 0, 25, 255],
      [0, 0, 27, 255],
      [0, 0, 29, 255],
      [0, 0, 31, 255],
      [0, 0, 33, 255],
      [0, 0, 35, 255],
      [0, 0, 37, 255],
      [0, 0, 39, 255],
      [0, 0, 41, 255],
      [0, 0, 43, 255],
      [0, 0, 45, 255],
      [0, 0, 47, 255],
      [0, 0, 49, 255],
      [0, 0, 51, 255],
      [0, 0, 53, 255],
      [0, 0, 55, 255],
      [0, 0, 57, 255],
      [0, 0, 59, 255],
      [0, 0, 61, 255],
      [0, 0, 63, 255],
      [0, 0, 65, 255],
      [0, 0, 67, 255],
      [0, 0, 69, 255],
      [0, 0, 71, 255],
      [0, 0, 73, 255],
      [0, 0, 75, 255],
      [0, 0, 77, 255],
      [0, 0, 79, 255],
      [0, 0, 81, 255],
      [0, 0, 83, 255],
      [0, 0, 84, 255],
      [0, 0, 86, 255],
      [0, 0, 88, 255],
      [0, 0, 90, 255],
      [0, 0, 92, 255],
      [0, 0, 94, 255],
      [0, 0, 96, 255],
      [0, 0, 98, 255],
      [0, 0, 100, 255],
      [0, 0, 102, 255],
      [0, 0, 104, 255],
      [0, 0, 106, 255],
      [0, 0, 108, 255],
      [0, 0, 110, 255],
      [0, 0, 112, 255],
      [0, 0, 114, 255],
      [0, 0, 116, 255],
      [0, 0, 117, 255],
      [0, 0, 119, 255],
      [0, 0, 121, 255],
      [0, 0, 123, 255],
      [0, 0, 125, 255],
      [0, 0, 127, 255],
      [0, 0, 129, 255],
      [0, 0, 131, 255],
      [0, 0, 133, 255],
      [0, 0, 135, 255],
      [0, 0, 137, 255],
      [0, 0, 139, 255],
      [0, 0, 141, 255],
      [0, 0, 143, 255],
      [0, 0, 145, 255],
      [0, 0, 147, 255],
      [0, 0, 149, 255],
      [0, 0, 151, 255],
      [0, 0, 153, 255],
      [0, 0, 155, 255],
      [0, 0, 157, 255],
      [0, 0, 159, 255],
      [0, 0, 161, 255],
      [0, 0, 163, 255],
      [0, 0, 165, 255],
      [0, 0, 167, 255],
      [3, 0, 169, 255],
      [6, 0, 171, 255],
      [9, 0, 173, 255],
      [12, 0, 175, 255],
      [15, 0, 177, 255],
      [18, 0, 179, 255],
      [21, 0, 181, 255],
      [24, 0, 183, 255],
      [26, 0, 184, 255],
      [29, 0, 186, 255],
      [32, 0, 188, 255],
      [35, 0, 190, 255],
      [38, 0, 192, 255],
      [41, 0, 194, 255],
      [44, 0, 196, 255],
      [47, 0, 198, 255],
      [50, 0, 200, 255],
      [52, 0, 197, 255],
      [55, 0, 194, 255],
      [57, 0, 191, 255],
      [59, 0, 188, 255],
      [62, 0, 185, 255],
      [64, 0, 182, 255],
      [66, 0, 179, 255],
      [69, 0, 176, 255],
      [71, 0, 174, 255],
      [74, 0, 171, 255],
      [76, 0, 168, 255],
      [78, 0, 165, 255],
      [81, 0, 162, 255],
      [83, 0, 159, 255],
      [85, 0, 156, 255],
      [88, 0, 153, 255],
      [90, 0, 150, 255],
      [93, 2, 144, 255],
      [96, 4, 138, 255],
      [99, 6, 132, 255],
      [102, 8, 126, 255],
      [105, 9, 121, 255],
      [108, 11, 115, 255],
      [111, 13, 109, 255],
      [114, 15, 103, 255],
      [116, 17, 97, 255],
      [119, 19, 91, 255],
      [122, 21, 85, 255],
      [125, 23, 79, 255],
      [128, 24, 74, 255],
      [131, 26, 68, 255],
      [134, 28, 62, 255],
      [137, 30, 56, 255],
      [140, 32, 50, 255],
      [143, 34, 47, 255],
      [146, 36, 44, 255],
      [149, 38, 41, 255],
      [152, 40, 38, 255],
      [155, 41, 35, 255],
      [158, 43, 32, 255],
      [161, 45, 29, 255],
      [164, 47, 26, 255],
      [166, 49, 24, 255],
      [169, 51, 21, 255],
      [172, 53, 18, 255],
      [175, 55, 15, 255],
      [178, 56, 12, 255],
      [181, 58, 9, 255],
      [184, 60, 6, 255],
      [187, 62, 3, 255],
      [190, 64, 0, 255],
      [194, 66, 0, 255],
      [198, 68, 0, 255],
      [201, 70, 0, 255],
      [205, 72, 0, 255],
      [209, 73, 0, 255],
      [213, 75, 0, 255],
      [217, 77, 0, 255],
      [221, 79, 0, 255],
      [224, 81, 0, 255],
      [228, 83, 0, 255],
      [232, 85, 0, 255],
      [236, 87, 0, 255],
      [240, 88, 0, 255],
      [244, 90, 0, 255],
      [247, 92, 0, 255],
      [251, 94, 0, 255],
      [255, 96, 0, 255],
      [255, 98, 3, 255],
      [255, 100, 6, 255],
      [255, 102, 9, 255],
      [255, 104, 12, 255],
      [255, 105, 15, 255],
      [255, 107, 18, 255],
      [255, 109, 21, 255],
      [255, 111, 24, 255],
      [255, 113, 26, 255],
      [255, 115, 29, 255],
      [255, 117, 32, 255],
      [255, 119, 35, 255],
      [255, 120, 38, 255],
      [255, 122, 41, 255],
      [255, 124, 44, 255],
      [255, 126, 47, 255],
      [255, 128, 50, 255],
      [255, 130, 53, 255],
      [255, 132, 56, 255],
      [255, 134, 59, 255],
      [255, 136, 62, 255],
      [255, 137, 65, 255],
      [255, 139, 68, 255],
      [255, 141, 71, 255],
      [255, 143, 74, 255],
      [255, 145, 76, 255],
      [255, 147, 79, 255],
      [255, 149, 82, 255],
      [255, 151, 85, 255],
      [255, 152, 88, 255],
      [255, 154, 91, 255],
      [255, 156, 94, 255],
      [255, 158, 97, 255],
      [255, 160, 100, 255],
      [255, 162, 103, 255],
      [255, 164, 106, 255],
      [255, 166, 109, 255],
      [255, 168, 112, 255],
      [255, 169, 115, 255],
      [255, 171, 118, 255],
      [255, 173, 121, 255],
      [255, 175, 124, 255],
      [255, 177, 126, 255],
      [255, 179, 129, 255],
      [255, 181, 132, 255],
      [255, 183, 135, 255],
      [255, 184, 138, 255],
      [255, 186, 141, 255],
      [255, 188, 144, 255],
      [255, 190, 147, 255],
      [255, 192, 150, 255],
      [255, 194, 153, 255],
      [255, 196, 156, 255],
      [255, 198, 159, 255],
      [255, 200, 162, 255],
      [255, 201, 165, 255],
      [255, 203, 168, 255],
      [255, 205, 171, 255],
      [255, 207, 174, 255],
      [255, 209, 176, 255],
      [255, 211, 179, 255],
      [255, 213, 182, 255],
      [255, 215, 185, 255],
      [255, 216, 188, 255],
      [255, 218, 191, 255],
      [255, 220, 194, 255],
      [255, 222, 197, 255],
      [255, 224, 200, 255],
      [255, 226, 203, 255],
      [255, 228, 206, 255],
      [255, 229, 210, 255],
      [255, 231, 213, 255],
      [255, 233, 216, 255],
      [255, 235, 219, 255],
      [255, 237, 223, 255],
      [255, 239, 226, 255],
      [255, 240, 229, 255],
      [255, 242, 232, 255],
      [255, 244, 236, 255],
      [255, 246, 239, 255],
      [255, 248, 242, 255],
      [255, 250, 245, 255],
      [255, 251, 249, 255],
      [255, 253, 252, 255],
      [255, 255, 255, 255]
    ]
  },
  pet20Step: {
    name: "PET 20 Step",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255]
    ]
  },
  gray: {
    name: "Gray",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [1, 1, 1]
      ]
    }
  },
  jet: {
    name: "Jet",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.35, 0, 0],
        [0.66, 1, 1],
        [0.89, 1, 1],
        [1, 0.5, 0.5]
      ],
      green: [
        [0, 0, 0],
        [0.125, 0, 0],
        [0.375, 1, 1],
        [0.64, 1, 1],
        [0.91, 0, 0],
        [1, 0, 0]
      ],
      blue: [
        [0, 0.5, 0.5],
        [0.11, 1, 1],
        [0.34, 1, 1],
        [0.65, 0, 0],
        [1, 0, 0]
      ]
    }
  },
  hsv: {
    name: "HSV",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [0.15873, 1, 1],
        [0.174603, 0.96875, 0.96875],
        [0.333333, 0.03125, 0.03125],
        [0.349206, 0, 0],
        [0.666667, 0, 0],
        [0.68254, 0.03125, 0.03125],
        [0.84127, 0.96875, 0.96875],
        [0.857143, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.15873, 0.9375, 0.9375],
        [0.174603, 1, 1],
        [0.507937, 1, 1],
        [0.666667, 0.0625, 0.0625],
        [0.68254, 0, 0],
        [1, 0, 0]
      ],
      blue: [
        [0, 0, 0],
        [0.333333, 0, 0],
        [0.349206, 0.0625, 0.0625],
        [0.507937, 1, 1],
        [0.84127, 1, 1],
        [0.857143, 0.9375, 0.9375],
        [1, 0.09375, 0.09375]
      ]
    }
  },
  hot: {
    name: "Hot",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.0416, 0.0416],
        [0.365079, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.365079, 0, 0],
        [0.746032, 1, 1],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [0.746032, 0, 0],
        [1, 1, 1]
      ]
    }
  },
  cool: {
    name: "Cool",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 1, 1],
        [1, 0, 0]
      ],
      blue: [
        [0, 1, 1],
        [1, 1, 1]
      ]
    }
  },
  spring: {
    name: "Spring",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 1, 1],
        [1, 0, 0]
      ]
    }
  },
  summer: {
    name: "Summer",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 0.5, 0.5],
        [1, 1, 1]
      ],
      blue: [
        [0, 0.4, 0.4],
        [1, 0.4, 0.4]
      ]
    }
  },
  autumn: {
    name: "Autumn",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [1, 0, 0]
      ]
    }
  },
  winter: {
    name: "Winter",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 0, 0]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 1, 1],
        [1, 0.5, 0.5]
      ]
    }
  },
  bone: {
    name: "Bone",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.746032, 0.652778, 0.652778],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.365079, 0.319444, 0.319444],
        [0.746032, 0.777778, 0.777778],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [0.365079, 0.444444, 0.444444],
        [1, 1, 1]
      ]
    }
  },
  copper: {
    name: "Copper",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.809524, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 0.7812, 0.7812]
      ],
      blue: [
        [0, 0, 0],
        [1, 0.4975, 0.4975]
      ]
    }
  },
  spectral: {
    name: "Spectral",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.05, 0.4667, 0.4667],
        [0.1, 0.5333, 0.5333],
        [0.15, 0, 0],
        [0.2, 0, 0],
        [0.25, 0, 0],
        [0.3, 0, 0],
        [0.35, 0, 0],
        [0.4, 0, 0],
        [0.45, 0, 0],
        [0.5, 0, 0],
        [0.55, 0, 0],
        [0.6, 0, 0],
        [0.65, 0.7333, 0.7333],
        [0.7, 0.9333, 0.9333],
        [0.75, 1, 1],
        [0.8, 1, 1],
        [0.85, 1, 1],
        [0.9, 0.8667, 0.8667],
        [0.95, 0.8, 0.8],
        [1, 0.8, 0.8]
      ],
      green: [
        [0, 0, 0],
        [0.05, 0, 0],
        [0.1, 0, 0],
        [0.15, 0, 0],
        [0.2, 0, 0],
        [0.25, 0.4667, 0.4667],
        [0.3, 0.6, 0.6],
        [0.35, 0.6667, 0.6667],
        [0.4, 0.6667, 0.6667],
        [0.45, 0.6, 0.6],
        [0.5, 0.7333, 0.7333],
        [0.55, 0.8667, 0.8667],
        [0.6, 1, 1],
        [0.65, 1, 1],
        [0.7, 0.9333, 0.9333],
        [0.75, 0.8, 0.8],
        [0.8, 0.6, 0.6],
        [0.85, 0, 0],
        [0.9, 0, 0],
        [0.95, 0, 0],
        [1, 0.8, 0.8]
      ],
      blue: [
        [0, 0, 0],
        [0.05, 0.5333, 0.5333],
        [0.1, 0.6, 0.6],
        [0.15, 0.6667, 0.6667],
        [0.2, 0.8667, 0.8667],
        [0.25, 0.8667, 0.8667],
        [0.3, 0.8667, 0.8667],
        [0.35, 0.6667, 0.6667],
        [0.4, 0.5333, 0.5333],
        [0.45, 0, 0],
        [0.5, 0, 0],
        [0.55, 0, 0],
        [0.6, 0, 0],
        [0.65, 0, 0],
        [0.7, 0, 0],
        [0.75, 0, 0],
        [0.8, 0, 0],
        [0.85, 0, 0],
        [0.9, 0, 0],
        [0.95, 0, 0],
        [1, 0.8, 0.8]
      ]
    }
  },
  coolwarm: {
    name: "CoolWarm",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.2298057, 0.2298057],
        [0.03125, 0.26623388, 0.26623388],
        [0.0625, 0.30386891, 0.30386891],
        [0.09375, 0.342804478, 0.342804478],
        [0.125, 0.38301334, 0.38301334],
        [0.15625, 0.424369608, 0.424369608],
        [0.1875, 0.46666708, 0.46666708],
        [0.21875, 0.509635204, 0.509635204],
        [0.25, 0.552953156, 0.552953156],
        [0.28125, 0.596262162, 0.596262162],
        [0.3125, 0.639176211, 0.639176211],
        [0.34375, 0.681291281, 0.681291281],
        [0.375, 0.722193294, 0.722193294],
        [0.40625, 0.761464949, 0.761464949],
        [0.4375, 0.798691636, 0.798691636],
        [0.46875, 0.833466556, 0.833466556],
        [0.5, 0.865395197, 0.865395197],
        [0.53125, 0.897787179, 0.897787179],
        [0.5625, 0.924127593, 0.924127593],
        [0.59375, 0.944468518, 0.944468518],
        [0.625, 0.958852946, 0.958852946],
        [0.65625, 0.96732803, 0.96732803],
        [0.6875, 0.969954137, 0.969954137],
        [0.71875, 0.966811177, 0.966811177],
        [0.75, 0.958003065, 0.958003065],
        [0.78125, 0.943660866, 0.943660866],
        [0.8125, 0.923944917, 0.923944917],
        [0.84375, 0.89904617, 0.89904617],
        [0.875, 0.869186849, 0.869186849],
        [0.90625, 0.834620542, 0.834620542],
        [0.9375, 0.795631745, 0.795631745],
        [0.96875, 0.752534934, 0.752534934],
        [1, 0.705673158, 0.705673158]
      ],
      green: [
        [0, 0.298717966, 0.298717966],
        [0.03125, 0.353094838, 0.353094838],
        [0.0625, 0.406535296, 0.406535296],
        [0.09375, 0.458757618, 0.458757618],
        [0.125, 0.50941904, 0.50941904],
        [0.15625, 0.558148092, 0.558148092],
        [0.1875, 0.604562568, 0.604562568],
        [0.21875, 0.648280772, 0.648280772],
        [0.25, 0.688929332, 0.688929332],
        [0.28125, 0.726149107, 0.726149107],
        [0.3125, 0.759599947, 0.759599947],
        [0.34375, 0.788964712, 0.788964712],
        [0.375, 0.813952739, 0.813952739],
        [0.40625, 0.834302879, 0.834302879],
        [0.4375, 0.849786142, 0.849786142],
        [0.46875, 0.860207984, 0.860207984],
        [0.5, 0.86541021, 0.86541021],
        [0.53125, 0.848937047, 0.848937047],
        [0.5625, 0.827384882, 0.827384882],
        [0.59375, 0.800927443, 0.800927443],
        [0.625, 0.769767752, 0.769767752],
        [0.65625, 0.734132809, 0.734132809],
        [0.6875, 0.694266682, 0.694266682],
        [0.71875, 0.650421156, 0.650421156],
        [0.75, 0.602842431, 0.602842431],
        [0.78125, 0.551750968, 0.551750968],
        [0.8125, 0.49730856, 0.49730856],
        [0.84375, 0.439559467, 0.439559467],
        [0.875, 0.378313092, 0.378313092],
        [0.90625, 0.312874446, 0.312874446],
        [0.9375, 0.24128379, 0.24128379],
        [0.96875, 0.157246067, 0.157246067],
        [1, 0.01555616, 0.01555616]
      ],
      blue: [
        [0, 0.753683153, 0.753683153],
        [0.03125, 0.801466763, 0.801466763],
        [0.0625, 0.84495867, 0.84495867],
        [0.09375, 0.883725899, 0.883725899],
        [0.125, 0.917387822, 0.917387822],
        [0.15625, 0.945619588, 0.945619588],
        [0.1875, 0.968154911, 0.968154911],
        [0.21875, 0.98478814, 0.98478814],
        [0.25, 0.995375608, 0.995375608],
        [0.28125, 0.999836203, 0.999836203],
        [0.3125, 0.998151185, 0.998151185],
        [0.34375, 0.990363227, 0.990363227],
        [0.375, 0.976574709, 0.976574709],
        [0.40625, 0.956945269, 0.956945269],
        [0.4375, 0.931688648, 0.931688648],
        [0.46875, 0.901068838, 0.901068838],
        [0.5, 0.865395561, 0.865395561],
        [0.53125, 0.820880546, 0.820880546],
        [0.5625, 0.774508472, 0.774508472],
        [0.59375, 0.726736146, 0.726736146],
        [0.625, 0.678007945, 0.678007945],
        [0.65625, 0.628751763, 0.628751763],
        [0.6875, 0.579375448, 0.579375448],
        [0.71875, 0.530263762, 0.530263762],
        [0.75, 0.481775914, 0.481775914],
        [0.78125, 0.434243684, 0.434243684],
        [0.8125, 0.387970225, 0.387970225],
        [0.84375, 0.343229596, 0.343229596],
        [0.875, 0.300267182, 0.300267182],
        [0.90625, 0.259301199, 0.259301199],
        [0.9375, 0.220525627, 0.220525627],
        [0.96875, 0.184115123, 0.184115123],
        [1, 0.150232812, 0.150232812]
      ]
    }
  },
  blues: {
    name: "Blues",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.9686274528503418, 0.9686274528503418],
        [0.125, 0.8705882430076599, 0.8705882430076599],
        [0.25, 0.7764706015586853, 0.7764706015586853],
        [0.375, 0.6196078658103943, 0.6196078658103943],
        [0.5, 0.41960784792900085, 0.41960784792900085],
        [0.625, 0.25882354378700256, 0.25882354378700256],
        [0.75, 0.12941177189350128, 0.12941177189350128],
        [0.875, 0.0313725508749485, 0.0313725508749485],
        [1, 0.0313725508749485, 0.0313725508749485]
      ],
      green: [
        [0, 0.9843137264251709, 0.9843137264251709],
        [0.125, 0.9215686321258545, 0.9215686321258545],
        [0.25, 0.8588235378265381, 0.8588235378265381],
        [0.375, 0.7921568751335144, 0.7921568751335144],
        [0.5, 0.6823529601097107, 0.6823529601097107],
        [0.625, 0.572549045085907, 0.572549045085907],
        [0.75, 0.4431372582912445, 0.4431372582912445],
        [0.875, 0.3176470696926117, 0.3176470696926117],
        [1, 0.1882352977991104, 0.1882352977991104]
      ],
      blue: [
        [0, 1, 1],
        [0.125, 0.9686274528503418, 0.9686274528503418],
        [0.25, 0.9372549057006836, 0.9372549057006836],
        [0.375, 0.8823529481887817, 0.8823529481887817],
        [0.5, 0.8392156958580017, 0.8392156958580017],
        [0.625, 0.7764706015586853, 0.7764706015586853],
        [0.75, 0.7098039388656616, 0.7098039388656616],
        [0.875, 0.6117647290229797, 0.6117647290229797],
        [1, 0.41960784792900085, 0.41960784792900085]
      ]
    }
  }
};
const CPU_COLORMAPS = colormapsData;
const RENDERING_DEFAULTS$1 = {
  MINIMUM_SLAB_THICKNESS: 0.05,
  MAXIMUM_RAY_DISTANCE: 1e6
};
Object.freeze(RENDERING_DEFAULTS$1);
const RENDERING_DEFAULTS$2 = RENDERING_DEFAULTS$1;
const EPSILON$6 = 1e-3;
const EPSILON$7 = EPSILON$6;
function deepFreeze(object3) {
  const propNames = Object.getOwnPropertyNames(object3);
  for (const name of propNames) {
    const value = object3[name];
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  }
  return Object.freeze(object3);
}
const MPR_CAMERA_VALUES = {
  axial: {
    viewPlaneNormal: [0, 0, -1],
    viewUp: [0, -1, 0]
  },
  sagittal: {
    viewPlaneNormal: [1, 0, 0],
    viewUp: [0, 0, 1]
  },
  coronal: {
    viewPlaneNormal: [0, -1, 0],
    viewUp: [0, 0, 1]
  }
};
const mprCameraValues = deepFreeze(MPR_CAMERA_VALUES);
const MPR_CAMERA_VALUES$1 = mprCameraValues;
const presets = [
  {
    name: "CT-AAA",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-AAA2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Bone",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Bones",
    gradientOpacity: "4 0 1 985.12 1",
    specularPower: "1",
    scalarOpacity: "8 -1000 0 152.19 0 278.93 0.190476 952 0.2",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac3",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Chest-Contrast-Enhanced",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Chest-Vessels",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries-2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries-3",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cropped-Volume-Bone",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -2048 0 -451 0 -450 1 1050 1 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Fat",
    gradientOpacity: "6 0 1 985.12 1 988 1",
    specularPower: "1",
    scalarOpacity: "14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Liver-Vasculature",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Lung",
    gradientOpacity: "6 0 1 985.12 1 988 1",
    specularPower: "1",
    scalarOpacity: "12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-MIP",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0 -637.62 0 700 1 3071 1",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Muscle",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Pulmonary-Arteries",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Soft-Tissue",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -2048 0 -167.01 0 -160 1 240 1 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Air",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "MR-Angio",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-Default",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-MIP",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "8 0 0 98.3725 0 416.637 1 2800 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-T2-Brain",
    gradientOpacity: "4 0 1 160.25 1",
    specularPower: "40",
    scalarOpacity: "10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1",
    specular: "0.5",
    shade: "1",
    ambient: "0.3",
    colorTransfer: "16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1",
    diffuse: "0.6",
    interpolation: "1"
  },
  {
    name: "DTI-FA-Brain",
    gradientOpacity: "4 0 1 0.9950 1",
    specularPower: "40",
    scalarOpacity: "16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0",
    specular: "0.5",
    shade: "1",
    ambient: "0.3",
    colorTransfer: "28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0",
    diffuse: "0.9",
    interpolation: "1"
  }
];
const presets$1 = presets;
const CONSTANTS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CPU_COLORMAPS,
  RENDERING_DEFAULTS: RENDERING_DEFAULTS$2,
  MPR_CAMERA_VALUES: MPR_CAMERA_VALUES$1,
  EPSILON: EPSILON$7,
  VIEWPORT_PRESETS: presets$1
}, Symbol.toStringTag, { value: "Module" }));
const cache$2 = {};
const renderingEngineCache = {
  get: (id) => {
    return cache$2[id];
  },
  set: (re) => {
    const renderingEngineId = re.id;
    cache$2[renderingEngineId] = re;
  },
  delete: (id) => {
    return delete cache$2[id];
  },
  getAll: () => {
    const renderingEngineIds = Object.keys(cache$2);
    const renderingEngines = renderingEngineIds.map((id) => cache$2[id]);
    return renderingEngines;
  }
};
const renderingEngineCache$1 = renderingEngineCache;
class CornerstoneEventTarget {
  constructor() {
    this.listeners = {};
  }
  reset() {
    this.listeners = {};
  }
  addEventListener(type, callback) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    if (this.listeners[type].indexOf(callback) !== -1) {
      return;
    }
    this.listeners[type].push(callback);
  }
  removeEventListener(type, callback) {
    if (!this.listeners[type]) {
      return;
    }
    const stack = this.listeners[type];
    const stackLength = stack.length;
    for (let i = 0; i < stackLength; i++) {
      if (stack[i] === callback) {
        stack.splice(i, 1);
        return;
      }
    }
  }
  dispatchEvent(event2) {
    if (!this.listeners[event2.type]) {
      return;
    }
    const stack = this.listeners[event2.type].slice();
    const stackLength = stack.length;
    for (let i = 0; i < stackLength; i++) {
      stack[i].call(this, event2);
    }
    return !event2.defaultPrevented;
  }
}
const eventTarget = new CornerstoneEventTarget();
const eventTarget$1 = eventTarget;
function invertRgbTransferFunction(rgbTransferFunction) {
  const size2 = rgbTransferFunction.getSize();
  for (let index2 = 0; index2 < size2; index2++) {
    const nodeValue1 = [];
    rgbTransferFunction.getNodeValue(index2, nodeValue1);
    nodeValue1[1] = 1 - nodeValue1[1];
    nodeValue1[2] = 1 - nodeValue1[2];
    nodeValue1[3] = 1 - nodeValue1[3];
    rgbTransferFunction.setNodeValue(index2, nodeValue1);
  }
}
function triggerEvent(el = eventTarget$1, type, detail = null) {
  if (!type) {
    throw new Error("Event type was not defined");
  }
  const event2 = new CustomEvent(type, {
    detail,
    cancelable: true
  });
  return el.dispatchEvent(event2);
}
function uuidv4() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}
function getMinMax(storedPixelData) {
  let min2 = storedPixelData[0];
  let max2 = storedPixelData[0];
  let storedPixel;
  const numPixels = storedPixelData.length;
  for (let index2 = 1; index2 < numPixels; index2++) {
    storedPixel = storedPixelData[index2];
    min2 = Math.min(min2, storedPixel);
    max2 = Math.max(max2, storedPixel);
  }
  return {
    min: min2,
    max: max2
  };
}
function imageIdToURI(imageId) {
  const colonIndex = imageId.indexOf(":");
  return imageId.substring(colonIndex + 1);
}
function isEqual(v1, v2, tolerance = 1e-5) {
  if (v1.length !== v2.length) {
    return false;
  }
  for (let i = 0; i < v1.length; i++) {
    if (Math.abs(v1[i] - v2[i]) > tolerance) {
      return false;
    }
  }
  return true;
}
function isOpposite(v1, v2, tolerance = 1e-5) {
  return Math.abs(v1[0] + v2[0]) < tolerance && Math.abs(v1[1] + v2[1]) < tolerance && Math.abs(v1[2] + v2[2]) < tolerance;
}
var EPSILON$5 = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
function toRadian(a) {
  return a * degree;
}
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$5() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function fromValues$4(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity$2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function invert$1(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply$3(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function create$4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function copy$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function identity$1(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale$2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON$5) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX$1(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY$1(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ$1(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c, t;
  if (len2 < EPSILON$5) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is22 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is22;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is22;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is22;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON$5 && Math.abs(eyey - centery) < EPSILON$5 && Math.abs(eyez - centerz) < EPSILON$5) {
    return identity$1(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len2 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len2;
  z1 *= len2;
  z2 *= len2;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len2 = Math.hypot(x0, x1, x2);
  if (!len2) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len2 = 1 / len2;
    x0 *= len2;
    x1 *= len2;
    x2 *= len2;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len2 = Math.hypot(y0, y1, y2);
  if (!len2) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len2 = 1 / len2;
    y0 *= len2;
    y1 *= len2;
    y2 *= len2;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
var mul$1 = multiply$2;
function create$3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone$1(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues$3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set$1(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add$2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract$3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply$1(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil$1(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor$1(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min$1(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max$1(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round$1(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale$1(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale2) {
  out[0] = a[0] + b[0] * scale2;
  out[1] = a[1] + b[1] * scale2;
  out[2] = a[2] + b[2] * scale2;
  return out;
}
function distance$1(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize$4(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross$1(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random$1(out, scale2) {
  scale2 = scale2 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale2;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale2;
  return out;
}
function transformMat4$1(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p2 = [], r = [];
  p2[0] = a[0] - b[0];
  p2[1] = a[1] - b[1];
  p2[2] = a[2] - b[2];
  r[0] = p2[0];
  r[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p2 = [], r = [];
  p2[0] = a[0] - b[0];
  p2[1] = a[1] - b[1];
  p2[2] = a[2] - b[2];
  r[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r[1] = p2[1];
  r[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p2 = [], r = [];
  p2[0] = a[0] - b[0];
  p2[1] = a[1] - b[1];
  p2[2] = a[2] - b[2];
  r[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r[2] = p2[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle$1(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot$1(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON$5 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$5 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$5 * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub$1 = subtract$3;
var mul = multiply$1;
var div = divide;
var dist = distance$1;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach$2 = function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
const vec3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: create$3,
  clone: clone$1,
  length,
  fromValues: fromValues$3,
  copy,
  set: set$1,
  add: add$2,
  subtract: subtract$3,
  multiply: multiply$1,
  divide,
  ceil: ceil$1,
  floor: floor$1,
  min: min$1,
  max: max$1,
  round: round$1,
  scale: scale$1,
  scaleAndAdd,
  distance: distance$1,
  squaredDistance,
  squaredLength,
  negate,
  inverse,
  normalize: normalize$4,
  dot: dot$1,
  cross: cross$1,
  lerp,
  hermite,
  bezier,
  random: random$1,
  transformMat4: transformMat4$1,
  transformMat3,
  transformQuat,
  rotateX,
  rotateY,
  rotateZ,
  angle: angle$1,
  zero,
  str,
  exactEquals,
  equals,
  sub: sub$1,
  mul,
  div,
  dist,
  sqrDist,
  len,
  sqrLen,
  forEach: forEach$2
}, Symbol.toStringTag, { value: "Module" }));
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function fromValues$2(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function subtract$2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function normalize$3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
(function() {
  var vec = create$2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON$5) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function multiply(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON$5) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var fromValues$1 = fromValues$2;
var normalize$2 = normalize$3;
(function() {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues$3(1, 0, 0);
  var yUnitVec3 = fromValues$3(0, 1, 0);
  return function(out, a, b) {
    var dot2 = dot$1(a, b);
    if (dot2 < -0.999999) {
      cross$1(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross$1(tmpvec3, yUnitVec3, a);
      normalize$4(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$1(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize$2(out, out);
    }
  };
})();
(function() {
  var temp1 = create$1();
  var temp2 = create$1();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$5();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$2(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract$1(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function normalize$1(out, a) {
  var x = a[0], y = a[1];
  var len2 = x * x + y * y;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  return out;
}
function angle(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
var sub = subtract$1;
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
const providers = [];
function getMetaData(type, query) {
  for (let i = 0; i < providers.length; i++) {
    const result = providers[i].provider(type, query);
    if (result !== void 0) {
      return result;
    }
  }
}
function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {
  const { direction, spacing } = imageVolume;
  const iVector = direction.slice(0, 3);
  const jVector = direction.slice(3, 6);
  const kVector = direction.slice(6, 9);
  const dotProducts = [
    dot$1(iVector, viewPlaneNormal),
    dot$1(jVector, viewPlaneNormal),
    dot$1(kVector, viewPlaneNormal)
  ];
  const projectedSpacing = create$3();
  set$1(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);
  const spacingInNormalDirection = length(projectedSpacing);
  return spacingInNormalDirection;
}
function getClosestImageId(imageVolume, worldPos, viewPlaneNormal, viewUp) {
  if (!imageVolume) {
    return;
  }
  const { direction, imageIds } = imageVolume;
  if (!imageIds || !imageIds.length) {
    return;
  }
  const kVector = direction.slice(6, 9);
  const dotProducts = dot$1(kVector, viewPlaneNormal);
  if (Math.abs(dotProducts) < 0.99) {
    return;
  }
  const spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
  let imageIdForTool;
  for (let i = 0; i < imageIds.length; i++) {
    const imageId = imageIds[i];
    const { imagePositionPatient } = getMetaData("imagePlaneModule", imageId);
    const dir = create$3();
    sub$1(dir, worldPos, imagePositionPatient);
    const dot2 = dot$1(dir, viewPlaneNormal);
    if (Math.abs(dot2) < halfSpacingInNormalDirection) {
      imageIdForTool = imageId;
    }
  }
  return imageIdForTool;
}
const MAX_CACHE_SIZE_1GB = 1073741824;
class Cache {
  constructor() {
    this.setMaxCacheSize = (newMaxCacheSize) => {
      if (!newMaxCacheSize || typeof newMaxCacheSize !== "number") {
        const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
        throw new Error(errorMessage);
      }
      this._maxCacheSize = newMaxCacheSize;
    };
    this.isCacheable = (byteLength) => {
      const unallocatedSpace = this.getBytesAvailable();
      const imageCacheSize = this._imageCacheSize;
      const availableSpace = unallocatedSpace + imageCacheSize;
      return availableSpace > byteLength;
    };
    this.getMaxCacheSize = () => this._maxCacheSize;
    this.getCacheSize = () => this._imageCacheSize + this._volumeCacheSize;
    this._decacheImage = (imageId) => {
      const { imageLoadObject } = this._imageCache.get(imageId);
      if (imageLoadObject.cancelFn) {
        imageLoadObject.cancelFn();
      }
      if (imageLoadObject.decache) {
        imageLoadObject.decache();
      }
      this._imageCache.delete(imageId);
    };
    this._decacheVolume = (volumeId) => {
      const cachedVolume = this._volumeCache.get(volumeId);
      const { volumeLoadObject, volume } = cachedVolume;
      if (volume.cancelLoading) {
        volume.cancelLoading();
      }
      if (volume.imageData) {
        volume.imageData = null;
      }
      if (volumeLoadObject.cancelFn) {
        volumeLoadObject.cancelFn();
      }
      if (volumeLoadObject.decache) {
        volumeLoadObject.decache();
      }
      this._volumeCache.delete(volumeId);
    };
    this.purgeCache = () => {
      const imageIterator = this._imageCache.keys();
      while (true) {
        const { value: imageId, done } = imageIterator.next();
        if (done) {
          break;
        }
        this.removeImageLoadObject(imageId);
        triggerEvent(eventTarget$1, Events$2.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      }
      this.purgeVolumeCache();
    };
    this.purgeVolumeCache = () => {
      const volumeIterator = this._volumeCache.keys();
      while (true) {
        const { value: volumeId, done } = volumeIterator.next();
        if (done) {
          break;
        }
        this.removeVolumeLoadObject(volumeId);
        triggerEvent(eventTarget$1, Events$2.VOLUME_CACHE_VOLUME_REMOVED, {
          volumeId
        });
      }
    };
    this.getVolumeLoadObject = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("getVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        return;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volumeLoadObject;
    };
    this.getVolume = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("getVolume: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        return;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volume;
    };
    this.removeImageLoadObject = (imageId) => {
      if (imageId === void 0) {
        throw new Error("removeImageLoadObject: imageId must not be undefined");
      }
      const cachedImage = this._imageCache.get(imageId);
      if (cachedImage === void 0) {
        throw new Error("removeImageLoadObject: imageId was not present in imageCache");
      }
      this._incrementImageCacheSize(-cachedImage.sizeInBytes);
      const eventDetails = {
        imageId
      };
      triggerEvent(eventTarget$1, Events$2.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);
      this._decacheImage(imageId);
    };
    this.removeVolumeLoadObject = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
      }
      this._incrementVolumeCacheSize(-cachedVolume.sizeInBytes);
      const eventDetails = {
        volume: cachedVolume,
        volumeId
      };
      triggerEvent(eventTarget$1, Events$2.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);
      this._decacheVolume(volumeId);
    };
    this._incrementImageCacheSize = (increment) => {
      this._imageCacheSize += increment;
    };
    this._incrementVolumeCacheSize = (increment) => {
      this._volumeCacheSize += increment;
    };
    this._imageCache = /* @__PURE__ */ new Map();
    this._volumeCache = /* @__PURE__ */ new Map();
    this._imageCacheSize = 0;
    this._volumeCacheSize = 0;
    this._maxCacheSize = MAX_CACHE_SIZE_1GB;
  }
  getBytesAvailable() {
    return this.getMaxCacheSize() - this.getCacheSize();
  }
  decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {
    let bytesAvailable = this.getBytesAvailable();
    if (bytesAvailable >= numBytes) {
      return bytesAvailable;
    }
    let cachedImages = Array.from(this._imageCache.values());
    function compare(a, b) {
      if (a.timeStamp > b.timeStamp) {
        return 1;
      }
      if (a.timeStamp < b.timeStamp) {
        return -1;
      }
      return 0;
    }
    cachedImages.sort(compare);
    let cachedImageIds = cachedImages.map((im) => im.imageId);
    let imageIdsToPurge = cachedImageIds;
    if (volumeImageIds) {
      imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));
    }
    for (const imageId of imageIdsToPurge) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget$1, Events$2.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
    cachedImages = Array.from(this._imageCache.values());
    cachedImageIds = cachedImages.map((im) => im.imageId);
    for (const imageId of cachedImageIds) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget$1, Events$2.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
  }
  putImageLoadObject(imageId, imageLoadObject) {
    if (imageId === void 0) {
      throw new Error("putImageLoadObject: imageId must not be undefined");
    }
    if (imageLoadObject.promise === void 0) {
      throw new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
    }
    if (this._imageCache.has(imageId)) {
      throw new Error("putImageLoadObject: imageId already in cache");
    }
    if (imageLoadObject.cancelFn && typeof imageLoadObject.cancelFn !== "function") {
      throw new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
    }
    const cachedImage = {
      loaded: false,
      imageId,
      sharedCacheKey: void 0,
      imageLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._imageCache.set(imageId, cachedImage);
    return imageLoadObject.promise.then((image) => {
      if (!this._imageCache.get(imageId)) {
        console.warn("The image was purged from the cache before it completed loading.");
        return;
      }
      if (image.sizeInBytes === void 0) {
        throw new Error("putImageLoadObject: image.sizeInBytes must not be undefined");
      }
      if (image.sizeInBytes.toFixed === void 0) {
        throw new Error("putImageLoadObject: image.sizeInBytes is not a number");
      }
      if (!this.isCacheable(image.sizeInBytes)) {
        throw new Error(Events$2.CACHE_SIZE_EXCEEDED);
      }
      this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);
      cachedImage.loaded = true;
      cachedImage.image = image;
      cachedImage.sizeInBytes = image.sizeInBytes;
      this._incrementImageCacheSize(cachedImage.sizeInBytes);
      const eventDetails = {
        image: cachedImage
      };
      triggerEvent(eventTarget$1, Events$2.IMAGE_CACHE_IMAGE_ADDED, eventDetails);
      cachedImage.sharedCacheKey = image.sharedCacheKey;
    }).catch((error) => {
      this._imageCache.delete(imageId);
      throw error;
    });
  }
  getImageLoadObject(imageId) {
    if (imageId === void 0) {
      throw new Error("getImageLoadObject: imageId must not be undefined");
    }
    const cachedImage = this._imageCache.get(imageId);
    if (cachedImage === void 0) {
      return;
    }
    cachedImage.timeStamp = Date.now();
    return cachedImage.imageLoadObject;
  }
  isImageIdCached(imageId) {
    const cachedImage = this._imageCache.get(imageId);
    if (!cachedImage) {
      return false;
    }
    return cachedImage.loaded;
  }
  getVolumeContainingImageId(imageId) {
    const volumeIds = Array.from(this._volumeCache.keys());
    const imageIdToUse = imageIdToURI(imageId);
    for (const volumeId of volumeIds) {
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume.volume) {
        return;
      }
      let { imageIds } = cachedVolume.volume;
      if (!imageIds || imageIds.length === 0) {
        continue;
      }
      imageIds = imageIds.map((id) => imageIdToURI(id));
      const imageIdIndex = imageIds.indexOf(imageIdToUse);
      if (imageIdIndex > -1) {
        return { volume: cachedVolume.volume, imageIdIndex };
      }
    }
  }
  getCachedImageBasedOnImageURI(imageId) {
    const imageURIToUse = imageIdToURI(imageId);
    const cachedImageIds = Array.from(this._imageCache.keys());
    const foundImageId = cachedImageIds.find((imageId2) => {
      return imageIdToURI(imageId2) === imageURIToUse;
    });
    if (!foundImageId) {
      return;
    }
    return this._imageCache.get(foundImageId);
  }
  putVolumeLoadObject(volumeId, volumeLoadObject) {
    if (volumeId === void 0) {
      throw new Error("putVolumeLoadObject: volumeId must not be undefined");
    }
    if (volumeLoadObject.promise === void 0) {
      throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
    }
    if (this._volumeCache.has(volumeId)) {
      throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);
    }
    if (volumeLoadObject.cancelFn && typeof volumeLoadObject.cancelFn !== "function") {
      throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
    }
    const cachedVolume = {
      loaded: false,
      volumeId,
      volumeLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._volumeCache.set(volumeId, cachedVolume);
    return volumeLoadObject.promise.then((volume) => {
      if (!this._volumeCache.get(volumeId)) {
        console.warn("The image was purged from the cache before it completed loading.");
        return;
      }
      if (volume.sizeInBytes === void 0) {
        throw new Error("putVolumeLoadObject: volume.sizeInBytes must not be undefined");
      }
      if (volume.sizeInBytes.toFixed === void 0) {
        throw new Error("putVolumeLoadObject: volume.sizeInBytes is not a number");
      }
      this.decacheIfNecessaryUntilBytesAvailable(volume.sizeInBytes, volume.imageIds);
      cachedVolume.volume = volume;
      cachedVolume.sizeInBytes = volume.sizeInBytes;
      this._incrementVolumeCacheSize(cachedVolume.sizeInBytes);
      const eventDetails = {
        volume: cachedVolume
      };
      triggerEvent(eventTarget$1, Events$2.VOLUME_CACHE_VOLUME_ADDED, eventDetails);
    }).catch((error) => {
      this._volumeCache.delete(volumeId);
      throw error;
    });
  }
}
const cache = new Cache();
const cache$1 = cache;
function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId) {
  const { viewPlaneNormal } = camera;
  const volumeActors = viewport.getActors();
  if (!volumeActors || !volumeActors.length) {
    return { spacingInNormalDirection: null, imageVolume: null };
  }
  const numVolumeActors = volumeActors.length;
  const imageVolumes = volumeActors.map((va) => {
    const uid2 = va.referenceId ?? va.uid;
    return cache$1.getVolume(uid2);
  });
  if (targetVolumeId) {
    const imageVolume = imageVolumes.find((iv) => iv.volumeId === targetVolumeId);
    const spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
    return { imageVolume, spacingInNormalDirection };
  }
  const smallest = {
    spacingInNormalDirection: Infinity,
    imageVolume: null
  };
  for (let i = 0; i < numVolumeActors; i++) {
    const imageVolume = imageVolumes[i];
    const spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
    if (spacingInNormalDirection < smallest.spacingInNormalDirection) {
      smallest.spacingInNormalDirection = spacingInNormalDirection;
      smallest.imageVolume = imageVolume;
    }
  }
  return smallest;
}
function getVolumeActorCorners(volumeActor) {
  const imageData = volumeActor.getMapper().getInputData();
  const bounds = imageData.extentToBounds(imageData.getExtent());
  return [
    [bounds[0], bounds[2], bounds[4]],
    [bounds[0], bounds[2], bounds[5]],
    [bounds[0], bounds[3], bounds[4]],
    [bounds[0], bounds[3], bounds[5]],
    [bounds[1], bounds[2], bounds[4]],
    [bounds[1], bounds[2], bounds[5]],
    [bounds[1], bounds[3], bounds[4]],
    [bounds[1], bounds[3], bounds[5]]
  ];
}
function getRenderingEngine(id) {
  return renderingEngineCache$1.get(id);
}
function getRenderingEngines() {
  return renderingEngineCache$1.getAll();
}
function getViewportsWithVolumeId(volumeId, renderingEngineId) {
  let renderingEngines;
  if (renderingEngineId) {
    renderingEngines = [getRenderingEngine(renderingEngineId)];
  } else {
    renderingEngines = getRenderingEngines();
  }
  const targetViewports = [];
  renderingEngines.forEach((renderingEngine) => {
    const viewports = renderingEngine.getVolumeViewports();
    const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));
    targetViewports.push(...filteredViewports);
  });
  return targetViewports;
}
function transformWorldToIndex(imageData, worldPos) {
  const continuousIndex = imageData.worldToIndex(worldPos);
  const index2 = continuousIndex.map(Math.round);
  return index2;
}
class RequestPoolManager {
  constructor(id) {
    this.numRequests = {
      interaction: 0,
      thumbnail: 0,
      prefetch: 0
    };
    this.id = id ? id : uuidv4();
    this.requestPool = {
      interaction: { 0: [] },
      thumbnail: { 0: [] },
      prefetch: { 0: [] }
    };
    this.grabDelay = 5;
    this.awake = false;
    this.numRequests = {
      interaction: 0,
      thumbnail: 0,
      prefetch: 0
    };
    this.maxNumRequests = {
      interaction: 6,
      thumbnail: 6,
      prefetch: 5
    };
  }
  setMaxSimultaneousRequests(type, maxNumRequests) {
    this.maxNumRequests[type] = maxNumRequests;
  }
  getMaxSimultaneousRequests(type) {
    return this.maxNumRequests[type];
  }
  destroy() {
    if (this.timeoutHandle) {
      window.clearTimeout(this.timeoutHandle);
    }
  }
  addRequest(requestFn, type, additionalDetails, priority = 0) {
    const requestDetails = {
      requestFn,
      type,
      additionalDetails
    };
    if (this.requestPool[type][priority] === void 0) {
      this.requestPool[type][priority] = [];
    }
    this.requestPool[type][priority].push(requestDetails);
    if (!this.awake) {
      this.awake = true;
      this.startGrabbing();
    } else if (type === RequestType$1.Interaction) {
      this.startGrabbing();
    }
  }
  filterRequests(filterFunction) {
    Object.keys(this.requestPool).forEach((type) => {
      const requestType = this.requestPool[type];
      Object.keys(requestType).forEach((priority) => {
        requestType[priority] = requestType[priority].filter((requestDetails) => {
          return filterFunction(requestDetails);
        });
      });
    });
  }
  clearRequestStack(type) {
    if (!this.requestPool[type]) {
      throw new Error(`No category for the type ${type} found`);
    }
    this.requestPool[type] = { 0: [] };
  }
  sendRequests(type) {
    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];
    for (let i = 0; i < requestsToSend; i++) {
      const requestDetails = this.getNextRequest(type);
      if (requestDetails === null) {
        return false;
      } else if (requestDetails) {
        this.numRequests[type]++;
        this.awake = true;
        requestDetails.requestFn().finally(() => {
          this.numRequests[type]--;
          this.startAgain();
        });
      }
    }
    return true;
  }
  getNextRequest(type) {
    const interactionPriorities = this.getSortedPriorityGroups(type);
    for (const priority of interactionPriorities) {
      if (this.requestPool[type][priority].length) {
        return this.requestPool[type][priority].shift();
      }
    }
    return null;
  }
  startGrabbing() {
    const hasRemainingInteractionRequests = this.sendRequests(RequestType$1.Interaction);
    const hasRemainingThumbnailRequests = this.sendRequests(RequestType$1.Thumbnail);
    const hasRemainingPrefetchRequests = this.sendRequests(RequestType$1.Prefetch);
    if (!hasRemainingInteractionRequests && !hasRemainingThumbnailRequests && !hasRemainingPrefetchRequests) {
      this.awake = false;
    }
  }
  startAgain() {
    if (!this.awake) {
      return;
    }
    if (this.grabDelay !== void 0) {
      this.timeoutHandle = window.setTimeout(() => {
        this.startGrabbing();
      }, this.grabDelay);
    } else {
      this.startGrabbing();
    }
  }
  getSortedPriorityGroups(type) {
    const priorities = Object.keys(this.requestPool[type]).map(Number).filter((priority) => this.requestPool[type][priority].length).sort();
    return priorities;
  }
  getRequestPool() {
    return this.requestPool;
  }
}
new RequestPoolManager();
const imageLoadPoolManager = new RequestPoolManager("imageLoadPool");
imageLoadPoolManager.grabDelay = 0;
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType$1.Interaction, 1e3);
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType$1.Thumbnail, 1e3);
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType$1.Prefetch, 1e3);
const imageLoadPoolManager$1 = imageLoadPoolManager;
const imageLoaders = {};
function loadImageFromImageLoader(imageId, options) {
  const colonIndex = imageId.indexOf(":");
  const scheme = imageId.substring(0, colonIndex);
  const loader = imageLoaders[scheme];
  if (loader === void 0 || loader === null) {
    throw new Error("loadImageFromImageLoader: no image loader for imageId");
  }
  const imageLoadObject = loader(imageId, options);
  imageLoadObject.promise.then(function(image) {
    triggerEvent(eventTarget$1, Events$2.IMAGE_LOADED, { image });
  }, function(error) {
    const errorObject = {
      imageId,
      error
    };
    triggerEvent(eventTarget$1, Events$2.IMAGE_LOAD_FAILED, errorObject);
  });
  return imageLoadObject;
}
function loadImageFromCacheOrVolume(imageId, options) {
  let imageLoadObject = cache$1.getImageLoadObject(imageId);
  if (imageLoadObject !== void 0) {
    return imageLoadObject;
  }
  const cachedVolumeInfo = cache$1.getVolumeContainingImageId(imageId);
  if (cachedVolumeInfo && cachedVolumeInfo.volume.loadStatus.loaded) {
    const { volume, imageIdIndex } = cachedVolumeInfo;
    imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);
    return imageLoadObject;
  }
  const cachedImage = cache$1.getCachedImageBasedOnImageURI(imageId);
  if (cachedImage) {
    imageLoadObject = cachedImage.imageLoadObject;
    return imageLoadObject;
  }
  imageLoadObject = loadImageFromImageLoader(imageId, options);
  return imageLoadObject;
}
function loadAndCacheImage(imageId, options = { priority: 0, requestType: "prefetch" }) {
  if (imageId === void 0) {
    throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
  }
  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);
  if (!cache$1.getImageLoadObject(imageId)) {
    cache$1.putImageLoadObject(imageId, imageLoadObject).catch((err) => {
      console.warn(err);
    });
  }
  return imageLoadObject.promise;
}
const state$2 = {
  viewport: {}
};
function createDefaultDisplayedArea() {
  return {
    tlhc: {
      x: 1,
      y: 1
    },
    brhc: {
      x: 1,
      y: 1
    },
    rowPixelSpacing: 1,
    columnPixelSpacing: 1,
    presentationSizeMode: "NONE"
  };
}
function createViewport() {
  const displayedArea = createDefaultDisplayedArea();
  const initialDefaultViewport = {
    scale: 1,
    translation: {
      x: 0,
      y: 0
    },
    voi: {
      windowWidth: void 0,
      windowCenter: void 0
    },
    invert: false,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: void 0,
    voiLUT: void 0,
    colormap: void 0,
    labelmap: false,
    displayedArea
  };
  return Object.assign({}, initialDefaultViewport, state$2.viewport);
}
function validateParameterUndefinedOrNull(checkParam, errorMsg) {
  if (checkParam === void 0 || checkParam === null) {
    throw new Error(errorMsg);
  }
}
function isRotated(rotation) {
  return !(rotation === null || rotation === void 0 || rotation === 0 || rotation === 180);
}
function getImageSize(image, rotation = null) {
  validateParameterUndefinedOrNull(image, "getImageSize: parameter image must not be undefined");
  validateParameterUndefinedOrNull(image.width, "getImageSize: parameter image must have width");
  validateParameterUndefinedOrNull(image.height, "getImageSize: parameter image must have height");
  if (isRotated(rotation)) {
    return {
      height: image.width,
      width: image.height
    };
  }
  return {
    width: image.width,
    height: image.height
  };
}
function getImageFitScale(canvas, image, rotation = null) {
  validateParameterUndefinedOrNull(canvas, "getImageScale: parameter canvas must not be undefined");
  validateParameterUndefinedOrNull(image, "getImageScale: parameter image must not be undefined");
  const imageSize = getImageSize(image, rotation);
  const rowPixelSpacing = image.rowPixelSpacing || 1;
  const columnPixelSpacing = image.columnPixelSpacing || 1;
  let verticalRatio = 1;
  let horizontalRatio = 1;
  if (rowPixelSpacing < columnPixelSpacing) {
    horizontalRatio = columnPixelSpacing / rowPixelSpacing;
  } else {
    verticalRatio = rowPixelSpacing / columnPixelSpacing;
  }
  const verticalScale = canvas.height / imageSize.height / verticalRatio;
  const horizontalScale = canvas.width / imageSize.width / horizontalRatio;
  return {
    verticalScale,
    horizontalScale,
    scaleFactor: Math.min(horizontalScale, verticalScale)
  };
}
function getDefaultViewport(canvas, image, modality, colormap) {
  if (canvas === void 0) {
    throw new Error("getDefaultViewport: parameter canvas must not be undefined");
  }
  if (image === void 0) {
    return createViewport();
  }
  const scale2 = getImageFitScale(canvas, image, 0).scaleFactor;
  let voi;
  if (modality === "PT" && image.isPreScaled) {
    voi = {
      windowWidth: 5,
      windowCenter: 2.5
    };
  } else if (image.windowWidth !== void 0 && image.windowCenter !== void 0) {
    voi = {
      windowWidth: Array.isArray(image.windowWidth) ? image.windowWidth[0] : image.windowWidth,
      windowCenter: Array.isArray(image.windowCenter) ? image.windowCenter[0] : image.windowCenter
    };
  }
  return {
    scale: scale2,
    translation: {
      x: 0,
      y: 0
    },
    voi,
    invert: image.invert,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: image.modalityLUT,
    modality,
    voiLUT: image.voiLUT,
    colormap: colormap !== void 0 ? colormap : image.colormap,
    displayedArea: {
      tlhc: {
        x: 1,
        y: 1
      },
      brhc: {
        x: image.columns,
        y: image.rows
      },
      rowPixelSpacing: image.rowPixelSpacing === void 0 ? 1 : image.rowPixelSpacing,
      columnPixelSpacing: image.columnPixelSpacing === void 0 ? 1 : image.columnPixelSpacing,
      presentationSizeMode: "NONE"
    }
  };
}
let Transform$1 = class Transform {
  constructor() {
    this.reset();
  }
  getMatrix() {
    return this.m;
  }
  reset() {
    this.m = [1, 0, 0, 1, 0, 0];
  }
  clone() {
    const transform = new Transform$1();
    transform.m[0] = this.m[0];
    transform.m[1] = this.m[1];
    transform.m[2] = this.m[2];
    transform.m[3] = this.m[3];
    transform.m[4] = this.m[4];
    transform.m[5] = this.m[5];
    return transform;
  }
  multiply(matrix) {
    const m11 = this.m[0] * matrix[0] + this.m[2] * matrix[1];
    const m12 = this.m[1] * matrix[0] + this.m[3] * matrix[1];
    const m21 = this.m[0] * matrix[2] + this.m[2] * matrix[3];
    const m22 = this.m[1] * matrix[2] + this.m[3] * matrix[3];
    const dx = this.m[0] * matrix[4] + this.m[2] * matrix[5] + this.m[4];
    const dy = this.m[1] * matrix[4] + this.m[3] * matrix[5] + this.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
  }
  invert() {
    const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
    const m0 = this.m[3] * d;
    const m1 = -this.m[1] * d;
    const m2 = -this.m[2] * d;
    const m3 = this.m[0] * d;
    const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
    const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
  }
  rotate(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const m11 = this.m[0] * c + this.m[2] * s;
    const m12 = this.m[1] * c + this.m[3] * s;
    const m21 = this.m[0] * -s + this.m[2] * c;
    const m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
  }
  translate(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
  }
  scale(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
  }
  transformPoint(point) {
    const x = point[0];
    const y = point[1];
    return [
      x * this.m[0] + y * this.m[2] + this.m[4],
      x * this.m[1] + y * this.m[3] + this.m[5]
    ];
  }
};
function calculateTransform(enabledElement, scale2) {
  const transform = new Transform$1();
  if (!enabledElement.viewport.displayedArea) {
    return transform;
  }
  transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);
  const angle2 = enabledElement.viewport.rotation;
  if (angle2 !== 0) {
    transform.rotate(angle2 * Math.PI / 180);
  }
  let widthScale = enabledElement.viewport.scale;
  let heightScale = enabledElement.viewport.scale;
  const width = enabledElement.viewport.displayedArea.brhc.x - (enabledElement.viewport.displayedArea.tlhc.x - 1);
  const height = enabledElement.viewport.displayedArea.brhc.y - (enabledElement.viewport.displayedArea.tlhc.y - 1);
  if (enabledElement.viewport.displayedArea.presentationSizeMode === "NONE") {
    if (enabledElement.image.rowPixelSpacing < enabledElement.image.columnPixelSpacing) {
      widthScale *= enabledElement.image.columnPixelSpacing / enabledElement.image.rowPixelSpacing;
    } else if (enabledElement.image.columnPixelSpacing < enabledElement.image.rowPixelSpacing) {
      heightScale *= enabledElement.image.rowPixelSpacing / enabledElement.image.columnPixelSpacing;
    }
  } else {
    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;
    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;
    if (enabledElement.viewport.displayedArea.presentationSizeMode === "SCALE TO FIT") {
      const verticalScale = enabledElement.canvas.height / (height * heightScale);
      const horizontalScale = enabledElement.canvas.width / (width * widthScale);
      widthScale = heightScale = Math.min(horizontalScale, verticalScale);
      if (enabledElement.viewport.displayedArea.rowPixelSpacing < enabledElement.viewport.displayedArea.columnPixelSpacing) {
        widthScale *= enabledElement.viewport.displayedArea.columnPixelSpacing / enabledElement.viewport.displayedArea.rowPixelSpacing;
      } else if (enabledElement.viewport.displayedArea.columnPixelSpacing < enabledElement.viewport.displayedArea.rowPixelSpacing) {
        heightScale *= enabledElement.viewport.displayedArea.rowPixelSpacing / enabledElement.viewport.displayedArea.columnPixelSpacing;
      }
    }
  }
  transform.scale(widthScale, heightScale);
  if (angle2 !== 0) {
    transform.rotate(-angle2 * Math.PI / 180);
  }
  transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);
  if (angle2 !== 0) {
    transform.rotate(angle2 * Math.PI / 180);
  }
  if (scale2 !== void 0) {
    transform.scale(scale2, scale2);
  }
  if (enabledElement.viewport.hflip) {
    transform.scale(-1, 1);
  }
  if (enabledElement.viewport.vflip) {
    transform.scale(1, -1);
  }
  transform.translate(-width / 2, -height / 2);
  return transform;
}
function now() {
  if (window.performance) {
    return performance.now();
  }
  return Date.now();
}
function generateLinearVOILUT(windowWidth, windowCenter) {
  return function(modalityLutValue) {
    return ((modalityLutValue - windowCenter) / windowWidth + 0.5) * 255;
  };
}
function generateNonLinearVOILUT(voiLUT) {
  const bitsPerEntry = Math.max(...voiLUT.lut).toString(2).length;
  const shift = bitsPerEntry - 8;
  const minValue = voiLUT.lut[0] >> shift;
  const maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;
  const maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;
  return function(modalityLutValue) {
    if (modalityLutValue < voiLUT.firstValueMapped) {
      return minValue;
    } else if (modalityLutValue >= maxValueMapped) {
      return maxValue;
    }
    return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;
  };
}
function getVOILUT(windowWidth, windowCenter, voiLUT) {
  if (voiLUT) {
    return generateNonLinearVOILUT(voiLUT);
  }
  return generateLinearVOILUT(windowWidth, windowCenter);
}
function generateColorLUT(image, windowWidth, windowCenter, invert2, voiLUT) {
  const maxPixelValue = image.maxPixelValue;
  const minPixelValue = image.minPixelValue;
  const offset = Math.min(minPixelValue, 0);
  if (image.cachedLut === void 0) {
    const length2 = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length2);
  }
  const lut = image.cachedLut.lutArray;
  const vlutfn = getVOILUT(Array.isArray(windowWidth) ? windowWidth[0] : windowWidth, Array.isArray(windowCenter) ? windowCenter[0] : windowCenter, voiLUT);
  if (invert2 === true) {
    for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = 255 - vlutfn(storedValue);
    }
  } else {
    for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = vlutfn(storedValue);
    }
  }
  return lut;
}
function storedColorPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  const numPixels = pixelData.length;
  start = now();
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex] + -minPixelValue];
      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex]];
      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function storedRGBAPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  const numPixels = pixelData.length;
  start = now();
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function setToPixelCoordinateSystem(enabledElement, context, scale2) {
  if (enabledElement === void 0) {
    throw new Error("setToPixelCoordinateSystem: parameter enabledElement must not be undefined");
  }
  if (context === void 0) {
    throw new Error("setToPixelCoordinateSystem: parameter context must not be undefined");
  }
  const transform = calculateTransform(enabledElement, scale2);
  const m = transform.getMatrix();
  context.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
}
function doesImageNeedToBeRendered(enabledElement, image) {
  const lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;
  const lastRenderedViewport = enabledElement.renderingTools.lastRenderedViewport;
  return image.imageId !== lastRenderedImageId || !lastRenderedViewport || lastRenderedViewport.windowCenter !== enabledElement.viewport.voi.windowCenter || lastRenderedViewport.windowWidth !== enabledElement.viewport.voi.windowWidth || lastRenderedViewport.invert !== enabledElement.viewport.invert || lastRenderedViewport.rotation !== enabledElement.viewport.rotation || lastRenderedViewport.hflip !== enabledElement.viewport.hflip || lastRenderedViewport.vflip !== enabledElement.viewport.vflip || lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT || lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT || lastRenderedViewport.colormap !== enabledElement.viewport.colormap;
}
function initializeRenderCanvas(enabledElement, image) {
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  renderCanvas.width = image.width;
  renderCanvas.height = image.height;
  const canvasContext = renderCanvas.getContext("2d");
  canvasContext.fillStyle = "white";
  canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
  const renderCanvasData = canvasContext.getImageData(0, 0, image.width, image.height);
  enabledElement.renderingTools.renderCanvasContext = canvasContext;
  enabledElement.renderingTools.renderCanvasData = renderCanvasData;
}
function saveLastRendered(enabledElement) {
  const imageId = enabledElement.image.imageId;
  const viewport = enabledElement.viewport;
  const isColor = enabledElement.image.color;
  enabledElement.renderingTools.lastRenderedImageId = imageId;
  enabledElement.renderingTools.lastRenderedIsColor = isColor;
  enabledElement.renderingTools.lastRenderedViewport = {
    windowCenter: viewport.voi.windowCenter,
    windowWidth: viewport.voi.windowWidth,
    invert: viewport.invert,
    rotation: viewport.rotation,
    hflip: viewport.hflip,
    vflip: viewport.vflip,
    modalityLUT: viewport.modalityLUT,
    voiLUT: viewport.voiLUT,
    colormap: viewport.colormap
  };
  return enabledElement.renderingTools;
}
function getLut$1(image, viewport) {
  if (image.cachedLut !== void 0 && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && image.cachedLut.invert === viewport.invert) {
    return image.cachedLut.lutArray;
  }
  generateColorLUT(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  return image.cachedLut.lutArray;
}
function getRenderCanvas$2(enabledElement, image, invalidated) {
  const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor === true;
  if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  if (enabledElement.viewport.voi.windowWidth === 255 && enabledElement.viewport.voi.windowCenter === 128 && enabledElement.viewport.invert === false && image.getCanvas && image.getCanvas()) {
    return image.getCanvas();
  }
  if (doesImageNeedToBeRendered(enabledElement, image) === false && invalidated !== true) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas(enabledElement, image);
  }
  let start = now();
  const colorLUT = getLut$1(image, enabledElement.viewport);
  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = now() - start;
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  if (image.rgba) {
    storedRGBAPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
  } else {
    storedColorPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
  }
  start = now();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now() - start;
  return renderCanvas;
}
function renderColorImage(enabledElement, invalidated) {
  if (enabledElement === void 0) {
    throw new Error("renderColorImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === void 0) {
    throw new Error("renderColorImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem(enabledElement, context);
  const renderCanvas = getRenderCanvas$2(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered(enabledElement);
}
function storedPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 3;
  let storedPixelDataIndex = 0;
  start = now();
  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
        canvasImageDataIndex += 4;
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
        canvasImageDataIndex += 4;
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataIndex += 4;
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataIndex += 4;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataIndex += 4;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function storedPixelDataToCanvasImageDataPET(image, lutFunction, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const numPixels = pixelData.length;
  let canvasImageDataIndex = 3;
  let storedPixelDataIndex = 0;
  start = now();
  while (storedPixelDataIndex < numPixels) {
    canvasImageDataData[canvasImageDataIndex] = lutFunction(pixelData[storedPixelDataIndex++]);
    canvasImageDataIndex += 4;
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function storedPixelDataToCanvasImageDataRGBA(image, lut, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let pixelValue;
  start = now();
  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255;
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++]];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255;
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function computeAutoVoi(viewport, image) {
  if (hasVoi(viewport)) {
    return;
  }
  const maxVoi = image.maxPixelValue * image.slope + image.intercept;
  const minVoi = image.minPixelValue * image.slope + image.intercept;
  const ww = maxVoi - minVoi;
  const wc = (maxVoi + minVoi) / 2;
  if (viewport.voi === void 0) {
    viewport.voi = {
      windowWidth: ww,
      windowCenter: wc
    };
  } else {
    viewport.voi.windowWidth = ww;
    viewport.voi.windowCenter = wc;
  }
}
function hasVoi(viewport) {
  const hasLut = viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;
  return hasLut || viewport.voi.windowWidth !== void 0 && viewport.voi.windowCenter !== void 0;
}
function lutMatches(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.id === b.id;
}
function generateLinearModalityLUT(slope, intercept) {
  return (storedPixelValue) => storedPixelValue * slope + intercept;
}
function generateNonLinearModalityLUT(modalityLUT) {
  const minValue = modalityLUT.lut[0];
  const maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];
  const maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;
  return (storedPixelValue) => {
    if (storedPixelValue < modalityLUT.firstValueMapped) {
      return minValue;
    } else if (storedPixelValue >= maxValueMapped) {
      return maxValue;
    }
    return modalityLUT.lut[storedPixelValue];
  };
}
function getModalityLut(slope, intercept, modalityLUT) {
  if (modalityLUT) {
    return generateNonLinearModalityLUT(modalityLUT);
  }
  return generateLinearModalityLUT(slope, intercept);
}
function generateLut(image, windowWidth, windowCenter, invert2, modalityLUT, voiLUT) {
  const maxPixelValue = image.maxPixelValue;
  const minPixelValue = image.minPixelValue;
  const offset = Math.min(minPixelValue, 0);
  if (image.cachedLut === void 0) {
    const length2 = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length2);
  }
  const lut = image.cachedLut.lutArray;
  const mlutfn = getModalityLut(image.slope, image.intercept, modalityLUT);
  const vlutfn = getVOILUT(windowWidth, windowCenter, voiLUT);
  if (image.isPreScaled) {
    if (invert2 === true) {
      for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = 255 - vlutfn(storedValue);
      }
    } else {
      for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = vlutfn(storedValue);
      }
    }
  } else {
    if (invert2 === true) {
      for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));
      }
    } else {
      for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = vlutfn(mlutfn(storedValue));
      }
    }
  }
  return lut;
}
function getLut(image, viewport, invalidated) {
  if (image.cachedLut !== void 0 && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && lutMatches(image.cachedLut.modalityLUT, viewport.modalityLUT) && lutMatches(image.cachedLut.voiLUT, viewport.voiLUT) && image.cachedLut.invert === viewport.invert && invalidated !== true) {
    return image.cachedLut.lutArray;
  }
  computeAutoVoi(viewport, image);
  generateLut(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  image.cachedLut.voiLUT = viewport.voiLUT;
  image.cachedLut.modalityLUT = viewport.modalityLUT;
  return image.cachedLut.lutArray;
}
function getRenderCanvas$1(enabledElement, image, invalidated, useAlphaChannel = true) {
  const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor === true;
  if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
    initializeRenderCanvas(enabledElement, image);
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  if (doesImageNeedToBeRendered(enabledElement, image) === false && invalidated !== true) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas(enabledElement, image);
  }
  image.stats = image.stats || {};
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  let start = now();
  image.stats.lastLutGenerateTime = now() - start;
  const { viewport } = enabledElement;
  if (viewport.modality === "PT" && image.isPreScaled) {
    const { windowWidth, windowCenter } = viewport.voi;
    const minimum = windowCenter - windowWidth / 2;
    const maximum = windowCenter + windowWidth / 2;
    const range = maximum - minimum;
    const collectedMultiplierTerms = 255 / range;
    let petVOILutFunction;
    if (viewport.invert) {
      petVOILutFunction = (value) => 255 - (value - minimum) * collectedMultiplierTerms;
    } else {
      petVOILutFunction = (value) => (value - minimum) * collectedMultiplierTerms;
    }
    storedPixelDataToCanvasImageDataPET(image, petVOILutFunction, renderCanvasData.data);
  } else {
    const lut = getLut(image, viewport, invalidated);
    if (useAlphaChannel) {
      storedPixelDataToCanvasImageData(image, lut, renderCanvasData.data);
    } else {
      storedPixelDataToCanvasImageDataRGBA(image, lut, renderCanvasData.data);
    }
  }
  start = now();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now() - start;
  return renderCanvas;
}
function renderGrayscaleImage(enabledElement, invalidated) {
  if (enabledElement === void 0) {
    throw new Error("drawImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === void 0) {
    throw new Error("drawImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem(enabledElement, context);
  const renderCanvas = getRenderCanvas$1(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered(enabledElement);
}
const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;
function HSVToRGB(hue, sat, val) {
  if (hue > 1) {
    throw new Error("HSVToRGB expects hue < 1");
  }
  const rgb = [];
  if (sat === 0) {
    rgb[0] = val;
    rgb[1] = val;
    rgb[2] = val;
    return rgb;
  }
  const hueCase = Math.floor(hue * 6);
  const frac = 6 * hue - hueCase;
  const lx = val * (1 - sat);
  const ly = val * (1 - sat * frac);
  const lz = val * (1 - sat * (1 - frac));
  switch (hueCase) {
    case 0:
    case 6:
      rgb[0] = val;
      rgb[1] = lz;
      rgb[2] = lx;
      break;
    case 1:
      rgb[0] = ly;
      rgb[1] = val;
      rgb[2] = lx;
      break;
    case 2:
      rgb[0] = lx;
      rgb[1] = val;
      rgb[2] = lz;
      break;
    case 3:
      rgb[0] = lx;
      rgb[1] = ly;
      rgb[2] = val;
      break;
    case 4:
      rgb[0] = lz;
      rgb[1] = lx;
      rgb[2] = val;
      break;
    case 5:
      rgb[0] = val;
      rgb[1] = lx;
      rgb[2] = ly;
      break;
  }
  return rgb;
}
function linearIndexLookupMain(v, p2) {
  let dIndex;
  if (v < p2.Range[0]) {
    dIndex = p2.MaxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
  } else if (v > p2.Range[1]) {
    dIndex = p2.MaxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
  } else {
    dIndex = (v + p2.Shift) * p2.Scale;
  }
  return Math.floor(dIndex);
}
class LookupTable {
  constructor() {
    this.NumberOfColors = 256;
    this.Ramp = "linear";
    this.TableRange = [0, 255];
    this.HueRange = [0, 0.66667];
    this.SaturationRange = [1, 1];
    this.ValueRange = [1, 1];
    this.AlphaRange = [1, 1];
    this.NaNColor = [128, 0, 0, 255];
    this.BelowRangeColor = [0, 0, 0, 255];
    this.UseBelowRangeColor = true;
    this.AboveRangeColor = [255, 255, 255, 255];
    this.UseAboveRangeColor = true;
    this.InputRange = [0, 255];
    this.Table = [];
  }
  setNumberOfTableValues(number) {
    this.NumberOfColors = number;
  }
  setRamp(ramp) {
    this.Ramp = ramp;
  }
  setTableRange(start, end) {
    this.TableRange[0] = start;
    this.TableRange[1] = end;
  }
  setHueRange(start, end) {
    this.HueRange[0] = start;
    this.HueRange[1] = end;
  }
  setSaturationRange(start, end) {
    this.SaturationRange[0] = start;
    this.SaturationRange[1] = end;
  }
  setValueRange(start, end) {
    this.ValueRange[0] = start;
    this.ValueRange[1] = end;
  }
  setRange(start, end) {
    this.InputRange[0] = start;
    this.InputRange[1] = end;
  }
  setAlphaRange(start, end) {
    this.AlphaRange[0] = start;
    this.AlphaRange[1] = end;
  }
  getColor(scalar) {
    return this.mapValue(scalar);
  }
  build(force) {
    if (this.Table.length > 1 && !force) {
      return;
    }
    this.Table = [];
    const maxIndex = this.NumberOfColors - 1;
    let hinc, sinc, vinc, ainc;
    if (maxIndex) {
      hinc = (this.HueRange[1] - this.HueRange[0]) / maxIndex;
      sinc = (this.SaturationRange[1] - this.SaturationRange[0]) / maxIndex;
      vinc = (this.ValueRange[1] - this.ValueRange[0]) / maxIndex;
      ainc = (this.AlphaRange[1] - this.AlphaRange[0]) / maxIndex;
    } else {
      hinc = sinc = vinc = ainc = 0;
    }
    for (let i = 0; i <= maxIndex; i++) {
      const hue = this.HueRange[0] + i * hinc;
      const sat = this.SaturationRange[0] + i * sinc;
      const val = this.ValueRange[0] + i * vinc;
      const alpha = this.AlphaRange[0] + i * ainc;
      const rgb = HSVToRGB(hue, sat, val);
      const c_rgba = [0, 0, 0, 0];
      switch (this.Ramp) {
        case "scurve":
          c_rgba[0] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[0]) * Math.PI)));
          c_rgba[1] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[1]) * Math.PI)));
          c_rgba[2] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[2]) * Math.PI)));
          c_rgba[3] = Math.floor(alpha * 255);
          break;
        case "linear":
          c_rgba[0] = Math.floor(rgb[0] * 255 + 0.5);
          c_rgba[1] = Math.floor(rgb[1] * 255 + 0.5);
          c_rgba[2] = Math.floor(rgb[2] * 255 + 0.5);
          c_rgba[3] = Math.floor(alpha * 255 + 0.5);
          break;
        case "sqrt":
          c_rgba[0] = Math.floor(Math.sqrt(rgb[0]) * 255 + 0.5);
          c_rgba[1] = Math.floor(Math.sqrt(rgb[1]) * 255 + 0.5);
          c_rgba[2] = Math.floor(Math.sqrt(rgb[2]) * 255 + 0.5);
          c_rgba[3] = Math.floor(Math.sqrt(alpha) * 255 + 0.5);
          break;
        default:
          throw new Error(`Invalid Ramp value (${this.Ramp})`);
      }
      this.Table.push(c_rgba);
    }
    this.buildSpecialColors();
  }
  buildSpecialColors() {
    const numberOfColors = this.NumberOfColors;
    const belowRangeColorIndex = numberOfColors + BELOW_RANGE_COLOR_INDEX;
    const aboveRangeColorIndex = numberOfColors + ABOVE_RANGE_COLOR_INDEX;
    const nanColorIndex = numberOfColors + NAN_COLOR_INDEX;
    if (this.UseBelowRangeColor || numberOfColors === 0) {
      this.Table[belowRangeColorIndex] = this.BelowRangeColor;
    } else {
      this.Table[belowRangeColorIndex] = this.Table[0];
    }
    if (this.UseAboveRangeColor || numberOfColors === 0) {
      this.Table[aboveRangeColorIndex] = this.AboveRangeColor;
    } else {
      this.Table[aboveRangeColorIndex] = this.Table[numberOfColors - 1];
    }
    this.Table[nanColorIndex] = this.NaNColor;
  }
  mapValue(v) {
    const index2 = this.getIndex(v);
    if (index2 < 0) {
      return this.NaNColor;
    } else if (index2 === 0) {
      if (this.UseBelowRangeColor && v < this.TableRange[0]) {
        return this.BelowRangeColor;
      }
    } else if (index2 === this.NumberOfColors - 1) {
      if (this.UseAboveRangeColor && v > this.TableRange[1]) {
        return this.AboveRangeColor;
      }
    }
    return this.Table[index2];
  }
  getIndex(v) {
    const p2 = {
      Range: [],
      MaxIndex: this.NumberOfColors - 1,
      Shift: -this.TableRange[0],
      Scale: 1
    };
    if (this.TableRange[1] <= this.TableRange[0]) {
      p2.Scale = Number.MAX_VALUE;
    } else {
      p2.Scale = p2.MaxIndex / (this.TableRange[1] - this.TableRange[0]);
    }
    p2.Range[0] = this.TableRange[0];
    p2.Range[1] = this.TableRange[1];
    if (isNaN(v)) {
      return -1;
    }
    let index2 = linearIndexLookupMain(v, p2);
    if (index2 === this.NumberOfColors + BELOW_RANGE_COLOR_INDEX) {
      index2 = 0;
    } else if (index2 === this.NumberOfColors + ABOVE_RANGE_COLOR_INDEX) {
      index2 = this.NumberOfColors - 1;
    }
    return index2;
  }
  setTableValue(index2, rgba) {
    if (arguments.length === 5) {
      rgba = Array.prototype.slice.call(arguments, 1);
    }
    if (index2 < 0) {
      throw new Error(`Can't set the table value for negative index (${index2})`);
    }
    if (index2 >= this.NumberOfColors) {
      new Error(`Index ${index2} is greater than the number of colors ${this.NumberOfColors}`);
    }
    this.Table[index2] = rgba;
    if (index2 === 0 || index2 === this.NumberOfColors - 1) {
      this.buildSpecialColors();
    }
  }
}
const LookupTable$1 = LookupTable;
const COLOR_TRANSPARENT = [0, 0, 0, 0];
function linspace(a, b, n) {
  n = n === null ? 100 : n;
  const increment = (b - a) / (n - 1);
  const vector = [];
  while (n-- > 0) {
    vector.push(a);
    a += increment;
  }
  vector[vector.length - 1] = b;
  return vector;
}
function getRank(array, elem) {
  let left = 0;
  let right = array.length - 1;
  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    const midElem = array[mid];
    if (midElem === elem) {
      return mid;
    } else if (elem < midElem) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return left;
}
function searchSorted(inputArray, values) {
  let i;
  const indexes = [];
  const len2 = values.length;
  inputArray.sort(function(a, b) {
    return a - b;
  });
  for (i = 0; i < len2; i++) {
    indexes[i] = getRank(inputArray, values[i]);
  }
  return indexes;
}
function makeMappingArray(N, data, gamma) {
  let i;
  const x = [];
  const y0 = [];
  const y1 = [];
  const lut = [];
  gamma = gamma === null ? 1 : gamma;
  for (i = 0; i < data.length; i++) {
    const element = data[i];
    x.push((N - 1) * element[0]);
    y0.push(element[1]);
    y1.push(element[1]);
  }
  const xLinSpace = linspace(0, 1, N);
  for (i = 0; i < N; i++) {
    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);
  }
  const xLinSpaceIndexes = searchSorted(x, xLinSpace);
  for (i = 1; i < N - 1; i++) {
    const index2 = xLinSpaceIndexes[i];
    const colorPercent = (xLinSpace[i] - x[index2 - 1]) / (x[index2] - x[index2 - 1]);
    const colorDelta = y0[index2] - y1[index2 - 1];
    lut[i] = colorPercent * colorDelta + y1[index2 - 1];
  }
  lut[0] = y1[0];
  lut[N - 1] = y0[data.length - 1];
  return lut;
}
function createLinearSegmentedColormap(segmentedData, N, gamma) {
  let i;
  const lut = [];
  N = N === null ? 256 : N;
  gamma = gamma === null ? 1 : gamma;
  const redLut = makeMappingArray(N, segmentedData.red, gamma);
  const greenLut = makeMappingArray(N, segmentedData.green, gamma);
  const blueLut = makeMappingArray(N, segmentedData.blue, gamma);
  for (i = 0; i < N; i++) {
    const red = Math.round(redLut[i] * 255);
    const green = Math.round(greenLut[i] * 255);
    const blue = Math.round(blueLut[i] * 255);
    const rgba = [red, green, blue, 255];
    lut.push(rgba);
  }
  return lut;
}
function getColormap(id, colormapData) {
  let colormap = CPU_COLORMAPS[id];
  if (!colormap) {
    colormap = CPU_COLORMAPS[id] = colormapData || {
      name: "",
      colors: []
    };
  }
  if (!colormap.colors && colormap.segmentedData) {
    colormap.colors = createLinearSegmentedColormap(colormap.segmentedData, colormap.numColors, colormap.gamma);
  }
  const cpuFallbackColormap = {
    getId() {
      return id;
    },
    getColorSchemeName() {
      return colormap.name;
    },
    setColorSchemeName(name) {
      colormap.name = name;
    },
    getNumberOfColors() {
      return colormap.colors.length;
    },
    setNumberOfColors(numColors) {
      while (colormap.colors.length < numColors) {
        colormap.colors.push(COLOR_TRANSPARENT);
      }
      colormap.colors.length = numColors;
    },
    getColor(index2) {
      if (this.isValidIndex(index2)) {
        return colormap.colors[index2];
      }
      return COLOR_TRANSPARENT;
    },
    getColorRepeating(index2) {
      const numColors = colormap.colors.length;
      index2 = numColors ? index2 % numColors : 0;
      return this.getColor(index2);
    },
    setColor(index2, rgba) {
      if (this.isValidIndex(index2)) {
        colormap.colors[index2] = rgba;
      }
    },
    addColor(rgba) {
      colormap.colors.push(rgba);
    },
    insertColor(index2, rgba) {
      if (this.isValidIndex(index2)) {
        colormap.colors.splice(index2, 1, rgba);
      }
    },
    removeColor(index2) {
      if (this.isValidIndex(index2)) {
        colormap.colors.splice(index2, 1);
      }
    },
    clearColors() {
      colormap.colors = [];
    },
    buildLookupTable(lut) {
      if (!lut) {
        return;
      }
      const numColors = colormap.colors.length;
      lut.setNumberOfTableValues(numColors);
      for (let i = 0; i < numColors; i++) {
        lut.setTableValue(i, colormap.colors[i]);
      }
    },
    createLookupTable() {
      const lut = new LookupTable$1();
      this.buildLookupTable(lut);
      return lut;
    },
    isValidIndex(index2) {
      return index2 >= 0 && index2 < colormap.colors.length;
    }
  };
  return cpuFallbackColormap;
}
function storedPixelDataToCanvasImageDataPseudocolorLUT(image, grayscaleLut, colorLUT, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let grayscale;
  let rgba;
  let clut;
  start = now();
  if (colorLUT instanceof LookupTable$1) {
    clut = colorLUT.Table;
  } else {
    clut = colorLUT;
  }
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, lutFunction, colorLUT, canvasImageDataData) {
  let start = now();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let grayscale;
  let rgba;
  let clut;
  start = now();
  if (colorLUT instanceof LookupTable$1) {
    clut = colorLUT.Table;
  } else {
    clut = colorLUT;
  }
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      grayscale = lutFunction(pixelData[storedPixelDataIndex++] + -minPixelValue);
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      grayscale = lutFunction(pixelData[storedPixelDataIndex++]);
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;
}
function clamp(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function getRenderCanvas(enabledElement, image, invalidated) {
  if (!enabledElement.renderingTools.renderCanvas) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  let colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;
  if (enabledElement.options && enabledElement.options.colormap) {
    console.warn("enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead");
  }
  if (colormap && typeof colormap === "string") {
    colormap = getColormap(colormap);
  }
  if (!colormap) {
    throw new Error("renderPseudoColorImage: colormap not found.");
  }
  const colormapId = colormap.getId();
  if (doesImageNeedToBeRendered(enabledElement, image) === false && invalidated !== true && enabledElement.renderingTools.colormapId === colormapId) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas(enabledElement, image);
  }
  let start = now();
  if (!enabledElement.renderingTools.colorLUT || invalidated || enabledElement.renderingTools.colormapId !== colormapId) {
    colormap.setNumberOfColors(256);
    enabledElement.renderingTools.colorLUT = colormap.createLookupTable();
    enabledElement.renderingTools.colormapId = colormapId;
  }
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  const { viewport } = enabledElement;
  const colorLUT = enabledElement.renderingTools.colorLUT;
  if (viewport.modality === "PT") {
    const { windowWidth, windowCenter } = viewport.voi;
    const minimum = windowCenter - windowWidth / 2;
    const maximum = windowCenter + windowWidth / 2;
    const range = maximum - minimum;
    const collectedMultiplierTerms = 255 / range;
    let petVOILutFunction;
    if (viewport.invert) {
      petVOILutFunction = (value) => {
        return clamp(Math.floor(255 - (value - minimum) * collectedMultiplierTerms), 0, 255);
      };
    } else {
      petVOILutFunction = (value) => {
        return clamp(Math.floor((value - minimum) * collectedMultiplierTerms), 0, 255);
      };
    }
    storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, petVOILutFunction, colorLUT, renderCanvasData.data);
  } else {
    const lut = getLut(image, enabledElement.viewport, invalidated);
    image.stats = image.stats || {};
    image.stats.lastLutGenerateTime = now() - start;
    storedPixelDataToCanvasImageDataPseudocolorLUT(image, lut, colorLUT, renderCanvasData.data);
  }
  start = now();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now() - start;
  return renderCanvas;
}
function renderPseudoColorImage(enabledElement, invalidated) {
  if (enabledElement === void 0) {
    throw new Error("drawImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === void 0) {
    throw new Error("drawImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem(enabledElement, context);
  const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered(enabledElement);
}
function drawImageSync(enabledElement, invalidated) {
  const image = enabledElement.image;
  if (!enabledElement.canvas || !enabledElement.image) {
    return;
  }
  const start = now();
  image.stats = {
    lastGetPixelDataTime: -1,
    lastStoredPixelDataToCanvasImageDataTime: -1,
    lastPutImageDataTime: -1,
    lastRenderTime: -1,
    lastLutGenerateTime: -1
  };
  if (image) {
    let render = image.render;
    if (!render) {
      if (enabledElement.viewport.colormap) {
        render = renderPseudoColorImage;
      } else if (image.color) {
        render = renderColorImage;
      } else {
        render = renderGrayscaleImage;
      }
    }
    render(enabledElement, invalidated);
  }
  const renderTimeInMs = now() - start;
  image.stats.lastRenderTime = renderTimeInMs;
  enabledElement.invalid = false;
  enabledElement.needsRedraw = false;
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace$1(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var alea$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy2(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state2 = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
      };
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 4294967296;
        }
        return (n >>> 0) * 23283064365386963e-26;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(alea$1);
var xor128$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy2(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(xor128$1);
var xorwow$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy2(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(xorwow$1);
var xorshift7$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var X = me.x, i = me.i, t, v;
        t = X[i];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i] = v;
        me.i = i + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, X = [];
        if (seed2 === (seed2 | 0)) {
          X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0; j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          X[7] = -1;
        else
          X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256; j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy2(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date();
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (state2.x)
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(xorshift7$1);
var xor4096$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var w = me.w, X = me.X, i = me.i, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i + 34 & 127];
        t = X[i = i + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i] = v ^ t;
        me.i = i;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\0";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i = 0, j = -32; j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i = 0 == t ? i + 1 : 0;
          }
        }
        if (i >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i;
      }
      init(me, seed);
    }
    function copy2(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date();
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (state2.X)
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(xor4096$1);
var tychei$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy2(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(
    commonjsGlobal$1,
    module,
    false
  );
})(tychei$1);
var seedrandom$1 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1);
(function(module) {
  (function(global2, pool, math) {
    var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom2(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
        3
      ), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state2) {
        if (state2) {
          if (state2.S) {
            copy2(state2, arc4);
          }
          prng2.state = function() {
            return copy2(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(
        prng,
        shortseed,
        "global" in options ? options.global : this == math,
        options.state
      );
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
        while (count--) {
          t2 = s2[i2 = mask & i2 + 1];
          r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i2;
        me.j = j2;
        return r;
      })(width);
    }
    function copy2(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten(obj2, depth) {
      var result = [], typ = typeof obj2, prop;
      if (depth && typ == "object") {
        for (prop in obj2) {
          try {
            result.push(flatten(obj2[prop], depth - 1));
          } catch (e) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj2 : obj2 + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
        return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math.random(), pool);
    if (module.exports) {
      module.exports = seedrandom2;
      try {
        nodecrypto = require$$0$1;
      } catch (ex) {
      }
    } else {
      math["seed" + rngname] = seedrandom2;
    }
  })(
    typeof self !== "undefined" ? self : commonjsGlobal$1,
    [],
    Math
  );
})(seedrandom$1);
var alea = alea$1.exports;
var xor128 = xor128$1.exports;
var xorwow = xorwow$1.exports;
var xorshift7 = xorshift7$1.exports;
var xor4096 = xor4096$1.exports;
var tychei = tychei$1.exports;
var sr = seedrandom$1.exports;
sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;
var seedrandom = sr;
function _typeof(obj2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj3) {
    return typeof obj3;
  } : function(obj3) {
    return obj3 && "function" == typeof Symbol && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
  }, _typeof(obj2);
}
function _defineProperty(obj2, key, value) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj2[key] = value;
  }
  return obj2;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
var toStr$b = Object.prototype.toString;
var isArguments$4 = function isArguments(value) {
  var str2 = toStr$b.call(value);
  var isArgs2 = str2 === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$b.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var keysShim$2;
if (!Object.keys) {
  var has$2 = Object.prototype.hasOwnProperty;
  var toStr$a = Object.prototype.toString;
  var isArgs$2 = isArguments$4;
  var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable$1.call({ toString: null }, "toString");
  var hasProtoEnumBug = isEnumerable$1.call(function() {
  }, "prototype");
  var dontEnums = [
    "toString",
    "toLocaleString",
    "valueOf",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "constructor"
  ];
  var equalsConstructorPrototype = function(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys["$" + k] && has$2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim$2 = function keys4(object3) {
    var isObject2 = object3 !== null && typeof object3 === "object";
    var isFunction2 = toStr$a.call(object3) === "[object Function]";
    var isArguments6 = isArgs$2(object3);
    var isString3 = isObject2 && toStr$a.call(object3) === "[object String]";
    var theKeys = [];
    if (!isObject2 && !isFunction2 && !isArguments6) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction2;
    if (isString3 && object3.length > 0 && !has$2.call(object3, 0)) {
      for (var i = 0; i < object3.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments6 && object3.length > 0) {
      for (var j = 0; j < object3.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object3) {
        if (!(skipProto && name === "prototype") && has$2.call(object3, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object3);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === "constructor") && has$2.call(object3, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
var implementation$g = keysShim$2;
var slice$3 = Array.prototype.slice;
var isArgs$1 = isArguments$4;
var origKeys$1 = Object.keys;
var keysShim$1 = origKeys$1 ? function keys(o) {
  return origKeys$1(o);
} : implementation$g;
var originalKeys$1 = Object.keys;
keysShim$1.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys4(object3) {
        if (isArgs$1(object3)) {
          return originalKeys$1(slice$3.call(object3));
        }
        return originalKeys$1(object3);
      };
    }
  } else {
    Object.keys = keysShim$1;
  }
  return Object.keys || keysShim$1;
};
var objectKeys$2 = keysShim$1;
var shams$2 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj2 = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj2[sym] = symVal;
  for (sym in obj2) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj2);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj2, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$8 = shams$2;
var shams$1 = function hasToStringTagShams() {
  return hasSymbols$8() && !!Symbol.toStringTag;
};
var origSymbol$1 = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham$1 = shams$2;
var hasSymbols$7 = function hasNativeSymbols() {
  if (typeof origSymbol$1 !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol$1("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham$1();
};
var ERROR_MESSAGE$1 = "Function.prototype.bind called on incompatible ";
var slice$2 = Array.prototype.slice;
var toStr$9 = Object.prototype.toString;
var funcType$1 = "[object Function]";
var implementation$f = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$9.call(target) !== funcType$1) {
    throw new TypeError(ERROR_MESSAGE$1 + target);
  }
  var args = slice$2.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target.apply(
        this,
        args.concat(slice$2.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$2.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$e = implementation$f;
var functionBind$1 = Function.prototype.bind || implementation$e;
var bind$3 = functionBind$1;
var src$1 = bind$3.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1$1;
var $SyntaxError$1 = SyntaxError;
var $Function$1 = Function;
var $TypeError$4 = TypeError;
var getEvalledConstructor$1 = function(expressionSyntax) {
  try {
    return $Function$1('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$3 = Object.getOwnPropertyDescriptor;
if ($gOPD$3) {
  try {
    $gOPD$3({}, "");
  } catch (e) {
    $gOPD$3 = null;
  }
}
var throwTypeError$1 = function() {
  throw new $TypeError$4();
};
var ThrowTypeError$1 = $gOPD$3 ? function() {
  try {
    arguments.callee;
    return throwTypeError$1;
  } catch (calleeThrows) {
    try {
      return $gOPD$3(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError$1;
    }
  }
}() : throwTypeError$1;
var hasSymbols$6 = hasSymbols$7();
var getProto$2 = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval$1 = {};
var TypedArray$1 = typeof Uint8Array === "undefined" ? undefined$1$1 : getProto$2(Uint8Array);
var INTRINSICS$1 = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$6 ? getProto$2([][Symbol.iterator]()) : undefined$1$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1$1,
  "%AsyncFunction%": needsEval$1,
  "%AsyncGenerator%": needsEval$1,
  "%AsyncGeneratorFunction%": needsEval$1,
  "%AsyncIteratorPrototype%": needsEval$1,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1$1 : FinalizationRegistry,
  "%Function%": $Function$1,
  "%GeneratorFunction%": needsEval$1,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$6 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$1$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1$1,
  "%Map%": typeof Map === "undefined" ? undefined$1$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$6 ? undefined$1$1 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$6 ? undefined$1$1 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$6 ? getProto$2(""[Symbol.iterator]()) : undefined$1$1,
  "%Symbol%": hasSymbols$6 ? Symbol : undefined$1$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError$1,
  "%TypedArray%": TypedArray$1,
  "%TypeError%": $TypeError$4,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1$1 : WeakSet
};
var doEval$1 = function doEval(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor$1("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor$1("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor$1("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval("%AsyncGenerator%");
    if (gen) {
      value = getProto$2(gen.prototype);
    }
  }
  INTRINSICS$1[name] = value;
  return value;
};
var LEGACY_ALIASES$1 = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$2 = functionBind$1;
var hasOwn$3 = src$1;
var $concat$2 = bind$2.call(Function.call, Array.prototype.concat);
var $spliceApply$1 = bind$2.call(Function.apply, Array.prototype.splice);
var $replace$2 = bind$2.call(Function.call, String.prototype.replace);
var $strSlice$1 = bind$2.call(Function.call, String.prototype.slice);
var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$1 = function stringToPath(string) {
  var first = $strSlice$1(string, 0, 1);
  var last = $strSlice$1(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$2(string, rePropName$1, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$2(subString, reEscapeChar$1, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic$1 = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$3(LEGACY_ALIASES$1, intrinsicName)) {
    alias = LEGACY_ALIASES$1[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$3(INTRINSICS$1, intrinsicName)) {
    var value = INTRINSICS$1[intrinsicName];
    if (value === needsEval$1) {
      value = doEval$1(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$4("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
};
var getIntrinsic$1 = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$4("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$4('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath$1(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic$1("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply$1(parts, $concat$2([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice$1(part, 0, 1);
    var last = $strSlice$1(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$3(INTRINSICS$1, intrinsicRealName)) {
      value = INTRINSICS$1[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$4("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$3 && i + 1 >= parts.length) {
        var desc = $gOPD$3(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$3(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS$1[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$4 = { exports: {} };
(function(module) {
  var bind4 = functionBind$1;
  var GetIntrinsic4 = getIntrinsic$1;
  var $apply = GetIntrinsic4("%Function.prototype.apply%");
  var $call = GetIntrinsic4("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic4("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $gOPD2 = GetIntrinsic4("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = GetIntrinsic4("%Object.defineProperty%", true);
  var $max = GetIntrinsic4("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind4, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$4);
var GetIntrinsic$5 = getIntrinsic$1;
var callBind$3 = callBind$4.exports;
var $indexOf$1 = callBind$3(GetIntrinsic$5("String.prototype.indexOf"));
var callBound$9 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$5(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.") > -1) {
    return callBind$3(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$7 = shams$1();
var callBound$8 = callBound$9;
var $toString$4 = callBound$8("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$7 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$4(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$4(value) !== "[object Array]" && $toString$4(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$3 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var keys$2 = objectKeys$2;
var hasSymbols$5 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$8 = Object.prototype.toString;
var concat$1 = Array.prototype.concat;
var origDefineProperty$1 = Object.defineProperty;
var isFunction$1 = function(fn) {
  return typeof fn === "function" && toStr$8.call(fn) === "[object Function]";
};
var arePropertyDescriptorsSupported = function() {
  var obj2 = {};
  try {
    origDefineProperty$1(obj2, "x", { enumerable: false, value: obj2 });
    for (var _ in obj2) {
      return false;
    }
    return obj2.x === obj2;
  } catch (e) {
    return false;
  }
};
var supportsDescriptors$3 = origDefineProperty$1 && arePropertyDescriptorsSupported();
var defineProperty$2 = function(object3, name, value, predicate) {
  if (name in object3 && (!isFunction$1(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors$3) {
    origDefineProperty$1(object3, name, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object3[name] = value;
  }
};
var defineProperties$3 = function(object3, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$2(map);
  if (hasSymbols$5) {
    props = concat$1.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty$2(object3, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties$3.supportsDescriptors = !!supportsDescriptors$3;
var defineProperties_1$1 = defineProperties$3;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$d = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var implementation$c = implementation$d;
var polyfill$6 = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$c;
};
var getPolyfill$7 = polyfill$6;
var define$4 = defineProperties_1$1;
var shim$7 = function shimObjectIs() {
  var polyfill3 = getPolyfill$7();
  define$4(Object, { is: polyfill3 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill3;
    }
  });
  return polyfill3;
};
var define$3 = defineProperties_1$1;
var callBind$2 = callBind$4.exports;
var implementation$b = implementation$d;
var getPolyfill$6 = polyfill$6;
var shim$6 = shim$7;
var polyfill$5 = callBind$2(getPolyfill$6(), Object);
define$3(polyfill$5, {
  getPolyfill: getPolyfill$6,
  implementation: implementation$b,
  shim: shim$6
});
var objectIs = polyfill$5;
var callBound$7 = callBound$9;
var hasToStringTag$6 = shams$1();
var has$1;
var $exec$1;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$6) {
  has$1 = callBound$7("Object.prototype.hasOwnProperty");
  $exec$1 = callBound$7("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString$3 = callBound$7("Object.prototype.toString");
var gOPD$3 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$6 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$3(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec$1(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString$3(value) === regexClass;
};
var $Object = Object;
var $TypeError$3 = TypeError;
var implementation$a = function flags() {
  if (this != null && this !== $Object(this)) {
    throw new $TypeError$3("RegExp.prototype.flags getter called on non-object");
  }
  var result = "";
  if (this.global) {
    result += "g";
  }
  if (this.ignoreCase) {
    result += "i";
  }
  if (this.multiline) {
    result += "m";
  }
  if (this.dotAll) {
    result += "s";
  }
  if (this.unicode) {
    result += "u";
  }
  if (this.sticky) {
    result += "y";
  }
  return result;
};
var implementation$9 = implementation$a;
var supportsDescriptors$2 = defineProperties_1$1.supportsDescriptors;
var $gOPD$2 = Object.getOwnPropertyDescriptor;
var $TypeError$2 = TypeError;
var polyfill$4 = function getPolyfill2() {
  if (!supportsDescriptors$2) {
    throw new $TypeError$2("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  if (/a/mig.flags === "gim") {
    var descriptor = $gOPD$2(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
      return descriptor.get;
    }
  }
  return implementation$9;
};
var supportsDescriptors$1 = defineProperties_1$1.supportsDescriptors;
var getPolyfill$5 = polyfill$4;
var gOPD$2 = Object.getOwnPropertyDescriptor;
var defineProperty$1 = Object.defineProperty;
var TypeErr = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex = /a/;
var shim$5 = function shimFlags() {
  if (!supportsDescriptors$1 || !getProto$1) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill3 = getPolyfill$5();
  var proto = getProto$1(regex);
  var descriptor = gOPD$2(proto, "flags");
  if (!descriptor || descriptor.get !== polyfill3) {
    defineProperty$1(proto, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill3
    });
  }
  return polyfill3;
};
var define$2 = defineProperties_1$1;
var callBind$1 = callBind$4.exports;
var implementation$8 = implementation$a;
var getPolyfill$4 = polyfill$4;
var shim$4 = shim$5;
var flagsBound = callBind$1(implementation$8);
define$2(flagsBound, {
  getPolyfill: getPolyfill$4,
  implementation: implementation$8,
  shim: shim$4
});
var regexp_prototype_flags = flagsBound;
var toString$2 = {}.toString;
var isarray$1 = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$7 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$5 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$5 ? tryDateObject(value) : toStr$7.call(value) === dateClass;
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$6 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$4 = shams$1();
var isString$3 = function isString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$4 ? tryStringObject(value) : toStr$6.call(value) === strClass;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$3 = shams$1();
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$3 ? tryNumberObject(value) : toStr$5.call(value) === numClass;
};
var callBound$6 = callBound$9;
var $boolToStr = callBound$6("Boolean.prototype.toString");
var $toString$2 = callBound$6("Object.prototype.toString");
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};
var boolClass = "[object Boolean]";
var hasToStringTag$2 = shams$1();
var isBooleanObject = function isBoolean(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$2 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$2(value) === boolClass;
};
var isSymbol$2 = { exports: {} };
var toStr$4 = Object.prototype.toString;
var hasSymbols$4 = hasSymbols$7();
if (hasSymbols$4) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$2.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr$4.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  isSymbol$2.exports = function isSymbol2(value) {
    return false;
  };
}
var isBigint = { exports: {} };
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var $BigInt = commonjsGlobal.BigInt;
var hasBigints = function hasNativeBigInts() {
  return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
};
var hasBigInts = hasBigints();
if (hasBigInts) {
  var bigIntValueOf$1 = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf$1.call(value);
      return true;
    } catch (e) {
    }
    return false;
  };
  isBigint.exports = function isBigInt2(value) {
    if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
      return false;
    }
    if (typeof value === "bigint") {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  isBigint.exports = function isBigInt2(value) {
    return false;
  };
}
var isString$2 = isString$3;
var isNumber$1 = isNumberObject;
var isBoolean$1 = isBooleanObject;
var isSymbol$1 = isSymbol$2.exports;
var isBigInt$1 = isBigint.exports;
var whichBoxedPrimitive$1 = function whichBoxedPrimitive(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString$2(value)) {
    return "String";
  }
  if (isNumber$1(value)) {
    return "Number";
  }
  if (isBoolean$1(value)) {
    return "Boolean";
  }
  if (isSymbol$1(value)) {
    return "Symbol";
  }
  if (isBigInt$1(value)) {
    return "BigInt";
  }
};
var $Map$3 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$3;
if (!$Map$3) {
  exported$3 = function isMap3(x) {
    return false;
  };
}
var $mapHas$5 = $Map$3 ? Map.prototype.has : null;
var $setHas$4 = $Set$3 ? Set.prototype.has : null;
if (!exported$3 && !$mapHas$5) {
  exported$3 = function isMap3(x) {
    return false;
  };
}
var isMap$3 = exported$3 || function isMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$5.call(x);
    if ($setHas$4) {
      try {
        $setHas$4.call(x);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $Map$3;
  } catch (e) {
  }
  return false;
};
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$2;
if (!$Set$2) {
  exported$2 = function isSet3(x) {
    return false;
  };
}
var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
var $setHas$3 = $Set$2 ? Set.prototype.has : null;
if (!exported$2 && !$setHas$3) {
  exported$2 = function isSet3(x) {
    return false;
  };
}
var isSet$3 = exported$2 || function isSet(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $setHas$3.call(x);
    if ($mapHas$4) {
      try {
        $mapHas$4.call(x);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $Set$2;
  } catch (e) {
  }
  return false;
};
var $WeakMap$2 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported$1;
if (!$WeakMap$2) {
  exported$1 = function isWeakMap3(x) {
    return false;
  };
}
var $mapHas$3 = $WeakMap$2 ? $WeakMap$2.prototype.has : null;
var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
if (!exported$1 && !$mapHas$3) {
  exported$1 = function isWeakMap3(x) {
    return false;
  };
}
var isWeakmap = exported$1 || function isWeakMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$3.call(x, $mapHas$3);
    if ($setHas$2) {
      try {
        $setHas$2.call(x, $setHas$2);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $WeakMap$2;
  } catch (e) {
  }
  return false;
};
var $WeakMap$1 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap$1) {
  exported = function isWeakSet3(x) {
    return false;
  };
}
var $mapHas$2 = $WeakMap$1 ? $WeakMap$1.prototype.has : null;
var $setHas$1 = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported && !$setHas$1) {
  isWeakset = function isWeakSet3(x) {
    return false;
  };
}
var isWeakset = exported || function isWeakSet(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $setHas$1.call(x, $setHas$1);
    if ($mapHas$2) {
      try {
        $mapHas$2.call(x, $mapHas$2);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $WeakSet;
  } catch (e) {
  }
  return false;
};
var isMap$2 = isMap$3;
var isSet$2 = isSet$3;
var isWeakMap$1 = isWeakmap;
var isWeakSet$1 = isWeakset;
var whichCollection$1 = function whichCollection(value) {
  if (value && typeof value === "object") {
    if (isMap$2(value)) {
      return "Map";
    }
    if (isSet$2(value)) {
      return "Set";
    }
    if (isWeakMap$1(value)) {
      return "WeakMap";
    }
    if (isWeakSet$1(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return new Date().getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
var esGetIterator = { exports: {} };
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var isArguments$2 = isArguments$3;
if (hasSymbols$7() || shams$2()) {
  var $iterator = Symbol.iterator;
  esGetIterator.exports = function getIterator2(iterable) {
    if (iterable != null && typeof iterable[$iterator] !== "undefined") {
      return iterable[$iterator]();
    }
    if (isArguments$2(iterable)) {
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  var isArray$2 = isarray;
  var isString$1 = isString$3;
  var GetIntrinsic$4 = getIntrinsic$1;
  var $Map$1 = GetIntrinsic$4("%Map%", true);
  var $Set$1 = GetIntrinsic$4("%Set%", true);
  var callBound$5 = callBound$9;
  var $arrayPush = callBound$5("Array.prototype.push");
  var $charCodeAt = callBound$5("String.prototype.charCodeAt");
  var $stringSlice = callBound$5("String.prototype.slice");
  var advanceStringIndex = function advanceStringIndex2(S, index2) {
    var length2 = S.length;
    if (index2 + 1 >= length2) {
      return index2 + 1;
    }
    var first = $charCodeAt(S, index2);
    if (first < 55296 || first > 56319) {
      return index2 + 1;
    }
    var second = $charCodeAt(S, index2 + 1);
    if (second < 56320 || second > 57343) {
      return index2 + 1;
    }
    return index2 + 2;
  };
  var getArrayIterator = function getArrayIterator2(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;
        if (!done) {
          value = arraylike[i];
          i += 1;
        }
        return {
          done,
          value
        };
      }
    };
  };
  var getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
    if (isArray$2(iterable) || isArguments$2(iterable)) {
      return getArrayIterator(iterable);
    }
    if (isString$1(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value
          };
        }
      };
    }
    if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
      return iterable["_es6-shim iterator_"]();
    }
  };
  if (!$Map$1 && !$Set$1) {
    esGetIterator.exports = function getIterator2(iterable) {
      if (iterable != null) {
        return getNonCollectionIterator(iterable, true);
      }
    };
  } else {
    var isMap$1 = isMap$3;
    var isSet$1 = isSet$3;
    var $mapForEach = callBound$5("Map.prototype.forEach", true);
    var $setForEach = callBound$5("Set.prototype.forEach", true);
    if (typeof browser$1 === "undefined" || !browser$1.versions || !browser$1.versions.node) {
      var $mapIterator = callBound$5("Map.prototype.iterator", true);
      var $setIterator = callBound$5("Set.prototype.iterator", true);
      var getStopIterationIterator = function(iterator) {
        var done = false;
        return {
          next: function next() {
            try {
              return {
                done,
                value: done ? void 0 : iterator.next()
              };
            } catch (e) {
              done = true;
              return {
                done: true,
                value: void 0
              };
            }
          }
        };
      };
    }
    var $mapAtAtIterator = callBound$5("Map.prototype.@@iterator", true) || callBound$5("Map.prototype._es6-shim iterator_", true);
    var $setAtAtIterator = callBound$5("Set.prototype.@@iterator", true) || callBound$5("Set.prototype._es6-shim iterator_", true);
    var getCollectionIterator = function getCollectionIterator2(iterable) {
      if (isMap$1(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator($mapIterator(iterable));
        }
        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }
        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function(v, k) {
            $arrayPush(entries, [k, v]);
          });
          return getArrayIterator(entries);
        }
      }
      if (isSet$1(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator($setIterator(iterable));
        }
        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }
        if ($setForEach) {
          var values = [];
          $setForEach(iterable, function(v) {
            $arrayPush(values, v);
          });
          return getArrayIterator(values);
        }
      }
    };
    esGetIterator.exports = function getIterator2(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}
var _nodeResolve_empty = {};
var _nodeResolve_empty$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": _nodeResolve_empty
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(_nodeResolve_empty$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice$2 = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat$1 = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO$1 = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str2) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str2)) {
    return str2;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice$2.call(str2, intStr.length + 1);
      return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace$1.call(str2, sepRegex, "$&_");
}
var inspectCustom = require$$0.custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj2, options, depth, seen) {
  var opts = options || {};
  if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj2 === "undefined") {
    return "undefined";
  }
  if (obj2 === null) {
    return "null";
  }
  if (typeof obj2 === "boolean") {
    return obj2 ? "true" : "false";
  }
  if (typeof obj2 === "string") {
    return inspectString(obj2, opts);
  }
  if (typeof obj2 === "number") {
    if (obj2 === 0) {
      return Infinity / obj2 > 0 ? "0" : "-0";
    }
    var str2 = String(obj2);
    return numericSeparator ? addNumericSeparator(obj2, str2) : str2;
  }
  if (typeof obj2 === "bigint") {
    var bigIntStr = String(obj2) + "n";
    return numericSeparator ? addNumericSeparator(obj2, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj2 === "object") {
    return isArray$1(obj2) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj2) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj2 === "function") {
    var name = nameOf(obj2);
    var keys4 = arrObjKeys(obj2, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys4.length > 0 ? " { " + $join.call(keys4, ", ") + " }" : "");
  }
  if (isSymbol(obj2)) {
    var symString = hasShammedSymbols ? $replace$1.call(String(obj2), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj2);
    return typeof obj2 === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj2)) {
    var s = "<" + $toLowerCase.call(String(obj2.nodeName));
    var attrs = obj2.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj2.childNodes && obj2.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj2.nodeName)) + ">";
    return s;
  }
  if (isArray$1(obj2)) {
    if (obj2.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj2, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj2)) {
    var parts = arrObjKeys(obj2, inspect2);
    if ("cause" in obj2 && !isEnumerable.call(obj2, "cause")) {
      return "{ [" + String(obj2) + "] " + $join.call($concat$1.call("[cause]: " + inspect2(obj2.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj2) + "]";
    }
    return "{ [" + String(obj2) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj2 === "object" && customInspect) {
    if (inspectSymbol && typeof obj2[inspectSymbol] === "function") {
      return obj2[inspectSymbol]();
    } else if (customInspect !== "symbol" && typeof obj2.inspect === "function") {
      return obj2.inspect();
    }
  }
  if (isMap2(obj2)) {
    var mapParts = [];
    mapForEach.call(obj2, function(value, key) {
      mapParts.push(inspect2(key, obj2, true) + " => " + inspect2(value, obj2));
    });
    return collectionOf("Map", mapSize.call(obj2), mapParts, indent);
  }
  if (isSet2(obj2)) {
    var setParts = [];
    setForEach.call(obj2, function(value) {
      setParts.push(inspect2(value, obj2));
    });
    return collectionOf("Set", setSize.call(obj2), setParts, indent);
  }
  if (isWeakMap2(obj2)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet2(obj2)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj2)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj2)) {
    return markBoxed(inspect2(Number(obj2)));
  }
  if (isBigInt(obj2)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj2)));
  }
  if (isBoolean2(obj2)) {
    return markBoxed(booleanValueOf.call(obj2));
  }
  if (isString2(obj2)) {
    return markBoxed(inspect2(String(obj2)));
  }
  if (!isDate$1(obj2) && !isRegExp(obj2)) {
    var ys = arrObjKeys(obj2, inspect2);
    var isPlainObject2 = gPO$1 ? gPO$1(obj2) === Object.prototype : obj2 instanceof Object || obj2.constructor === Object;
    var protoTag = obj2 instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj2) === obj2 && toStringTag in obj2 ? $slice$2.call(toStr$3(obj2), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj2.constructor !== "function" ? "" : obj2.constructor.name ? obj2.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj2);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace$1.call(String(s), /"/g, "&quot;");
}
function isArray$1(obj2) {
  return toStr$3(obj2) === "[object Array]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isDate$1(obj2) {
  return toStr$3(obj2) === "[object Date]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isRegExp(obj2) {
  return toStr$3(obj2) === "[object RegExp]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isError(obj2) {
  return toStr$3(obj2) === "[object Error]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isString2(obj2) {
  return toStr$3(obj2) === "[object String]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isNumber(obj2) {
  return toStr$3(obj2) === "[object Number]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isBoolean2(obj2) {
  return toStr$3(obj2) === "[object Boolean]" && (!toStringTag || !(typeof obj2 === "object" && toStringTag in obj2));
}
function isSymbol(obj2) {
  if (hasShammedSymbols) {
    return obj2 && typeof obj2 === "object" && obj2 instanceof Symbol;
  }
  if (typeof obj2 === "symbol") {
    return true;
  }
  if (!obj2 || typeof obj2 !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj2);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj2) {
  if (!obj2 || typeof obj2 !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj2);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn$2 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has(obj2, key) {
  return hasOwn$2.call(obj2, key);
}
function toStr$3(obj2) {
  return objectToString.call(obj2);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap2(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap2(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet2(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet2(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str2, opts) {
  if (str2.length > opts.maxStringLength) {
    var remaining = str2.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice$2.call(str2, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace$1.call($replace$1.call(str2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str2) {
  return "Object(" + str2 + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj2, inspect2) {
  var isArr = isArray$1(obj2);
  var xs = [];
  if (isArr) {
    xs.length = obj2.length;
    for (var i = 0; i < obj2.length; i++) {
      xs[i] = has(obj2, i) ? inspect2(obj2[i], obj2) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj2) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj2) {
    if (!has(obj2, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj2.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj2) + ": " + inspect2(obj2[key], obj2));
    } else {
      xs.push(key + ": " + inspect2(obj2[key], obj2));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj2, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj2[syms[j]], obj2));
      }
    }
  }
  return xs;
}
var GetIntrinsic$3 = getIntrinsic$1;
var callBound$4 = callBound$9;
var inspect = objectInspect;
var $TypeError$1 = GetIntrinsic$3("%TypeError%");
var $WeakMap = GetIntrinsic$3("%WeakMap%", true);
var $Map = GetIntrinsic$3("%Map%", true);
var $weakMapGet = callBound$4("WeakMap.prototype.get", true);
var $weakMapSet = callBound$4("WeakMap.prototype.set", true);
var $weakMapHas = callBound$4("WeakMap.prototype.has", true);
var $mapGet$1 = callBound$4("Map.prototype.get", true);
var $mapSet = callBound$4("Map.prototype.set", true);
var $mapHas$1 = callBound$4("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$1("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet$1($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas$1($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var hasOwn$1 = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var foreach = function forEach(obj2, fn, ctx) {
  if (toString.call(fn) !== "[object Function]") {
    throw new TypeError("iterator must be a function");
  }
  var l = obj2.length;
  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj2[i], i, obj2);
    }
  } else {
    for (var k in obj2) {
      if (hasOwn$1.call(obj2, k)) {
        fn.call(ctx, obj2[k], k, obj2);
      }
    }
  }
};
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$2 = function availableTypedArrays() {
  var out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$2[possibleNames[i]] === "function") {
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};
var GetIntrinsic$2 = getIntrinsic$1;
var $gOPD$1 = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var getOwnPropertyDescriptor = $gOPD$1;
var forEach$1 = foreach;
var availableTypedArrays$1 = availableTypedArrays$2;
var callBound$3 = callBound$9;
var $toString$1 = callBound$3("Object.prototype.toString");
var hasToStringTag$1 = shams$1();
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays$1 = availableTypedArrays$1();
var $indexOf = callBound$3("Array.prototype.indexOf", true) || function indexOf2(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};
var $slice$1 = callBound$3("String.prototype.slice");
var toStrTags$1 = {};
var gOPD$1 = getOwnPropertyDescriptor;
var getPrototypeOf$1 = Object.getPrototypeOf;
if (hasToStringTag$1 && gOPD$1 && getPrototypeOf$1) {
  forEach$1(typedArrays$1, function(typedArray) {
    var arr = new g$1[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf$1(arr);
      var descriptor = gOPD$1(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = gOPD$1(superProto, Symbol.toStringTag);
      }
      toStrTags$1[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays$1 = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach$1(toStrTags$1, function(getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
      }
    }
  });
  return anyTrue;
};
var isTypedArray$1 = function isTypedArray(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!hasToStringTag$1 || !(Symbol.toStringTag in value)) {
    var tag = $slice$1($toString$1(value), 8, -1);
    return $indexOf(typedArrays$1, tag) > -1;
  }
  if (!gOPD$1) {
    return false;
  }
  return tryTypedArrays$1(value);
};
var forEach2 = foreach;
var availableTypedArrays2 = availableTypedArrays$2;
var callBound$2 = callBound$9;
var $toString = callBound$2("Object.prototype.toString");
var hasToStringTag = shams$1();
var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays2();
var $slice = callBound$2("String.prototype.slice");
var toStrTags = {};
var gOPD = getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach2(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays2(value) {
  var foundName = false;
  forEach2(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);
        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var isTypedArray2 = isTypedArray$1;
var whichTypedArray$1 = function whichTypedArray(value) {
  if (!isTypedArray2(value)) {
    return false;
  }
  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
    return $slice($toString(value), 8, -1);
  }
  return tryTypedArrays(value);
};
var keys$1 = objectKeys$2;
var canBeObject = function(obj2) {
  return typeof obj2 !== "undefined" && obj2 !== null;
};
var hasSymbols$3 = shams$2();
var callBound$1 = callBound$9;
var toObject = Object;
var $push = callBound$1("Array.prototype.push");
var $propIsEnumerable = callBound$1("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols$3 ? Object.getOwnPropertySymbols : null;
var implementation$7 = function assign(target, source1) {
  if (!canBeObject(target)) {
    throw new TypeError("target must be an object");
  }
  var objTarget = toObject(target);
  var s, source, i, props, syms, value, key;
  for (s = 1; s < arguments.length; ++s) {
    source = toObject(arguments[s]);
    props = keys$1(source);
    var getSymbols = hasSymbols$3 && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      syms = getSymbols(source);
      for (i = 0; i < syms.length; ++i) {
        key = syms[i];
        if ($propIsEnumerable(source, key)) {
          $push(props, key);
        }
      }
    }
    for (i = 0; i < props.length; ++i) {
      key = props[i];
      value = source[key];
      if ($propIsEnumerable(source, key)) {
        objTarget[key] = value;
      }
    }
  }
  return objTarget;
};
var implementation$6 = implementation$7;
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str2 = "abcdefghijklmnopqrst";
  var letters = str2.split("");
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj2 = Object.assign({}, map);
  var actual = "";
  for (var k in obj2) {
    actual += k;
  }
  return str2 !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$3 = function getPolyfill3() {
  if (!Object.assign) {
    return implementation$6;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$6;
  }
  if (assignHasPendingExceptions()) {
    return implementation$6;
  }
  return Object.assign;
};
var define$1 = defineProperties_1$1;
var getPolyfill$3 = polyfill$3;
var shim$3 = function shimAssign() {
  var polyfill3 = getPolyfill$3();
  define$1(
    Object,
    { assign: polyfill3 },
    { assign: function() {
      return Object.assign !== polyfill3;
    } }
  );
  return polyfill3;
};
var defineProperties$2 = defineProperties_1$1;
var callBind = callBind$4.exports;
var implementation$5 = implementation$7;
var getPolyfill$2 = polyfill$3;
var shim$2 = shim$3;
var polyfill$2 = callBind.apply(getPolyfill$2());
var bound = function assign2(target, source1) {
  return polyfill$2(Object, arguments);
};
defineProperties$2(bound, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$5,
  shim: shim$2
});
var object_assign = bound;
var objectKeys$1 = objectKeys$2;
var isArguments$1 = isArguments$3;
var is2 = objectIs;
var isRegex3 = isRegex$1;
var flags2 = regexp_prototype_flags;
var isArray = isarray$1;
var isDate = isDateObject;
var whichBoxedPrimitive2 = whichBoxedPrimitive$1;
var GetIntrinsic$1 = getIntrinsic$1;
var callBound = callBound$9;
var whichCollection2 = whichCollection$1;
var getIterator = esGetIterator.exports;
var getSideChannel2 = sideChannel;
var whichTypedArray2 = whichTypedArray$1;
var assign3 = object_assign;
var $getTime = callBound("Date.prototype.getTime");
var gPO = Object.getPrototypeOf;
var $objToString = callBound("Object.prototype.toString");
var $Set = GetIntrinsic$1("%Set%", true);
var $mapHas = callBound("Map.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSize = callBound("Map.prototype.size", true);
var $setAdd = callBound("Set.prototype.add", true);
var $setDelete = callBound("Set.prototype.delete", true);
var $setHas = callBound("Set.prototype.has", true);
var $setSize = callBound("Set.prototype.size", true);
function setHasEqualElement(set2, val1, opts, channel) {
  var i = getIterator(set2);
  var result;
  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) {
      $setDelete(set2, result.value);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === "undefined") {
    return null;
  }
  if (typeof prim === "object") {
    return void 0;
  }
  if (typeof prim === "symbol") {
    return false;
  }
  if (typeof prim === "string" || typeof prim === "number") {
    return +prim === +prim;
  }
  return true;
}
function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet(b, altValue);
  var looseOpts = assign3({}, opts, { strict: false });
  if (typeof curB === "undefined" && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
    return false;
  }
  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  return $setHas(b, altValue) && !$setHas(a, altValue);
}
function mapHasEqualEntry(set2, map, key1, item1, opts, channel) {
  var i = getIterator(set2);
  var result;
  var key2;
  while ((result = i.next()) && !result.done) {
    key2 = result.value;
    if (internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
      $setDelete(set2, key2);
      return true;
    }
  }
  return false;
}
function internalDeepEqual(actual, expected, options, channel) {
  var opts = options || {};
  if (opts.strict ? is2(actual, expected) : actual === expected) {
    return true;
  }
  var actualBoxed = whichBoxedPrimitive2(actual);
  var expectedBoxed = whichBoxedPrimitive2(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is2(actual, expected) : actual == expected;
  }
  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) {
    channel.set(actual, sentinel);
  }
  if (!hasExpected) {
    channel.set(expected, sentinel);
  }
  return objEquiv(actual, expected, opts, channel);
}
function isBuffer(x) {
  if (!x || typeof x !== "object" || typeof x.length !== "number") {
    return false;
  }
  if (typeof x.copy !== "function" || typeof x.slice !== "function") {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== "number") {
    return false;
  }
  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
}
function setEquiv(a, b, opts, channel) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set2;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === "object") {
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, resultA.value);
    } else if (!$setHas(b, resultA.value)) {
      if (opts.strict) {
        return false;
      }
      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, resultA.value);
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      if (resultB.value && typeof resultB.value === "object") {
        if (!setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function mapEquiv(a, b, opts, channel) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set2;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === "object") {
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, key);
    } else {
      item2 = $mapGet(b, key);
      if (typeof item2 === "undefined" && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
          return false;
        }
        if (!set2) {
          set2 = new $Set();
        }
        $setAdd(set2, key);
      }
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === "object") {
        if (!mapHasEqualEntry(set2, a, key, item2, opts, channel)) {
          return false;
        }
      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) && !mapHasEqualEntry(set2, a, key, item2, assign3({}, opts, { strict: false }), channel)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function objEquiv(a, b, opts, channel) {
  var i, key;
  if (typeof a !== typeof b) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if ($objToString(a) !== $objToString(b)) {
    return false;
  }
  if (isArguments$1(a) !== isArguments$1(b)) {
    return false;
  }
  var aIsArray = isArray(a);
  var bIsArray = isArray(b);
  if (aIsArray !== bIsArray) {
    return false;
  }
  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;
  if (aIsError !== bIsError) {
    return false;
  }
  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) {
      return false;
    }
  }
  var aIsRegex = isRegex3(a);
  var bIsRegex = isRegex3(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags2(a) !== flags2(b))) {
    return false;
  }
  var aIsDate = isDate(a);
  var bIsDate = isDate(b);
  if (aIsDate !== bIsDate) {
    return false;
  }
  if (aIsDate || bIsDate) {
    if ($getTime(a) !== $getTime(b)) {
      return false;
    }
  }
  if (opts.strict && gPO && gPO(a) !== gPO(b)) {
    return false;
  }
  if (whichTypedArray2(a) !== whichTypedArray2(b)) {
    return false;
  }
  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  var ka = objectKeys$1(a);
  var kb = objectKeys$1(b);
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    }
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!internalDeepEqual(a[key], b[key], opts, channel)) {
      return false;
    }
  }
  var aCollection = whichCollection2(a);
  var bCollection = whichCollection2(b);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === "Set" || bCollection === "Set") {
    return setEquiv(a, b, opts, channel);
  }
  if (aCollection === "Map") {
    return mapEquiv(a, b, opts, channel);
  }
  return true;
}
var deepEqual = function deepEqual2(a, b, opts) {
  return internalDeepEqual(a, b, opts, getSideChannel2());
};
var toStr$2 = Object.prototype.toString;
var isArguments4 = function isArguments5(value) {
  var str2 = toStr$2.call(value);
  var isArgs2 = str2 === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$2.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$4;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation$4;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments4;
    var isEnumerable2 = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable2.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable2.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim2 = function keys4(object3) {
      var isObject2 = object3 !== null && typeof object3 === "object";
      var isFunction2 = toStr2.call(object3) === "[object Function]";
      var isArguments6 = isArgs2(object3);
      var isString3 = isObject2 && toStr2.call(object3) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments6) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString3 && object3.length > 0 && !has2.call(object3, 0)) {
        for (var i = 0; i < object3.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments6 && object3.length > 0) {
        for (var j = 0; j < object3.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object3) {
          if (!(skipProto && name === "prototype") && has2.call(object3, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object3);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object3, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$4 = keysShim2;
  return implementation$4;
}
var slice$1 = Array.prototype.slice;
var isArgs = isArguments4;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys2(o) {
  return origKeys(o);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys2() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys4(object3) {
        if (isArgs(object3)) {
          return originalKeys(slice$1.call(object3));
        }
        return originalKeys(object3);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var shams = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj2 = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj2[sym] = symVal;
  for (sym in obj2) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj2);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj2, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$2 = function hasNativeSymbols2() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$3 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target.apply(
        this,
        args.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$2 = implementation$3;
var functionBind = Function.prototype.bind || implementation$2;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$2();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval2 = function doEval3(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval3("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval3("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind3 = functionBind;
var hasOwn = src;
var $concat = bind3.call(Function.call, Array.prototype.concat);
var $spliceApply = bind3.call(Function.apply, Array.prototype.splice);
var $replace = bind3.call(Function.call, String.prototype.replace);
var $strSlice = bind3.call(Function.call, String.prototype.slice);
var $exec = bind3.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath2 = function stringToPath3(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval2(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath2(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic2("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var GetIntrinsic3 = getIntrinsic;
var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var keys3 = objectKeys;
var hasSymbols3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function(fn) {
  return typeof fn === "function" && toStr.call(fn) === "[object Function]";
};
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var supportsDescriptors = origDefineProperty && hasPropertyDescriptors2;
var defineProperty = function(object3, name, value, predicate) {
  if (name in object3 && (!isFunction(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors) {
    origDefineProperty(object3, name, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object3[name] = value;
  }
};
var defineProperties$1 = function(object3, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys3(map);
  if (hasSymbols3) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object3, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties$1.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties$1;
var implementation_browser = { exports: {} };
if (typeof self !== "undefined") {
  implementation_browser.exports = self;
} else if (typeof window !== "undefined") {
  implementation_browser.exports = window;
} else {
  implementation_browser.exports = Function("return this")();
}
var implementation$1 = implementation_browser.exports;
var polyfill$1 = function getPolyfill4() {
  if (typeof commonjsGlobal$1 !== "object" || !commonjsGlobal$1 || commonjsGlobal$1.Math !== Math || commonjsGlobal$1.Array !== Array) {
    return implementation$1;
  }
  return commonjsGlobal$1;
};
var define = defineProperties_1;
var getPolyfill$1 = polyfill$1;
var shim$1 = function shimGlobal() {
  var polyfill3 = getPolyfill$1();
  if (define.supportsDescriptors) {
    var descriptor = Object.getOwnPropertyDescriptor(polyfill3, "globalThis");
    if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill3)) {
      Object.defineProperty(polyfill3, "globalThis", {
        configurable: true,
        enumerable: false,
        value: polyfill3,
        writable: true
      });
    }
  } else if (typeof globalThis !== "object" || globalThis !== polyfill3) {
    polyfill3.globalThis = polyfill3;
  }
  return polyfill3;
};
var defineProperties = defineProperties_1;
var implementation = implementation_browser.exports;
var getPolyfill5 = polyfill$1;
var shim = shim$1;
var polyfill2 = getPolyfill5();
var getGlobal = function() {
  return polyfill2;
};
defineProperties(getGlobal, {
  getPolyfill: getPolyfill5,
  implementation,
  shim
});
var globalthis = getGlobal;
function ownKeys$k(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$k(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var vtkGlobal = globalthis();
var factoryMapping = {
  vtkObject: function vtkObject() {
    return null;
  }
};
function vtk(obj2) {
  if (obj2 === null || obj2 === void 0) {
    return obj2;
  }
  if (obj2.isA) {
    return obj2;
  }
  if (!obj2.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("Invalid VTK object");
    }
    return null;
  }
  var constructor = factoryMapping[obj2.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("No vtk class found for Object of type ".concat(obj2.vtkClass));
    }
    return null;
  }
  var model = _objectSpread$k({}, obj2);
  Object.keys(model).forEach(function(keyName) {
    if (model[keyName] && _typeof(model[keyName]) === "object" && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });
  var newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}
vtk.register = register;
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _superPropBase(object3, property) {
  while (!Object.prototype.hasOwnProperty.call(object3, property)) {
    object3 = _getPrototypeOf(object3);
    if (object3 === null)
      break;
  }
  return object3;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ClassHierarchy = /* @__PURE__ */ function(_Array) {
  _inherits(ClassHierarchy2, _Array);
  var _super = _createSuper(ClassHierarchy2);
  function ClassHierarchy2() {
    _classCallCheck(this, ClassHierarchy2);
    return _super.apply(this, arguments);
  }
  _createClass(ClassHierarchy2, [{
    key: "push",
    value: function push() {
      var _get2;
      var newArgs = [];
      for (var i = 0; i < arguments.length; i++) {
        if (!this.includes(arguments[i])) {
          newArgs.push(arguments[i]);
        }
      }
      return (_get2 = _get(_getPrototypeOf(ClassHierarchy2.prototype), "push", this)).call.apply(_get2, [this].concat(newArgs));
    }
  }]);
  return ClassHierarchy2;
}(/* @__PURE__ */ _wrapNativeSuper(Array));
function ownKeys$j(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$j(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var globalMTime = 0;
var VOID = Symbol("void");
function getCurrentGlobalMTime() {
  return globalMTime;
}
var fakeConsole = {};
function noOp() {
}
var consoleMethods = ["log", "debug", "info", "warn", "error", "time", "timeEnd", "group", "groupEnd"];
consoleMethods.forEach(function(methodName) {
  fakeConsole[methodName] = noOp;
});
vtkGlobal.console = console.hasOwnProperty("log") ? console : fakeConsole;
var loggerFunctions = {
  debug: noOp,
  error: vtkGlobal.console.error || noOp,
  info: vtkGlobal.console.info || noOp,
  log: vtkGlobal.console.log || noOp,
  warn: vtkGlobal.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log.apply(loggerFunctions, arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info.apply(loggerFunctions, arguments);
}
function vtkDebugMacro$8() {
  loggerFunctions.debug.apply(loggerFunctions, arguments);
}
function vtkErrorMacro$j() {
  loggerFunctions.error.apply(loggerFunctions, arguments);
}
function vtkWarningMacro$7() {
  loggerFunctions.warn.apply(loggerFunctions, arguments);
}
var ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str2) {
  if (!ERROR_ONCE_MAP[str2]) {
    loggerFunctions.error(str2);
    ERROR_ONCE_MAP[str2] = true;
  }
}
var TYPED_ARRAYS = /* @__PURE__ */ Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return _construct(TYPED_ARRAYS[type] || Float64Array, args);
}
function newTypedArrayFrom(type) {
  var _ref;
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (_ref = TYPED_ARRAYS[type] || Float64Array).from.apply(_ref, args);
}
function capitalize(str2) {
  return str2.charAt(0).toUpperCase() + str2.slice(1);
}
function _capitalize(str2) {
  return capitalize(str2[0] === "_" ? str2.slice(1) : str2);
}
function uncapitalize(str2) {
  return str2.charAt(0).toLowerCase() + str2.slice(1);
}
function formatBytesToProperUnit(size2) {
  var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var chunkSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
  var units = ["TB", "GB", "MB", "KB"];
  var value = Number(size2);
  var currentUnit = "B";
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return "".concat(value.toFixed(precision), " ").concat(currentUnit);
}
function formatNumbersWithThousandSeparator(n) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  var sections = [];
  var size2 = n;
  while (size2 > 1e3) {
    sections.push("000".concat(size2 % 1e3).slice(-3));
    size2 = Math.floor(size2 / 1e3);
  }
  if (size2 > 0) {
    sections.push(size2);
  }
  sections.reverse();
  return sections.join(separator);
}
function safeArrays(model) {
  Object.keys(model).forEach(function(key) {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function enumToString(e, value) {
  return Object.keys(e).find(function(key) {
    return e[key] === value;
  });
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}
function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}
function measurePromiseExecution(promise, callback) {
  var start = performance.now();
  promise.finally(function() {
    var delta = performance.now() - start;
    callback(delta);
  });
}
function obj() {
  var publicAPI = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  safeArrays(model);
  var callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!("classHierarchy" in model)) {
    model.classHierarchy = new ClassHierarchy("vtkObject");
  } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
    model.classHierarchy = ClassHierarchy.from(model.classHierarchy);
  }
  function off2(index2) {
    callbacks[index2] = null;
  }
  function on2(index2) {
    function unsubscribe() {
      off2(index2);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = function() {
    return !!model.deleted;
  };
  publicAPI.modified = function(otherMTime) {
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach(function(callback) {
      return callback && callback(publicAPI);
    });
  };
  publicAPI.onModified = function(callback) {
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return null;
    }
    var index2 = callbacks.length;
    callbacks.push(callback);
    return on2(index2);
  };
  publicAPI.getMTime = function() {
    return model.mtime;
  };
  publicAPI.isA = function(className) {
    var count = model.classHierarchy.length;
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function() {
    var depth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function() {
    var map = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var noWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var noFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var ret = false;
    Object.keys(map).forEach(function(name) {
      var fn = noFunction ? null : publicAPI["set".concat(capitalize(name))];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn.apply(void 0, _toConsumableArray(map[name])) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        if (["mtime"].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro$7("Warning: Set value to model directly ".concat(name, ", ").concat(map[name]));
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function() {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    var subset = {};
    list.forEach(function(name) {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = function(val) {
    return model[val];
  };
  publicAPI.delete = function() {
    Object.keys(model).forEach(function(field) {
      return delete model[field];
    });
    callbacks.forEach(function(el, index2) {
      return off2(index2);
    });
    model.deleted = true;
  };
  publicAPI.getState = function() {
    if (model.deleted) {
      return null;
    }
    var jsonArchive = _objectSpread$j(_objectSpread$j({}, model), {}, {
      vtkClass: publicAPI.getClassName()
    });
    Object.keys(jsonArchive).forEach(function(keyName) {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === void 0 || keyName[0] === "_") {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      }
    });
    var sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(function(name) {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error("Cannot ShallowCopy ".concat(other.getClassName(), " into ").concat(publicAPI.getClassName()));
    }
    var otherModel = other.get();
    var keyList = Object.keys(model).sort();
    var otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach(function(key) {
      var keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro$8("add ".concat(key, " in shallowCopy"));
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro$8("Untouched keys: ".concat(keyList.join(", ")));
    }
    publicAPI.modified();
  };
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };
  return publicAPI;
}
var objectGetterMap = {
  object: function object(publicAPI, model, field) {
    return function getter() {
      return _objectSpread$j({}, model[field.name]);
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach(function(field) {
    if (_typeof(field) === "object") {
      var getter = objectGetterMap[field.type];
      if (getter) {
        publicAPI["get".concat(_capitalize(field.name))] = getter(publicAPI, model, field);
      } else {
        publicAPI["get".concat(_capitalize(field.name))] = function() {
          return model[field.name];
        };
      }
    } else {
      publicAPI["get".concat(_capitalize(field))] = function() {
        return model[field];
      };
    }
  });
}
var objectSetterMap = {
  enum: function _enum(publicAPI, model, field) {
    return function(value) {
      if (typeof value === "string") {
        if (field.enum[value] !== void 0) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro$j("Set Enum with invalid argument ".concat(field, ", ").concat(value));
        throw new RangeError("Set Enum with invalid string argument");
      }
      if (typeof value === "number") {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map(function(key) {
            return field.enum[key];
          }).indexOf(value) !== -1) {
            model[field.name] = value;
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro$j("Set Enum outside numeric range ".concat(field, ", ").concat(value));
          throw new RangeError("Set Enum outside numeric range");
        }
        return false;
      }
      vtkErrorMacro$j("Set Enum with invalid argument (String/Number) ".concat(field, ", ").concat(value));
      throw new TypeError("Set Enum with invalid argument (String/Number)");
    };
  },
  object: function object2(publicAPI, model, field) {
    return function(value) {
      if (!deepEqual(model[field.name], value)) {
        model[field.name] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  }
};
function findSetter(field) {
  if (_typeof(field) === "object") {
    var fn = objectSetterMap[field.type];
    if (fn) {
      return function(publicAPI, model) {
        return fn(publicAPI, model, field);
      };
    }
    vtkErrorMacro$j("No setter for field ".concat(field));
    throw new TypeError("No setter for field");
  }
  return function getSetter(publicAPI, model) {
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro$j("instance deleted - cannot call any method");
        return false;
      }
      if (model[field] !== value) {
        model[field] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set(publicAPI, model, fields) {
  fields.forEach(function(field) {
    if (_typeof(field) === "object") {
      publicAPI["set".concat(_capitalize(field.name))] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI["set".concat(_capitalize(field))] = findSetter(field)(publicAPI, model);
    }
  });
}
function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}
function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach(function(field) {
    publicAPI["get".concat(_capitalize(field))] = function() {
      return model[field] ? [].concat(model[field]) : model[field];
    };
    publicAPI["get".concat(_capitalize(field), "ByReference")] = function() {
      return model[field];
    };
  });
}
function setArray(publicAPI, model, fieldNames, size2) {
  var defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  fieldNames.forEach(function(field) {
    if (model[field] && size2 && model[field].length !== size2) {
      throw new RangeError("Invalid initial number of values for array (".concat(field, ")"));
    }
    publicAPI["set".concat(_capitalize(field))] = function() {
      if (model.deleted) {
        vtkErrorMacro$j("instance deleted - cannot call any method");
        return false;
      }
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      var array = args;
      var changeDetected;
      var needCopy = false;
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        array = array[0];
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size2 && array.length !== size2) {
          if (array.length < size2 && defaultVal !== void 0) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size2) {
              array.push(defaultVal);
            }
          } else {
            throw new RangeError("Invalid number of values for array setter (".concat(field, ")"));
          }
        }
        changeDetected = model[field] == null || model[field].some(function(item, index2) {
          return item !== array[index2];
        }) || model[field].length !== array.length;
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        model[field] = array;
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI["set".concat(_capitalize(field), "From")] = function(otherArray) {
      var target = model[field];
      otherArray.forEach(function(v, i) {
        target[i] = v;
      });
    };
  });
}
function setGetArray(publicAPI, model, fieldNames, size2) {
  var defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size2, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (var i = 0; i < fieldNames.length; i++) {
    var fieldName = fieldNames[i];
    if (model[fieldName] !== void 0) {
      model["_".concat(fieldName)] = model[fieldName];
      delete model[fieldName];
    }
  }
}
function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(vtk);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(vtk);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(vtk);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
  } else {
    model.inputArrayToProcess = [];
  }
  model.numberOfInputs = numberOfInputs;
  function setInputData(dataset) {
    var port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro$j("algorithm ".concat(publicAPI.getClassName(), " only has ").concat(model.numberOfInputs, " input ports. To add more input ports, use addInputData()"));
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    var port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      var msg = "algorithm ".concat(publicAPI.getClassName(), " only has ");
      msg += "".concat(model.numberOfInputs);
      msg += " input ports. To add more input ports, use addInputConnection()";
      vtkErrorMacro$j(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    var portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = function() {
    var localMTime = publicAPI.getMTime();
    var minOutputMTime = Infinity;
    var count2 = numberOfOutputs;
    while (count2--) {
      if (!model.output[count2] || model.output[count2].isDeleted()) {
        return true;
      }
      var mt = model.output[count2].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count2 = model.numberOfInputs;
    while (count2--) {
      var _model$inputConnectio, _publicAPI$getInputDa;
      if ((_model$inputConnectio = model.inputConnection[count2]) !== null && _model$inputConnectio !== void 0 && _model$inputConnectio.filter.shouldUpdate() || ((_publicAPI$getInputDa = publicAPI.getInputData(count2)) === null || _publicAPI$getInputDa === void 0 ? void 0 : _publicAPI$getInputDa.getMTime()) > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var outputPortAccess = function outputPortAccess2() {
      return getOutputData(port);
    };
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }
  if (model.numberOfInputs) {
    var count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = function() {
    var ins = [];
    if (model.numberOfInputs) {
      var _count = 0;
      while (_count < model.numberOfInputs) {
        ins[_count] = publicAPI.getInputData(_count);
        _count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = function() {
    return model.numberOfInputs;
  };
  publicAPI.getNumberOfOutputPorts = function() {
    return numberOfOutputs || model.output.length;
  };
  publicAPI.getInputArrayToProcess = function(inputPort) {
    var arrayDesc = model.inputArrayToProcess[inputPort];
    var ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds["get".concat(arrayDesc.fieldAssociation)]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function(inputPort, arrayName, fieldAssociation) {
    var attributeType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}
var EVENT_ABORT = Symbol("Event abort");
function event(publicAPI, model, eventName) {
  var callbacks = [];
  var previousDelete = publicAPI.delete;
  var curCallbackID = 1;
  function off2(callbackID) {
    for (var i = 0; i < callbacks.length; ++i) {
      var _callbacks$i = _slicedToArray(callbacks[i], 1), cbID = _callbacks$i[0];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }
  function on2(callbackID) {
    function unsubscribe() {
      off2(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    var _arguments = arguments;
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return;
    }
    var currentCallbacks = callbacks.slice();
    var _loop = function _loop2(index3) {
      var _currentCallbacks$ind = _slicedToArray(currentCallbacks[index3], 3), cb = _currentCallbacks$ind[1], priority = _currentCallbacks$ind[2];
      if (!cb) {
        return "continue";
      }
      if (priority < 0) {
        setTimeout(function() {
          return cb.apply(publicAPI, _arguments);
        }, 1 - priority);
      } else {
        var continueNext = cb.apply(publicAPI, _arguments);
        if (continueNext === EVENT_ABORT) {
          return "break";
        }
      }
    };
    for (var index2 = 0; index2 < currentCallbacks.length; ++index2) {
      var _ret = _loop(index2);
      if (_ret === "continue")
        continue;
      if (_ret === "break")
        break;
    }
  }
  publicAPI["invoke".concat(_capitalize(eventName))] = invoke;
  publicAPI["on".concat(_capitalize(eventName))] = function(callback) {
    var priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!callback.apply) {
      console.error("Invalid callback for event ".concat(eventName));
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro$j("instance deleted - cannot call any method");
      return null;
    }
    var callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort(function(cb1, cb2) {
      return cb2[2] - cb1[2];
    });
    return on2(callbackID);
  };
  publicAPI.delete = function() {
    previousDelete();
    callbacks.forEach(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1), cbID = _ref3[0];
      return off2(cbID);
    });
  };
}
function newInstance$X(extend2, className) {
  var constructor = function constructor2() {
    var initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var model = {};
    var publicAPI = {};
    extend2(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };
  if (className) {
    vtk.register(className, constructor);
  }
  return constructor;
}
function chain() {
  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    fn[_key5] = arguments[_key5];
  }
  return function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return fn.filter(function(i) {
      return !!i;
    }).map(function(i) {
      return i.apply(void 0, args);
    });
  };
}
function isVtkObject(instance) {
  return instance && instance.isA && instance.isA("vtkObject");
}
function traverseInstanceTree(instance, extractFunction) {
  var accumulator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var visitedInstances = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      return accumulator;
    }
    visitedInstances.push(instance);
    var result = extractFunction(instance);
    if (result !== void 0) {
      accumulator.push(result);
    }
    var model = instance.get();
    Object.keys(model).forEach(function(key) {
      var modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach(function(subObj) {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}
function debounce(func, wait, immediate) {
  var _this = this;
  var timeout;
  var debounced = function debounced2() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    var context = _this;
    var later = function later2() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = function() {
    return clearTimeout(timeout);
  };
  return debounced;
}
function throttle(callback, delay) {
  var isThrottled = false;
  var argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper.apply(void 0, _toConsumableArray(argsToUse));
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback.apply(void 0, args);
    setTimeout(next, delay);
  }
  return wrapper;
}
function keystore(publicAPI, model) {
  var initialKeystore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = function(key, value) {
    model.keystore[key] = value;
  };
  publicAPI.getKey = function(key) {
    return model.keystore[key];
  };
  publicAPI.getAllKeys = function() {
    return Object.keys(model.keystore);
  };
  publicAPI.deleteKey = function(key) {
    return delete model.keystore[key];
  };
  publicAPI.clearKeystore = function() {
    return publicAPI.getAllKeys().forEach(function(key) {
      return delete model.keystore[key];
    });
  };
}
var nextProxyId = 1;
var ROOT_GROUP_NAME = "__root__";
function proxy(publicAPI, model) {
  keystore(publicAPI, model);
  var parentDelete = publicAPI.delete;
  model.proxyId = "".concat(nextProxyId++);
  model.ui = JSON.parse(JSON.stringify(model.ui || []));
  get(publicAPI, model, ["proxyId", "proxyGroup", "proxyName"]);
  setGet(publicAPI, model, ["proxyManager"]);
  var propertyMap = {};
  var groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    var childrenNames = groupChildrenNames[currentGroupName];
    for (var i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = function(ui) {
    model.ui = JSON.parse(JSON.stringify(ui || []));
    Object.keys(propertyMap).forEach(function(k) {
      return delete propertyMap[k];
    });
    Object.keys(groupChildrenNames).forEach(function(k) {
      return delete groupChildrenNames[k];
    });
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    var gName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = function(propertyName, propUI) {
    var prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = _objectSpread$j({}, propUI);
    }
  };
  publicAPI.activate = function() {
    if (model.proxyManager) {
      var setActiveMethod = "setActive".concat(_capitalize(publicAPI.getProxyGroup().slice(0, -1)));
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = function(otherLink, type) {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = function(type) {
    var subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function(id) {
    var persistent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    var value = null;
    var links = [];
    var count = 0;
    var updateInProgress = false;
    function update(source) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      var needUpdate = [];
      var sourceLink = null;
      count = links.length;
      while (count--) {
        var link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      var newValue = sourceLink.instance["get".concat(_capitalize(sourceLink.propertyName))]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          var linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set(_defineProperty({}, linkToUpdate.propertyName, value));
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      var indexToDelete = [];
      count = links.length;
      while (count--) {
        var link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === void 0)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind4(instance, propertyName) {
      var updateMe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var subscription = instance.onModified(update);
      var other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== void 0) {
          instance.set(_defineProperty({}, propertyName, model.propertyLinkMap[id].value));
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: function unsubscribe2() {
          return unbind(instance, propertyName);
        }
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    var linkHandler = {
      bind: bind4,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };
  function getProperties() {
    var groupName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    var values = [];
    var id = model.proxyId;
    var propertyNames = listProxyProperties(groupName) || [];
    for (var i = 0; i < propertyNames.length; i++) {
      var name = propertyNames[i];
      var method = publicAPI["get".concat(_capitalize(name))];
      var value = method ? method() : void 0;
      var prop = {
        id,
        name,
        value
      };
      var children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = function() {
    return getProperties().map(function(p2) {
      return p2.name;
    });
  };
  publicAPI.getPropertyByName = function(name) {
    return getProperties().find(function(p2) {
      return p2.name === name;
    });
  };
  publicAPI.getPropertyDomainByName = function(name) {
    return (propertyMap[name] || {}).domain;
  };
  publicAPI.getProxySection = function() {
    return {
      id: model.proxyId,
      name: model.proxyGroup,
      ui: model.ui,
      properties: getProperties()
    };
  };
  publicAPI.delete = function() {
    var list = Object.keys(model.propertyLinkMap);
    var count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };
  publicAPI.getState = function() {
    return null;
  };
  function registerLinks() {
    if (model.links) {
      for (var i = 0; i < model.links.length; i++) {
        var _model$links$i = model.links[i], link = _model$links$i.link, property = _model$links$i.property, persistent = _model$links$i.persistent, updateOnBind = _model$links$i.updateOnBind, type = _model$links$i.type;
        if (type === "application") {
          var sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, "application");
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}
function proxyPropertyMapping(publicAPI, model, map) {
  var parentDelete = publicAPI.delete;
  var subscriptions = [];
  var propertyNames = Object.keys(map);
  var count = propertyNames.length;
  while (count--) {
    var propertyName = propertyNames[count];
    var _map$propertyName = map[propertyName], modelKey = _map$propertyName.modelKey, property = _map$propertyName.property, _map$propertyName$mod = _map$propertyName.modified, modified = _map$propertyName$mod === void 0 ? true : _map$propertyName$mod;
    var methodSrc = _capitalize(property);
    var methodDst = _capitalize(propertyName);
    publicAPI["get".concat(methodDst)] = model[modelKey]["get".concat(methodSrc)];
    publicAPI["set".concat(methodDst)] = model[modelKey]["set".concat(methodSrc)];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = function() {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}
function proxyPropertyState(publicAPI, model) {
  var state2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var defaults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    var modelKeys2 = Object.keys(map);
    var count2 = modelKeys2.length;
    while (count2--) {
      var modelKey = modelKeys2[count2];
      model[modelKey].set(map[modelKey]);
    }
  }
  var modelKeys = Object.keys(defaults);
  var count = modelKeys.length;
  var _loop2 = function _loop22() {
    var key = modelKeys[count];
    model[key] = defaults[key];
    var mapping = state2[key];
    publicAPI["set".concat(_capitalize(key))] = function(value) {
      if (value !== model[key]) {
        model[key] = value;
        var propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  };
  while (count--) {
    _loop2();
  }
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  var sX = 0;
  var sY = 0;
  var pX = 0;
  var pY = 0;
  if ("detail" in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ("wheelDelta" in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ("wheelDeltaY" in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }
  if ("axis" in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ("deltaX" in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}
var macro = {
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  measurePromiseExecution,
  moveToProtected,
  newInstance: newInstance$X,
  newTypedArray,
  newTypedArrayFrom,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  uncapitalize,
  VOID,
  vtkDebugMacro: vtkDebugMacro$8,
  vtkErrorMacro: vtkErrorMacro$j,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro: vtkWarningMacro$7
};
var vtkErrorMacro$i = macro.vtkErrorMacro, vtkWarningMacro$6 = macro.vtkWarningMacro;
var randomSeedValue = 0;
var VTK_MAX_ROTATIONS = 20;
var VTK_SMALL_NUMBER = 1e-12;
function notImplemented$2(method) {
  return function() {
    return vtkErrorMacro$i("vtkMath::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function swapRowsMatrix_nxn(matrix, n, row1, row2) {
  var tmp;
  for (var i = 0; i < n; i++) {
    tmp = matrix[row1 * n + i];
    matrix[row1 * n + i] = matrix[row2 * n + i];
    matrix[row2 * n + i] = tmp;
  }
}
function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
  var tmp;
  for (var i = 0; i < n; i++) {
    tmp = matrix[i * n + column1];
    matrix[i * n + column1] = matrix[i * n + column2];
    matrix[i * n + column2] = tmp;
  }
}
function createArray() {
  var size2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
  return Array(size2).fill(0);
}
var Pi = function Pi2() {
  return Math.PI;
};
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
var round = Math.round, floor = Math.floor, ceil = Math.ceil, min = Math.min, max = Math.max;
function arrayMin(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var minValue = Infinity;
  for (var i = offset, len2 = arr.length; i < len2; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var maxValue = -Infinity;
  for (var i = offset, len2 = arr.length; i < len2; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var minValue = Infinity;
  var maxValue = -Infinity;
  for (var i = offset, len2 = arr.length; i < len2; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return [minValue, maxValue];
}
var ceilLog2 = notImplemented$2("ceilLog2");
var factorial = notImplemented$2("factorial");
function nearestPowerOfTwo(xi) {
  var v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  var r = 1;
  for (var i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }
  var r = createArray(n);
  for (var i = 0; i < n; ++i) {
    r[i] = i;
  }
  return r;
}
function nextCombination(m, n, r) {
  var status = 0;
  for (var i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      var j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  seedrandom("".concat(seed), {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  var minValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var maxValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
var gaussian = notImplemented$2("gaussian");
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  out_3x3[0] = x[0] * y[0];
  out_3x3[1] = x[0] * y[1];
  out_3x3[2] = x[0] * y[2];
  out_3x3[3] = x[1] * y[0];
  out_3x3[4] = x[1] * y[1];
  out_3x3[5] = x[1] * y[2];
  out_3x3[6] = x[2] * y[0];
  out_3x3[7] = x[2] * y[1];
  out_3x3[8] = x[2] * y[2];
}
function cross(x, y, out) {
  var Zx = x[1] * y[2] - x[2] * y[1];
  var Zy = x[2] * y[0] - x[0] * y[2];
  var Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default: {
      var sum = 0;
      for (var i = 0; i < n; i++) {
        sum += x[i] * x[i];
      }
      return Math.sqrt(sum);
    }
  }
}
function normalize(x) {
  var den = norm(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}
function perpendiculars(x, y, z, theta) {
  var x2 = x[0] * x[0];
  var y2 = x[1] * x[1];
  var z2 = x[2] * x[2];
  var r = Math.sqrt(x2 + y2 + z2);
  var dx;
  var dy;
  var dz;
  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }
  var a = x[dx] / r;
  var b = x[dy] / r;
  var c = x[dz] / r;
  var tmp = Math.sqrt(a * a + c * c);
  if (theta !== 0) {
    var sintheta = Math.sin(theta);
    var costheta = Math.cos(theta);
    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }
    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }
    if (z) {
      z[dx] = -a * b / tmp;
      z[dy] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector$1(a, b, projection) {
  var bSquared = dot(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }
  var scale2 = dot(a, b) / bSquared;
  for (var i = 0; i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale2);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  var bSquared = dot2D(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }
  var scale2 = dot2D(a, b) / bSquared;
  for (var i = 0; i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale2);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  var crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function gaussianAmplitude(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  out_2x2[0] = x[0] * y[0];
  out_2x2[1] = x[0] * y[1];
  out_2x2[2] = x[1] * y[0];
  out_2x2[3] = x[1] * y[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  var den = norm2D(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  var maxI;
  var tmp;
  var largest;
  var scale2 = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i * 3]);
    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
      largest = tmp;
    }
    scale2[i] = 1 / largest;
  }
  largest = scale2[0] * Math.abs(mat_3x3[0]);
  maxI = 0;
  if ((tmp = scale2[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale2[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale2[maxI] = scale2[0];
  }
  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0];
  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale2[1] * Math.abs(mat_3x3[4]);
  maxI = 1;
  if ((tmp = scale2[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale2[2] = scale2[1];
  }
  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4];
  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  var sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];
  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  var a1 = mat_3x3[0];
  var b1 = mat_3x3[1];
  var c1 = mat_3x3[2];
  var a2 = mat_3x3[3];
  var b2 = mat_3x3[4];
  var c2 = mat_3x3[5];
  var a3 = mat_3x3[6];
  var b3 = mat_3x3[7];
  var c3 = mat_3x3[8];
  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2);
  var det = a1 * d1 + b1 * d2 + c1 * d3;
  var v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  var v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  var v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  var x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  var y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  var z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  var copyA = _toConsumableArray(a_3x3);
  var copyB = _toConsumableArray(b_3x3);
  for (var i = 0; i < 3; i++) {
    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {
  if (colA !== rowB) {
    vtkErrorMacro$i("Number of columns of A must match number of rows of B.");
  }
  var copyA = _toConsumableArray(a);
  var copyB = _toConsumableArray(b);
  for (var i = 0; i < rowA; i++) {
    for (var j = 0; j < colB; j++) {
      out_rowXcol[i * colB + j] = 0;
      for (var k = 0; k < colA; k++) {
        out_rowXcol[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  var tmp;
  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp;
  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  var a1 = in_3x3[0];
  var b1 = in_3x3[1];
  var c1 = in_3x3[2];
  var a2 = in_3x3[3];
  var b2 = in_3x3[4];
  var c2 = in_3x3[5];
  var a3 = in_3x3[6];
  var b3 = in_3x3[7];
  var c3 = in_3x3[8];
  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2);
  var det = a1 * d1 + b1 * d2 + c1 * d3;
  if (det === 0) {
    vtkWarningMacro$6("Matrix has 0 determinant");
  }
  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d2 / det;
  outI_3x3[6] = d3 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e2 / det;
  outI_3x3[7] = e3 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f2 / det;
  outI_3x3[8] = f3 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}
function identity3x3(mat_3x3) {
  for (var i = 0; i < 3; i++) {
    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
    mat_3x3[i * 3 + i] = 1;
  }
}
function identity(n, mat) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      mat[i * n + j] = 0;
    }
    mat[i * n + i] = 1;
  }
  return mat;
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  var ww = quat_4[0] * quat_4[0];
  var wx = quat_4[0] * quat_4[1];
  var wy = quat_4[0] * quat_4[2];
  var wz = quat_4[0] * quat_4[3];
  var xx = quat_4[1] * quat_4[1];
  var yy = quat_4[2] * quat_4[2];
  var zz = quat_4[3] * quat_4[3];
  var xy = quat_4[1] * quat_4[2];
  var xz = quat_4[1] * quat_4[3];
  var yz = quat_4[2] * quat_4[3];
  var rr = xx + yy + zz;
  var f = 1 / (ww + rr);
  var s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0] = xx * f + s;
  mat_3x3[3] = (xy + wz) * f;
  mat_3x3[6] = (xz - wy) * f;
  mat_3x3[1] = (xy - wz) * f;
  mat_3x3[4] = yy * f + s;
  mat_3x3[7] = (yz + wx) * f;
  mat_3x3[2] = (xz + wy) * f;
  mat_3x3[5] = (yz - wx) * f;
  mat_3x3[8] = zz * f + s;
}
function areEquals(a, b) {
  var eps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-6;
  if (a.length !== b.length) {
    return false;
  }
  function isEqual2(element, index2) {
    return Math.abs(element - b[index2]) <= eps;
  }
  return a.every(isEqual2);
}
var areMatricesEqual = areEquals;
function roundNumber(num) {
  var digits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!"".concat(num).includes("e")) {
    return +"".concat(Math.round("".concat(num, "e+").concat(digits)), "e-").concat(digits);
  }
  var arr = "".concat(num).split("e");
  var sig = "";
  if (+arr[1] + digits > 0) {
    sig = "+";
  }
  return +"".concat(Math.round("".concat(+arr[0], "e").concat(sig).concat(+arr[1] + digits)), "e-").concat(digits);
}
function roundVector(vector) {
  var out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  var digits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  var i;
  var j;
  var k;
  var iq;
  var ip;
  var numPos;
  var tresh;
  var theta;
  var t;
  var tau;
  var sm;
  var s;
  var h;
  var g2;
  var c;
  var tmp;
  var b = createArray(n);
  var z = createArray(n);
  var vtkROTATE = function vtkROTATE2(aa, ii, jj) {
    g2 = aa[ii];
    h = aa[jj];
    aa[ii] = g2 - s * (h + g2 * tau);
    aa[jj] = h + s * (g2 - h * tau);
  };
  identity(n, v);
  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip + ip * n];
    z[ip] = 0;
  }
  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0;
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip * n + iq]);
      }
    }
    if (sm === 0) {
      break;
    }
    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0;
    }
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g2 = 100 * Math.abs(a[ip * n + iq]);
        if (i > 3 && Math.abs(w[ip]) + g2 === Math.abs(w[ip]) && Math.abs(w[iq]) + g2 === Math.abs(w[iq])) {
          a[ip * n + iq] = 0;
        } else if (Math.abs(a[ip * n + iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g2 === Math.abs(h)) {
            t = a[ip * n + iq] / h;
          } else {
            theta = 0.5 * h / a[ip * n + iq];
            t = 1 / (Math.abs(theta) + Math.sqrt(1 + theta * theta));
            if (theta < 0) {
              t = -t;
            }
          }
          c = 1 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1 + c);
          h = t * a[ip * n + iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip * n + iq] = 0;
          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j * n + ip, j * n + iq);
          }
          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip * n + j, j * n + iq);
          }
          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip * n + j, iq * n + j);
          }
          for (j = 0; j < n; j++) {
            vtkROTATE(v, j * n + ip, j * n + iq);
          }
        }
      }
    }
    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0;
    }
  }
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro$6("vtkMath::Jacobi: Error extracting eigenfunctions");
    return 0;
  }
  for (j = 0; j < n - 1; j++) {
    k = j;
    tmp = w[k];
    for (i = j + 1; i < n; i++) {
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < VTK_SMALL_NUMBER) {
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      swapColumnsMatrix_nxn(v, n, j, k);
    }
  }
  var ceil_half_n = (n >> 1) + (n & 1);
  for (numPos = 0, i = 0; i < n * n; i++) {
    if (v[i] >= 0) {
      numPos++;
    }
  }
  if (numPos < ceil_half_n) {
    for (i = 0; i < n; i++) {
      v[i * n + j] *= -1;
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  var tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];
  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  var eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var eigenvalues = [0, 0, 0, 0];
  var NTemp = [].concat(tmp);
  jacobiN(NTemp, 4, eigenvalues, eigenvectors);
  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  var ww = quat_1[0] * quat_2[0];
  var wx = quat_1[0] * quat_2[1];
  var wy = quat_1[0] * quat_2[2];
  var wz = quat_1[0] * quat_2[3];
  var xw = quat_1[1] * quat_2[0];
  var xx = quat_1[1] * quat_2[1];
  var xy = quat_1[1] * quat_2[2];
  var xz = quat_1[1] * quat_2[3];
  var yw = quat_1[2] * quat_2[0];
  var yx = quat_1[2] * quat_2[1];
  var yy = quat_1[2] * quat_2[2];
  var yz = quat_1[2] * quat_2[3];
  var zw = quat_1[3] * quat_2[0];
  var zx = quat_1[3] * quat_2[1];
  var zy = quat_1[3] * quat_2[2];
  var zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  for (var i = 0; i < 9; i++) {
    out_3x3[i] = a_3x3[i];
  }
  var scale2 = createArray(3);
  var index2 = createArray(3);
  var largest;
  for (var _i = 0; _i < 3; _i++) {
    var _x = Math.abs(out_3x3[_i * 3]);
    var _x2 = Math.abs(out_3x3[_i * 3 + 1]);
    var _x3 = Math.abs(out_3x3[_i * 3 + 2]);
    largest = _x2 > _x ? _x2 : _x;
    largest = _x3 > largest ? _x3 : largest;
    scale2[_i] = 1;
    if (largest !== 0) {
      scale2[_i] /= largest;
    }
  }
  var x1 = Math.abs(out_3x3[0]) * scale2[0];
  var x2 = Math.abs(out_3x3[3]) * scale2[1];
  var x3 = Math.abs(out_3x3[6]) * scale2[2];
  index2[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index2[0] = 1;
  }
  if (x3 >= largest) {
    index2[0] = 2;
  }
  if (index2[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[0], 0);
    scale2[index2[0]] = scale2[0];
  }
  var y2 = Math.abs(out_3x3[4]) * scale2[1];
  var y3 = Math.abs(out_3x3[7]) * scale2[2];
  index2[1] = 1;
  largest = y2;
  if (y3 >= largest) {
    index2[1] = 2;
    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  }
  index2[2] = 2;
  var flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (var _i2 = 0; _i2 < 9; _i2++) {
      out_3x3[_i2] = -out_3x3[_i2];
    }
  }
  var quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);
  if (flip) {
    for (var _i3 = 0; _i3 < 9; _i3++) {
      out_3x3[_i3] = -out_3x3[_i3];
    }
  }
  if (index2[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[1], 1);
  }
  if (index2[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  var i;
  var j;
  var k;
  var maxI;
  var tmp;
  var maxVal;
  var copyA = _toConsumableArray(a_3x3);
  jacobiN(copyA, 3, w_3, v_3x3);
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }
  transpose3x3(v_3x3, v_3x3);
  for (i = 0; i < 3; i++) {
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      maxVal = Math.abs(v_3x3[i * 3]);
      maxI = 0;
      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
      }
      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      }
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j * 3] = 0;
      v_3x3[j * 3 + 1] = 0;
      v_3x3[j * 3 + 2] = 0;
      v_3x3[j * 3 + j] = 1;
      var vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
      normalize(vectTmp1);
      var vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
      for (var t = 0; t < 3; t++) {
        v_3x3[k * 3 + t] = vectTmp1[t];
        v_3x3[j * 3 + t] = vectTmp2[t];
      }
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }
  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;
  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  if (maxI !== 0) {
    var eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  }
  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    var _eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = _eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  }
  for (i = 0; i < 2; i++) {
    if (v_3x3[i * 3 + i] < 0) {
      v_3x3[i * 3] = -v_3x3[i * 3];
      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
    }
  }
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  }
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  var i;
  var B = _toConsumableArray(a_3x3);
  var d = determinant3x3(B);
  if (d < 0) {
    for (i = 0; i < 9; i++) {
      B[i] = -B[i];
    }
  }
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}
function luFactorLinearSystem(A, index2, size2) {
  var i;
  var j;
  var k;
  var largest;
  var maxI = 0;
  var sum;
  var temp1;
  var temp2;
  var scale2 = createArray(size2);
  for (i = 0; i < size2; i++) {
    for (largest = 0, j = 0; j < size2; j++) {
      if ((temp2 = Math.abs(A[i * size2 + j])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0) {
      vtkWarningMacro$6("Unable to factor linear system");
      return 0;
    }
    scale2[i] = 1 / largest;
  }
  for (j = 0; j < size2; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i * size2 + j];
      for (k = 0; k < i; k++) {
        sum -= A[i * size2 + k] * A[k * size2 + j];
      }
      A[i * size2 + j] = sum;
    }
    for (largest = 0, i = j; i < size2; i++) {
      sum = A[i * size2 + j];
      for (k = 0; k < j; k++) {
        sum -= A[i * size2 + k] * A[k * size2 + j];
      }
      A[i * size2 + j] = sum;
      if ((temp1 = scale2[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    if (j !== maxI) {
      for (k = 0; k < size2; k++) {
        temp1 = A[maxI * size2 + k];
        A[maxI * size2 + k] = A[j * size2 + k];
        A[j * size2 + k] = temp1;
      }
      scale2[maxI] = scale2[j];
    }
    index2[j] = maxI;
    if (Math.abs(A[j * size2 + j]) <= VTK_SMALL_NUMBER) {
      vtkWarningMacro$6("Unable to factor linear system");
      return 0;
    }
    if (j !== size2 - 1) {
      temp1 = 1 / A[j * size2 + j];
      for (i = j + 1; i < size2; i++) {
        A[i * size2 + j] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A, index2, x, size2) {
  var i;
  var j;
  var ii;
  var idx;
  var sum;
  for (ii = -1, i = 0; i < size2; i++) {
    idx = index2[i];
    sum = x[idx];
    x[idx] = x[i];
    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i * size2 + j] * x[j];
      }
    } else if (sum !== 0) {
      ii = i;
    }
    x[i] = sum;
  }
  for (i = size2 - 1; i >= 0; i--) {
    sum = x[i];
    for (j = i + 1; j < size2; j++) {
      sum -= A[i * size2 + j] * x[j];
    }
    x[i] = sum / A[i * size2 + i];
  }
}
function solveLinearSystem(A, x, size2) {
  if (size2 === 2) {
    var y = createArray(2);
    var det = determinant2x2(A[0], A[1], A[2], A[3]);
    if (det === 0) {
      return 0;
    }
    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }
  if (size2 === 1) {
    if (A[0] === 0) {
      return 0;
    }
    x[0] /= A[0];
    return 1;
  }
  var index2 = createArray(size2);
  if (luFactorLinearSystem(A, index2, size2) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index2, x, size2);
  return 1;
}
function invertMatrix(A, AI, size2) {
  var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var column = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var tmp1Size = index2 || createArray(size2);
  var tmp2Size = column || createArray(size2);
  if (luFactorLinearSystem(A, tmp1Size, size2) === 0) {
    return 0;
  }
  for (var j = 0; j < size2; j++) {
    for (var i = 0; i < size2; i++) {
      tmp2Size[i] = 0;
    }
    tmp2Size[j] = 1;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size2);
    for (var _i4 = 0; _i4 < size2; _i4++) {
      AI[_i4 * size2 + j] = tmp2Size[_i4];
    }
  }
  return 1;
}
function estimateMatrixCondition(A, size2) {
  var minValue = +Number.MAX_VALUE;
  var maxValue = -Number.MAX_VALUE;
  for (var i = 0; i < size2; i++) {
    for (var j = i; j < size2; j++) {
      if (Math.abs(A[i * size2 + j]) > maxValue) {
        maxValue = Math.abs(A[i * size2 + j]);
      }
    }
  }
  for (var _i5 = 0; _i5 < size2; _i5++) {
    if (Math.abs(A[_i5 * size2 + _i5]) < minValue) {
      minValue = Math.abs(A[_i5 * size2 + _i5]);
    }
  }
  if (minValue === 0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  if (numberOfSamples < xOrder) {
    vtkWarningMacro$6("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  var i;
  var j;
  var k;
  var XXt = createArray(xOrder * xOrder);
  var eigenvals = createArray(xOrder);
  var eigenvecs = createArray(xOrder * xOrder);
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
    }
  }
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);
  for (i = 0; i < xOrder; i++) {
    mt[i] = eigenvecs[i * xOrder + xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  var checkHomogeneous = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro$6("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  var homogenFlags = createArray(yOrder);
  var allHomogeneous = 1;
  var hmt;
  var homogRC = 0;
  var i;
  var j;
  var k;
  var someHomogeneous = 0;
  if (checkHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i * yOrder + j]) > VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro$6("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()");
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }
  if (someHomogeneous) {
    hmt = createArray(xOrder);
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }
  var XXt = createArray(xOrder * xOrder);
  var XXtI = createArray(xOrder * xOrder);
  var XYt = createArray(xOrder * yOrder);
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
      for (j = 0; j < yOrder; j++) {
        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
      }
    }
  }
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  var successFlag = invertMatrix(XXt, XXtI, xOrder);
  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i * yOrder + j] = 0;
        for (k = 0; k < xOrder; k++) {
          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
        }
      }
    }
  }
  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        for (i = 0; i < xOrder; i++) {
          mt[i * yOrder + j] = hmt[i * yOrder];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  var outFloatArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  var h;
  var s;
  var _rgb = _slicedToArray(rgb, 3), r = _rgb[0], g2 = _rgb[1], b = _rgb[2];
  var onethird = 1 / 3;
  var onesixth = 1 / 6;
  var twothird = 2 / 3;
  var cmax = r;
  var cmin = r;
  if (g2 > cmax) {
    cmax = g2;
  } else if (g2 < cmin) {
    cmin = g2;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  var v = cmax;
  if (v > 0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g2 - b) / (cmax - cmin);
    } else if (g2 === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g2) / (cmax - cmin);
    }
    if (h < 0) {
      h += 1;
    }
  } else {
    h = 0;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  var _hsv = _slicedToArray(hsv, 3), h = _hsv[0], s = _hsv[1], v = _hsv[2];
  var onethird = 1 / 3;
  var onesixth = 1 / 6;
  var twothird = 2 / 3;
  var fivesixth = 5 / 6;
  var r;
  var g2;
  var b;
  if (h > onesixth && h <= onethird) {
    g2 = 1;
    r = (onethird - h) / onesixth;
    b = 0;
  } else if (h > onethird && h <= 0.5) {
    g2 = 1;
    b = (h - onethird) / onesixth;
    r = 0;
  } else if (h > 0.5 && h <= twothird) {
    b = 1;
    g2 = (twothird - h) / onesixth;
    r = 0;
  } else if (h > twothird && h <= fivesixth) {
    b = 1;
    r = (h - twothird) / onesixth;
    g2 = 0;
  } else if (h > fivesixth && h <= 1) {
    r = 1;
    b = (1 - h) / onesixth;
    g2 = 0;
  } else {
    r = 1;
    g2 = h / onesixth;
    b = 0;
  }
  r = s * r + (1 - s);
  g2 = s * g2 + (1 - s);
  b = s * b + (1 - s);
  r *= v;
  g2 *= v;
  b *= v;
  rgb[0] = r;
  rgb[1] = g2;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  var _lab = _slicedToArray(lab, 3), L = _lab[0], a = _lab[1], b = _lab[2];
  var var_Y = (L + 16) / 116;
  var var_X = a / 500 + var_Y;
  var var_Z = var_Y - b / 200;
  if (Math.pow(var_Y, 3) > 8856e-6) {
    var_Y = Math.pow(var_Y, 3);
  } else {
    var_Y = (var_Y - 16 / 116) / 7.787;
  }
  if (Math.pow(var_X, 3) > 8856e-6) {
    var_X = Math.pow(var_X, 3);
  } else {
    var_X = (var_X - 16 / 116) / 7.787;
  }
  if (Math.pow(var_Z, 3) > 8856e-6) {
    var_Z = Math.pow(var_Z, 3);
  } else {
    var_Z = (var_Z - 16 / 116) / 7.787;
  }
  var ref_X = 0.9505;
  var ref_Y = 1;
  var ref_Z = 1.089;
  xyz[0] = ref_X * var_X;
  xyz[1] = ref_Y * var_Y;
  xyz[2] = ref_Z * var_Z;
}
function xyz2lab(xyz, lab) {
  var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
  var ref_X = 0.9505;
  var ref_Y = 1;
  var ref_Z = 1.089;
  var var_X = x / ref_X;
  var var_Y = y / ref_Y;
  var var_Z = z / ref_Z;
  if (var_X > 8856e-6)
    var_X = Math.pow(var_X, 1 / 3);
  else
    var_X = 7.787 * var_X + 16 / 116;
  if (var_Y > 8856e-6)
    var_Y = Math.pow(var_Y, 1 / 3);
  else
    var_Y = 7.787 * var_Y + 16 / 116;
  if (var_Z > 8856e-6)
    var_Z = Math.pow(var_Z, 1 / 3);
  else
    var_Z = 7.787 * var_Z + 16 / 116;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  var _xyz2 = _slicedToArray(xyz, 3), x = _xyz2[0], y = _xyz2[1], z = _xyz2[2];
  var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  var g2 = x * -0.9689 + y * 1.8758 + z * 0.0415;
  var b = x * 0.0557 + y * -0.204 + z * 1.057;
  if (r > 31308e-7)
    r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
  else
    r *= 12.92;
  if (g2 > 31308e-7)
    g2 = 1.055 * Math.pow(g2, 1 / 2.4) - 0.055;
  else
    g2 *= 12.92;
  if (b > 31308e-7)
    b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
  else
    b *= 12.92;
  var maxVal = r;
  if (maxVal < g2)
    maxVal = g2;
  if (maxVal < b)
    maxVal = b;
  if (maxVal > 1) {
    r /= maxVal;
    g2 /= maxVal;
    b /= maxVal;
  }
  if (r < 0)
    r = 0;
  if (g2 < 0)
    g2 = 0;
  if (b < 0)
    b = 0;
  rgb[0] = r;
  rgb[1] = g2;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  var _rgb2 = _slicedToArray(rgb, 3), r = _rgb2[0], g2 = _rgb2[1], b = _rgb2[2];
  if (r > 0.04045)
    r = Math.pow((r + 0.055) / 1.055, 2.4);
  else
    r /= 12.92;
  if (g2 > 0.04045)
    g2 = Math.pow((g2 + 0.055) / 1.055, 2.4);
  else
    g2 /= 12.92;
  if (b > 0.04045)
    b = Math.pow((b + 0.055) / 1.055, 2.4);
  else
    b /= 12.92;
  xyz[0] = r * 0.4124 + g2 * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g2 * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g2 * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  var xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  var xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1;
  bounds[1] = -1;
  bounds[2] = 1;
  bounds[3] = -1;
  bounds[4] = 1;
  bounds[5] = -1;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0);
}
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  var out = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  var result = 0;
  if (range[0] !== range[1]) {
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
var getScalarTypeFittingRange = notImplemented$2("GetScalarTypeFittingRange");
var getAdjustedScalarRange = notImplemented$2("GetAdjustedScalarRange");
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (var i = 0; i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (var i = 0; i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (var i = 0; i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p2, p3, center) {
  var v21 = createArray(3);
  var v32 = createArray(3);
  var v13 = createArray(3);
  var v12 = createArray(3);
  var v23 = createArray(3);
  var v31 = createArray(3);
  for (var i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }
  var norm12 = norm(v12);
  var norm23 = norm(v23);
  var norm13 = norm(v13);
  var crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  var normCross = norm(crossv21v32);
  var radius = norm12 * norm23 * norm13 / (2 * normCross);
  var normCross22 = 2 * normCross * normCross;
  var alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  var beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  var gamma = norm12 * norm12 * dot(v13, v23) / normCross22;
  for (var _i6 = 0; _i6 < 3; ++_i6) {
    center[_i6] = alpha * p1[_i6] + beta * p2[_i6] + gamma * p3[_i6];
  }
  return radius;
}
var inf = Infinity;
var negInf = -Infinity;
var isInf = function isInf2(value) {
  return !Number.isFinite(value);
};
var isFinite$1 = Number.isFinite, isNaN$1 = Number.isNaN;
var isNan = isNaN$1;
function createUninitializedBounds() {
  return [].concat([
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE
  ]);
}
function getMajorAxisIndex(vector) {
  var maxValue = -1;
  var axisIndex = -1;
  for (var i = 0; i < vector.length; i++) {
    var value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }
  return axisIndex;
}
function floatToHex2(value) {
  var integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return "0".concat(integer.toString(16));
}
function floatRGB2HexCode(rgbArray) {
  var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#";
  return "".concat(prefix).concat(rgbArray.map(floatToHex2).join(""));
}
function floatToChar(f) {
  return Math.round(f * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return "rgb(".concat(rgbArray.map(floatToChar).join(", "), ")");
  }
  return "rgba(".concat(floatToChar(rgbArray[0] || 0), ", ").concat(floatToChar(rgbArray[1] || 0), ", ").concat(floatToChar(rgbArray[2] || 0), ", ").concat(rgbArray[3] || 0, ")");
}
var vtkMath = {
  Pi,
  radiansFromDegrees,
  degreesFromRadians,
  round,
  floor,
  ceil,
  ceilLog2,
  min,
  max,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random,
  gaussian,
  add,
  subtract,
  multiplyScalar,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot,
  outer,
  cross,
  norm,
  normalize,
  perpendiculars,
  projectVector: projectVector$1,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  identity,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  roundNumber,
  roundVector,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN$1,
  isNaN: isNaN$1,
  isFinite: isFinite$1,
  createUninitializedBounds,
  getMajorAxisIndex,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA
};
var NoOp = function NoOp2(v) {
  return v;
};
var IDENTITY = identity$1(new Float64Array(16));
var EPSILON$4 = 1e-6;
var Transform2 = /* @__PURE__ */ function() {
  function Transform3() {
    var useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck(this, Transform3);
    this.matrix = identity$1(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? toRadian : NoOp;
  }
  _createClass(Transform3, [{
    key: "rotateFromDirections",
    value: function rotateFromDirections(originDirection, targetDirection) {
      var src2 = new Float64Array(3);
      var dst = new Float64Array(3);
      var transf = new Float64Array(16);
      set$1(src2, originDirection[0], originDirection[1], originDirection[2]);
      set$1(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
      normalize$4(src2, src2);
      normalize$4(dst, dst);
      var cosAlpha = dot$1(src2, dst);
      if (cosAlpha >= 1) {
        return this;
      }
      cross$1(this.tmp, src2, dst);
      if (length(this.tmp) < EPSILON$4) {
        cross$1(this.tmp, [1, 0, 0], originDirection);
        if (length(this.tmp) < EPSILON$4) {
          cross$1(this.tmp, [0, 1, 0], originDirection);
        }
      }
      fromRotation(transf, Math.acos(cosAlpha), this.tmp);
      multiply$2(this.matrix, this.matrix, transf);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate$1(angle2, axis) {
      set$1.apply(vec3, [this.tmp].concat(_toConsumableArray(axis)));
      normalize$4(this.tmp, this.tmp);
      rotate(this.matrix, this.matrix, this.angleConv(angle2), this.tmp);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX2(angle2) {
      rotateX$1(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY2(angle2) {
      rotateY$1(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ2(angle2) {
      rotateZ$1(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
  }, {
    key: "translate",
    value: function translate$1(x, y, z) {
      set$1(this.tmp, x, y, z);
      translate(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "scale",
    value: function scale2(sx, sy, sz) {
      set$1(this.tmp, sx, sy, sz);
      scale$2(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply2(mat4x4) {
      multiply$2(this.matrix, this.matrix, mat4x4);
      return this;
    }
  }, {
    key: "identity",
    value: function identity2() {
      identity$1(this.matrix);
      return this;
    }
  }, {
    key: "apply",
    value: function apply(typedArray) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (areMatricesEqual(IDENTITY, this.matrix)) {
        return this;
      }
      var size2 = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
      for (var i = offset; i < size2; i += 3) {
        set$1(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
        transformMat4$1(this.tmp, this.tmp, this.matrix);
        typedArray[i] = this.tmp[0];
        typedArray[i + 1] = this.tmp[1];
        typedArray[i + 2] = this.tmp[2];
      }
      return this;
    }
  }, {
    key: "getMatrix",
    value: function getMatrix() {
      return this.matrix;
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(mat4x4) {
      if (!!mat4x4 && mat4x4.length === 16) {
        copy$1(this.matrix, mat4x4);
      }
      return this;
    }
  }]);
  return Transform3;
}();
function buildFromDegree() {
  return new Transform2(true);
}
function buildFromRadian() {
  return new Transform2(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};
function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {
  const corners = getVolumeActorCorners(volumeActor);
  const transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(viewPlaneNormal, [1, 0, 0]);
  corners.forEach((pt) => transform.apply(pt));
  const transformedFocalPoint = [...focalPoint];
  transform.apply(transformedFocalPoint);
  const currentSlice = transformedFocalPoint[0];
  let minX = Infinity;
  let maxX = -Infinity;
  for (let i = 0; i < 8; i++) {
    const x = corners[i][0];
    if (x > maxX) {
      maxX = x;
    }
    if (x < minX) {
      minX = x;
    }
  }
  return {
    min: minX,
    max: maxX,
    current: currentSlice,
    actor: volumeActor,
    viewPlaneNormal,
    focalPoint
  };
}
function getImageSliceDataForVolumeViewport(viewport) {
  const camera = viewport.getCamera();
  const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);
  if (!imageVolume) {
    return;
  }
  const { viewPlaneNormal, focalPoint } = camera;
  const actorEntry = viewport.getActors().find((a) => a.referenceId === imageVolume.volumeId || a.uid === imageVolume.volumeId);
  if (!actorEntry) {
    console.warn("No actor found for with actorUID of", imageVolume.volumeId);
  }
  const volumeActor = actorEntry.actor;
  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);
  const { min: min2, max: max2, current } = sliceRange;
  const numberOfSlices = Math.round((max2 - min2) / spacingInNormalDirection) + 1;
  let imageIndex = (current - min2) / (max2 - min2) * numberOfSlices;
  imageIndex = Math.floor(imageIndex);
  if (imageIndex > numberOfSlices - 1) {
    imageIndex = numberOfSlices - 1;
  } else if (imageIndex < 0) {
    imageIndex = 0;
  }
  return {
    numberOfSlices,
    imageIndex
  };
}
function isImageActor(actor) {
  if (actor.isA("vtkVolume")) {
    return true;
  }
  if (actor.isA("vtkImageSlice")) {
    return true;
  }
  return false;
}
function getViewportsWithImageURI(imageURI, renderingEngineId) {
  let renderingEngines;
  if (renderingEngineId) {
    renderingEngines = [getRenderingEngine(renderingEngineId)];
  } else {
    renderingEngines = getRenderingEngines();
  }
  const viewports = [];
  renderingEngines.forEach((renderingEngine) => {
    const stackViewports = renderingEngine.getStackViewports();
    const filteredStackViewports = stackViewports.filter((viewport) => viewport.hasImageURI(imageURI));
    const volumeViewports = renderingEngine.getVolumeViewports();
    const filteredVolumeViewports = volumeViewports.filter((viewport) => viewport.hasImageURI(imageURI));
    viewports.push(...filteredStackViewports, ...filteredVolumeViewports);
  });
  return viewports;
}
function hasNaNValues(input) {
  if (Array.isArray(input)) {
    return input.some((value) => Number.isNaN(value));
  }
  return Number.isNaN(input);
}
var DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var VtkDataTypes$3 = {
  VOID: "",
  CHAR: "Int8Array",
  SIGNED_CHAR: "Int8Array",
  UNSIGNED_CHAR: "Uint8Array",
  SHORT: "Int16Array",
  UNSIGNED_SHORT: "Uint16Array",
  INT: "Int32Array",
  UNSIGNED_INT: "Uint32Array",
  FLOAT: "Float32Array",
  DOUBLE: "Float64Array"
};
var DefaultDataType$1 = VtkDataTypes$3.FLOAT;
var Constants$c = {
  DefaultDataType: DefaultDataType$1,
  DataTypeByteSize,
  VtkDataTypes: VtkDataTypes$3
};
function ownKeys$i(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$i(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var vtkErrorMacro$h = vtkErrorMacro$j;
var DefaultDataType = Constants$c.DefaultDataType;
function fastComputeRange(arr, offset, numberOfComponents) {
  var len2 = arr.length;
  var min2;
  var max2;
  var x;
  var i;
  if (len2 === 0) {
    return {
      min: Number.MAX_VALUE,
      max: -Number.MAX_VALUE
    };
  }
  min2 = arr[offset];
  max2 = min2;
  for (i = offset; i < len2; i += numberOfComponents) {
    x = arr[i];
    if (x < min2) {
      min2 = x;
    } else if (x > max2) {
      max2 = x;
    }
  }
  return {
    min: min2,
    max: max2
  };
}
function createRangeHelper() {
  var min2 = Number.MAX_VALUE;
  var max2 = -Number.MAX_VALUE;
  var count = 0;
  var sum = 0;
  return {
    add: function add2(value) {
      if (min2 > value) {
        min2 = value;
      }
      if (max2 < value) {
        max2 = value;
      }
      count++;
      sum += value;
    },
    get: function get2() {
      return {
        min: min2,
        max: max2,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange: function getRange() {
      return {
        min: min2,
        max: max2
      };
    }
  };
}
function computeRange(values) {
  var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var numberOfComponents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    var size2 = values.length;
    var numberOfValues = size2 / numberOfComponents;
    var data = new Float64Array(numberOfValues);
    for (var i = 0, j = 0; i < numberOfValues; ++i) {
      var _i;
      for (var nextJ = j + numberOfComponents; j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      _i = i, data[_i] = Math.pow(data[_i], 0.5);
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  var size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var ranges = rangeArray || [];
  while (ranges.length <= size2) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  var numComps = normArray.getNumberOfComponents();
  var maxNorm = 0;
  var tuple = new Array(numComps);
  for (var i = 0; i < normArray.getNumberOfTuples(); ++i) {
    normArray.getTuple(i, tuple);
    var norm$1 = norm(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}
var STATIC$5 = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};
function vtkDataArray(publicAPI, model) {
  model.classHierarchy.push("vtkDataArray");
  function dataChange() {
    model.ranges = null;
    publicAPI.modified();
  }
  function resize2(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    var numComps = publicAPI.getNumberOfComponents();
    var curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === curNumTuples) {
      return true;
    }
    if (requestedNumTuples > curNumTuples) {
      var oldValues = model.values;
      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }
    model.size = requestedNumTuples * numComps;
    dataChange();
    return true;
  }
  publicAPI.initialize = function() {
    resize2(0);
  };
  publicAPI.getElementComponentSize = function() {
    return model.values.BYTES_PER_ELEMENT;
  };
  publicAPI.getComponent = function(tupleIdx) {
    var compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = function(tupleIdx, compIdx, value) {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      dataChange();
    }
  };
  publicAPI.getValue = function(valueIdx) {
    var idx = valueIdx / model.numberOfComponents;
    var comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = function(valueIdx, value) {
    var idx = valueIdx / model.numberOfComponents;
    var comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = function() {
    return model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  };
  publicAPI.getRange = function() {
    var componentIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
    var rangeIdx = componentIndex < 0 ? model.numberOfComponents : componentIndex;
    var range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = function(rangeValue, componentIndex) {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    var range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setTuple = function(idx, tuple) {
    var offset = idx * model.numberOfComponents;
    for (var i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.setTuples = function(idx, tuples) {
    var i = idx * model.numberOfComponents;
    var last = Math.min(tuples.length, model.size - i);
    for (var j = 0; j < last; ) {
      model.values[i++] = tuples[j++];
    }
  };
  publicAPI.insertTuple = function(idx, tuple) {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize2(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = function(idx, tuples) {
    var end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize2(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = function(tuple) {
    var idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = function(tuples) {
    var idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.getTuple = function(idx) {
    var tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var numberOfComponents = model.numberOfComponents || 1;
    var offset = idx * numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset + 3];
      case 3:
        tupleToFill[2] = model.values[offset + 2];
      case 2:
        tupleToFill[1] = model.values[offset + 1];
      case 1:
        tupleToFill[0] = model.values[offset];
        break;
      default:
        for (var i = numberOfComponents - 1; i >= 0; --i) {
          tupleToFill[i] = model.values[offset + i];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = function(fromId, toId) {
    var from = (fromId !== null && fromId !== void 0 ? fromId : 0) * model.numberOfComponents;
    var to = (toId !== null && toId !== void 0 ? toId : publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    var arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = function() {
    return model.numberOfComponents;
  };
  publicAPI.getNumberOfValues = function() {
    return model.size;
  };
  publicAPI.getNumberOfTuples = function() {
    return model.size / model.numberOfComponents;
  };
  publicAPI.getDataType = function() {
    return model.dataType;
  };
  publicAPI.newClone = function() {
    return newInstance$W({
      empty: true,
      name: model.name,
      dataType: model.dataType,
      numberOfComponents: model.numberOfComponents
    });
  };
  publicAPI.getName = function() {
    if (!model.name) {
      publicAPI.modified();
      model.name = "vtkDataArray".concat(publicAPI.getMTime());
    }
    return model.name;
  };
  publicAPI.setData = function(typedArray, numberOfComponents) {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    dataChange();
  };
  publicAPI.getState = function() {
    if (model.deleted) {
      return null;
    }
    var jsonArchive = _objectSpread$i(_objectSpread$i({}, model), {}, {
      vtkClass: publicAPI.getClassName()
    });
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;
    Object.keys(jsonArchive).forEach(function(keyName) {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });
    var sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(function(name) {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.deepCopy = function(other) {
    publicAPI.shallowCopy(other);
    publicAPI.setData(other.getData().slice());
  };
  publicAPI.interpolateTuple = function(idx, source1, source1Idx, source2, source2Idx, t) {
    var numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro$h("numberOfComponents must match");
    }
    var tuple1 = source1.getTuple(source1Idx);
    var tuple2 = source2.getTuple(source2Idx);
    var out = [];
    out.length = numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
        break;
      default:
        for (var i = 0; i < numberOfComponents; i++) {
          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}
var DEFAULT_VALUES$Y = {
  name: "",
  numberOfComponents: 1,
  dataType: DefaultDataType,
  rangeTuple: [0, 0]
};
function extend$Z(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$Y, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = newTypedArray(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = newTypedArrayFrom(model.dataType, model.values);
  }
  if (model.values) {
    var _model$size;
    model.size = (_model$size = model.size) !== null && _model$size !== void 0 ? _model$size : model.values.length;
    model.dataType = getDataType(model.values);
  }
  obj(publicAPI, model);
  set(publicAPI, model, ["name", "numberOfComponents"]);
  vtkDataArray(publicAPI, model);
}
var newInstance$W = newInstance$X(extend$Z, "vtkDataArray");
var vtkDataArray$1 = _objectSpread$i(_objectSpread$i({
  newInstance: newInstance$W,
  extend: extend$Z
}, STATIC$5), Constants$c);
var VectorMode$1 = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
var ScalarMappingTarget$2 = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var vtkScalarsToColors$2 = {
  VectorMode: VectorMode$1,
  ScalarMappingTarget: ScalarMappingTarget$2
};
var ColorMode$1 = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
var ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
var GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants$b = {
  ColorMode: ColorMode$1,
  GetArray,
  ScalarMode
};
function ownKeys$h(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ScalarMappingTarget$1 = vtkScalarsToColors$2.ScalarMappingTarget, VectorMode = vtkScalarsToColors$2.VectorMode;
var VtkDataTypes$2 = vtkDataArray$1.VtkDataTypes;
var ColorMode = Constants$b.ColorMode;
var vtkErrorMacro$g = macro.vtkErrorMacro;
function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255 + 0.5);
}
function vtkScalarsToColors(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = function() {
    return publicAPI.setVectorMode(VectorMode.MAGNITUDE);
  };
  publicAPI.setVectorModeToComponent = function() {
    return publicAPI.setVectorMode(VectorMode.COMPONENT);
  };
  publicAPI.setVectorModeToRGBColors = function() {
    return publicAPI.setVectorMode(VectorMode.RGBCOLORS);
  };
  publicAPI.build = function() {
  };
  publicAPI.isOpaque = function() {
    return true;
  };
  publicAPI.setAnnotations = function(values, annotations) {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro$g("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      var num = annotations.length;
      for (var i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = function(value, annotation) {
    var i = publicAPI.checkForAnnotatedValue(value);
    var modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };
  publicAPI.getNumberOfAnnotatedValues = function() {
    return model.annotationArray.length;
  };
  publicAPI.getAnnotatedValue = function(idx) {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = function(idx) {
    if (model.annotationArray[idx] === void 0) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = function(val) {
    return model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  };
  publicAPI.removeAnnotation = function(value) {
    var i = publicAPI.checkForAnnotatedValue(value);
    var needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = function() {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = function(val, rgba) {
    if (model.indexedLookup) {
      var i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = function(value) {
    return publicAPI.getAnnotatedValueIndexInternal(value);
  };
  publicAPI.getAnnotatedValueIndexInternal = function(value) {
    if (model.annotatedValueMap[value] !== void 0) {
      var na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = function(val, rgba) {
    rgba[0] = 0;
    rgba[1] = 0;
    rgba[2] = 0;
    rgba[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = function() {
    model.annotatedValueMap = [];
    var na = model.annotationArray.length;
    for (var i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };
  publicAPI.mapScalars = function(scalars, colorMode, componentIn) {
    var numberOfComponents = scalars.getNumberOfComponents();
    var newColors = null;
    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes$2.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      var newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes$2.UNSIGNED_CHAR
      };
      var s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      var component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget$1.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget$1.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = function(input, output, compsToUse) {
    var length2 = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    for (var i = 0; i < length2; i++) {
      var sum = 0;
      for (var j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };
  publicAPI.mapVectorsThroughTable = function(input, output, outputFormat, vectorComponentIn, vectorSizeIn) {
    var vectorMode = publicAPI.getVectorMode();
    var vectorSize = vectorSizeIn;
    var vectorComponent = vectorComponentIn;
    var inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode.COMPONENT;
      }
    }
    var inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode.RGBCOLORS: {
        break;
      }
      case VectorMode.MAGNITUDE:
      default: {
        var magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = function(newColors, colors, alpha, convtFun) {
    var a = convtFun(alpha);
    var values = colors.getData();
    var newValues = newColors.getData();
    var size2 = values.length;
    var component = 0;
    var tuple = 1;
    var count = 0;
    for (var i = component; i < size2; i += tuple) {
      var l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = function(newColors, colors, alpha, convtFun) {
    var values = colors.getData();
    var newValues = newColors.getData();
    var size2 = values.length;
    var component = 0;
    var tuple = 2;
    var count = 0;
    for (var i = component; i < size2; i += tuple) {
      var l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = function(newColors, colors, alpha, convtFun) {
    var a = floatColorToUChar(alpha);
    var values = colors.getData();
    var newValues = newColors.getData();
    var size2 = values.length;
    var component = 0;
    var tuple = 3;
    var count = 0;
    for (var i = component; i < size2; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = function(newColors, colors, alpha, convtFun) {
    var values = colors.getData();
    var newValues = newColors.getData();
    var size2 = values.length;
    var component = 0;
    var tuple = 4;
    var count = 0;
    for (var i = component; i < size2; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };
  publicAPI.convertToRGBA = function(colors, numComp, numTuples) {
    var alpha = model.alpha;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes$2.UNSIGNED_CHAR) {
      return colors;
    }
    var newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes$2.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    var convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes$2.FLOAT || colors.getDataType() === VtkDataTypes$2.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro$g("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = function() {
    return false;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    return 256 * 256 * 256;
  };
  publicAPI.setRange = function(min2, max2) {
    return publicAPI.setMappingRange(min2, max2);
  };
  publicAPI.getRange = function(min2, max2) {
    return publicAPI.getMappingRange();
  };
}
var DEFAULT_VALUES$X = {
  alpha: 1,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false
};
function extend$Y(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$X, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors(publicAPI, model);
}
var newInstance$V = macro.newInstance(extend$Y, "vtkScalarsToColors");
var vtkScalarsToColors$1 = _objectSpread$h({
  newInstance: newInstance$V,
  extend: extend$Y
}, vtkScalarsToColors$2);
var ColorSpace$1 = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
var Scale$1 = {
  LINEAR: 0,
  LOG10: 1
};
var Constants$a = {
  ColorSpace: ColorSpace$1,
  Scale: Scale$1
};
function ownKeys$g(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ColorSpace = Constants$a.ColorSpace, Scale = Constants$a.Scale;
var ScalarMappingTarget = vtkScalarsToColors$1.ScalarMappingTarget;
var vtkDebugMacro$7 = macro.vtkDebugMacro, vtkErrorMacro$f = macro.vtkErrorMacro, vtkWarningMacro$5 = macro.vtkWarningMacro;
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  var L = lab[0];
  var a = lab[1];
  var b = lab[2];
  var M = Math.sqrt(L * L + a * a + b * b);
  var s = M > 1e-3 ? Math.acos(L / M) : 0;
  var h = s > 1e-3 ? Math.atan2(b, a) : 0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  var M = msh[0];
  var s = msh[1];
  var h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    return msh[2];
  }
  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  var adiff = a1 - a2;
  if (adiff < 0) {
    adiff = -adiff;
  }
  while (adiff >= 2 * Math.PI) {
    adiff -= 2 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2 * Math.PI - adiff;
  }
  return adiff;
}
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  var lab1 = [];
  var lab2 = [];
  rgb2lab(rgb1, lab1);
  rgb2lab(rgb2, lab2);
  var msh1 = [];
  var msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);
  var localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    var Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0;
      msh2[2] = 0;
      localS *= 2;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0;
      msh1[2] = 0;
      localS = 2 * localS - 1;
    }
  }
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  var mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
  var labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  lab2rgb(labTmp, result);
}
function vtkColorTransferFunction(publicAPI, model) {
  model.classHierarchy.push("vtkColorTransferFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.addRGBPoint = function(x, r, g2, b) {
    return publicAPI.addRGBPointLong(x, r, g2, b, 0.5, 0);
  };
  publicAPI.addRGBPointLong = function(x, r, g2, b) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro$f("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro$f("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      r,
      g: g2,
      b,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.addHSVPoint = function(x, h, s, v) {
    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
  };
  publicAPI.addHSVPointLong = function(x, h, s, v) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    var rgb = [];
    var hsv = [h, s, v];
    hsv2rgb(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      var before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      var after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };
  publicAPI.sortAndUpdateRange = function() {
    var before = JSON.stringify(model.nodes);
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var after = JSON.stringify(model.nodes);
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };
  publicAPI.updateRange = function() {
    var oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    var size2 = model.nodes.length;
    if (size2) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size2 - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    var retVal = i;
    if (i >= model.nodes.length) {
      return -1;
    }
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.movePoint = function(oldX, newX) {
    if (oldX === newX) {
      return;
    }
    publicAPI.removePoint(newX);
    for (var i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addRGBSegment = function(x1, r1, g1, b1, x2, r2, g2, b2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0);
    publicAPI.modified();
  };
  publicAPI.addHSVSegment = function(x1, h1, s1, v1, x2, h2, s2, v2) {
    var hsv1 = [h1, s1, v1];
    var hsv2 = [h2, s2, v2];
    var rgb1 = [];
    var rgb2 = [];
    hsv2rgb(hsv1, rgb1);
    hsv2rgb(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };
  publicAPI.mapValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255 * rgb[0] + 0.5), Math.floor(255 * rgb[1] + 0.5), Math.floor(255 * rgb[2] + 0.5), 255];
  };
  publicAPI.getColor = function(x, rgb) {
    if (model.indexedLookup) {
      var numNodes = publicAPI.getSize();
      var idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        publicAPI.getNanColor(rgb);
      } else {
        var nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        rgb[0] = nodeVal.r;
        rgb[1] = nodeVal.g;
        rgb[2] = nodeVal.b;
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };
  publicAPI.getRedValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };
  publicAPI.getGreenValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };
  publicAPI.getBlueValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };
  publicAPI.getTable = function(xStart, xEnd, size2, table) {
    if (isNan(xStart) || isNan(xEnd)) {
      for (var i = 0; i < size2; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastR = 0;
    var lastG = 0;
    var lastB = 0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var rgb1 = [0, 0, 0];
    var rgb2 = [0, 0, 0];
    var midpoint = 0;
    var sharpness = 0;
    var tmpVec = [];
    var usingLogScale = model.scale === Scale.LOG10;
    if (usingLogScale) {
      usingLogScale = model.mappingRange[0] > 0;
    }
    var logStart = 0;
    var logEnd = 0;
    var logX = 0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }
    for (var _i = 0; _i < size2; _i++) {
      var tidx = 3 * _i;
      if (size2 > 1) {
        if (usingLogScale) {
          logX = logStart + _i / (size2 - 1) * (logEnd - logStart);
          x = Math.pow(10, logX);
        } else {
          x = xStart + _i / (size2 - 1) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = Math.pow(10, logX);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      if (model.discretize) {
        var range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          var numberOfValues = model.numberOfValues;
          var deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2;
          } else {
            var xn = (x - range[0]) / deltaRange;
            var discretizeIndex = floor(numberOfValues * xn);
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (x > model.mappingRange[1]) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
        }
      } else {
        var s = 0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }
        if (sharpness < 0.01) {
          if (model.colorSpace === ColorSpace.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace.HSV) {
            var hsv1 = [];
            var hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            var hsvTmp = [];
            hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0) {
              hsvTmp[0] += 1;
            }
            hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace.LAB) {
            var lab1 = [];
            var lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            var labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro$f("ColorSpace set to invalid value.", model.colorSpace);
          }
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = void 0;
        var t = void 0;
        if (model.colorSpace === ColorSpace.RGB) {
          for (var j = 0; j < 3; j++) {
            slope = rgb2[j] - rgb1[j];
            t = (1 - sharpness) * slope;
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace.HSV) {
          var _hsv = [];
          var _hsv2 = [];
          rgb2hsv(rgb1, _hsv);
          rgb2hsv(rgb2, _hsv2);
          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {
            if (_hsv[0] > _hsv2[0]) {
              _hsv[0] -= 1;
            } else {
              _hsv2[0] -= 1;
            }
          }
          var _hsvTmp = [];
          for (var _j = 0; _j < 3; _j++) {
            slope = _hsv2[_j] - _hsv[_j];
            t = (1 - sharpness) * slope;
            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;
            if (_j === 0 && _hsvTmp[_j] < 0) {
              _hsvTmp[_j] += 1;
            }
          }
          hsv2rgb(_hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace.LAB) {
          var _lab = [];
          var _lab2 = [];
          rgb2lab(rgb1, _lab);
          rgb2lab(rgb2, _lab2);
          var _labTmp = [];
          for (var _j2 = 0; _j2 < 3; _j2++) {
            slope = _lab2[_j2] - _lab[_j2];
            t = (1 - sharpness) * slope;
            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;
          }
          lab2rgb(_labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace.DIVERGING) {
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro$f("ColorSpace set to invalid value.");
        }
        for (var _j3 = 0; _j3 < 3; _j3++) {
          table[tidx + _j3] = table[tidx + _j3] < 0 ? 0 : table[tidx + _j3];
          table[tidx + _j3] = table[tidx + _j3] > 1 ? 1 : table[tidx + _j3];
        }
      }
    }
  };
  publicAPI.getUint8Table = function(xStart, xEnd, size2) {
    var withAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size2 && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro$f("Attempting to lookup a value with no points in the function");
      return model.table;
    }
    var nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size2 || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size2 * nbChannels);
      model.tableSize = size2;
      model.tableWithAlpha = withAlpha;
    }
    var tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size2, tmpTable);
    for (var i = 0; i < size2; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromTable = function(xStart, xEnd, size2, table) {
    var inc = 0;
    publicAPI.removeAllPoints();
    if (size2 > 1) {
      inc = (xEnd - xStart) / (size2 - 1);
    }
    for (var i = 0; i < size2; i++) {
      var node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.getNodeValue = function(index2, val) {
    if (index2 < 0 || index2 >= model.nodes.length) {
      vtkErrorMacro$f("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index2].x;
    val[1] = model.nodes[index2].r;
    val[2] = model.nodes[index2].g;
    val[3] = model.nodes[index2].b;
    val[4] = model.nodes[index2].midpoint;
    val[5] = model.nodes[index2].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index2, val) {
    if (index2 < 0 || index2 >= model.nodes.length) {
      vtkErrorMacro$f("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index2].x;
    model.nodes[index2].x = val[0];
    model.nodes[index2].r = val[1];
    model.nodes[index2].g = val[2];
    model.nodes[index2].b = val[3];
    model.nodes[index2].midpoint = val[4];
    model.nodes[index2].sharpness = val[5];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      return model.tableSize;
    }
    return 16777216;
  };
  publicAPI.getIndexedColor = function(idx, rgba) {
    var n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      var nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (var j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1;
      return;
    }
    publicAPI.getNanColor(rgba);
    rgba[3] = 1;
  };
  publicAPI.fillFromDataPointer = function(nb, ptr) {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (var i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };
  publicAPI.setMappingRange = function(min2, max2) {
    var range = [min2, max2];
    var originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro$f("attempt to set zero width color range");
      return;
    }
    var scale2 = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    var shift = range[0] - originalRange[0] * scale2;
    for (var i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale2 + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };
  publicAPI.adjustRange = function(range) {
    var functionRange = publicAPI.getRange();
    var rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    if (model.nodes.length < 2) {
      return -1;
    }
    var distance2 = Number.MAX_VALUE;
    for (var i = 0; i < model.nodes.length - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance2) {
        distance2 = currentDist;
      }
    }
    return distance2;
  };
  publicAPI.mapScalarsThroughTable = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro$7("Transfer Function Has No Points!");
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };
  publicAPI.mapData = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro$5("Transfer Function Has No Points!");
      return;
    }
    var alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
    var length2 = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    var rgb = [];
    if (outFormat === ScalarMappingTarget.RGBA) {
      for (var i = 0; i < length2; i++) {
        var x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget.RGB) {
      for (var _i2 = 0; _i2 < length2; _i2++) {
        var _x = inputV[_i2 * inIncr + inputOffset];
        publicAPI.getColor(_x, rgb);
        outputV[_i2 * 3] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE) {
      for (var _i3 = 0; _i3 < length2; _i3++) {
        var _x2 = inputV[_i3 * inIncr + inputOffset];
        publicAPI.getColor(_x2, rgb);
        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {
      for (var _i4 = 0; _i4 < length2; _i4++) {
        var _x3 = inputV[_i4 * inIncr + inputOffset];
        publicAPI.getColor(_x3, rgb);
        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[_i4 * 2 + 1] = alpha;
      }
    }
  };
  publicAPI.applyColorMap = function(colorMap) {
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === void 0) {
        vtkErrorMacro$f("ColorSpace ".concat(colorMap.ColorSpace, " not supported, using RGB instead"));
        model.colorSpace = ColorSpace.RGB;
      }
    }
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1);
      }
    }
    if (colorMap.RGBPoints) {
      var size2 = colorMap.RGBPoints.length;
      model.nodes = [];
      var midpoint = 0.5;
      var sharpness = 0;
      for (var i = 0; i < size2; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    publicAPI.sortAndUpdateRange();
  };
}
var DEFAULT_VALUES$W = {
  clamping: true,
  colorSpace: ColorSpace.RGB,
  hSVWrap: true,
  scale: Scale.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};
function extend$X(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$W, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0, 0, 1];
  model.belowRangeColor = [0, 0, 0, 1];
  model.aboveRangeColor = [1, 1, 1, 1];
  model.buildTime = {};
  macro.obj(model.buildTime);
  macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
  macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "colorSpace", "discretize", "numberOfValues"]);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkColorTransferFunction(publicAPI, model);
}
var newInstance$U = macro.newInstance(extend$X, "vtkColorTransferFunction");
var vtkColorTransferFunction$1 = _objectSpread$g({
  newInstance: newInstance$U,
  extend: extend$X
}, Constants$a);
var vtkErrorMacro$e = macro.vtkErrorMacro;
function vtkPiecewiseFunction(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.getType = function() {
    var value;
    var prevValue = 0;
    var functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (var i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              functionType = 1;
              break;
            case 2:
            default:
              functionType = 3;
              break;
          }
        } else {
          switch (functionType) {
            case 0:
            case 2:
              functionType = 2;
              break;
            case 1:
            default:
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return "Constant";
      case 1:
        return "NonDecreasing";
      case 2:
        return "NonIncreasing";
      case 3:
      default:
        return "Varied";
    }
  };
  publicAPI.getDataPointer = function() {
    var size2 = model.nodes.length;
    model.function = null;
    if (size2 > 0) {
      model.function = [];
      for (var i = 0; i < size2; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };
  publicAPI.getFirstNonZeroValue = function() {
    if (model.nodes.length === 0) {
      return 0;
    }
    var allZero = 1;
    var x = 0;
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0) {
        allZero = 0;
        break;
      }
    }
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };
  publicAPI.getNodeValue = function(index2, val) {
    var size2 = model.nodes.length;
    if (index2 < 0 || index2 >= size2) {
      vtkErrorMacro$e("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index2].x;
    val[1] = model.nodes[index2].y;
    val[2] = model.nodes[index2].midpoint;
    val[3] = model.nodes[index2].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index2, val) {
    var size2 = model.nodes.length;
    if (index2 < 0 || index2 >= size2) {
      vtkErrorMacro$e("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index2].x;
    model.nodes[index2].x = val[0];
    model.nodes[index2].y = val[1];
    model.nodes[index2].midpoint = val[2];
    model.nodes[index2].sharpness = val[3];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.addPoint = function(x, y) {
    return publicAPI.addPointLong(x, y, 0.5, 0);
  };
  publicAPI.addPointLong = function(x, y, midpoint, sharpness) {
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro$e("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro$e("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      y,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };
  publicAPI.sortAndUpdateRange = function() {
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };
  publicAPI.updateRange = function() {
    var oldRange = model.range.slice();
    var size2 = model.nodes.length;
    if (size2) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size2 - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i >= model.nodes.length) {
      return -1;
    }
    var retVal = i;
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addSegment = function(x1, y1, x2, y2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addPoint(x1, y1, 0.5, 0);
    publicAPI.addPoint(x2, y2, 0.5, 0);
  };
  publicAPI.getValue = function(x) {
    var table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };
  publicAPI.adjustRange = function(range) {
    if (range.length < 2) {
      return 0;
    }
    var functionRange = publicAPI.getRange();
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    var size2 = model.nodes.length;
    if (size2 < 2) {
      return -1;
    }
    var distance2 = model.nodes[1].x - model.nodes[0].x;
    for (var i = 0; i < size2 - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance2) {
        distance2 = currentDist;
      }
    }
    return distance2;
  };
  publicAPI.getTable = function(xStart, xEnd, size2, table) {
    var stride = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
    var i;
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastValue = 0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var y1 = 0;
    var y2 = 0;
    var midpoint = 0;
    var sharpness = 0;
    for (i = 0; i < size2; i++) {
      var tidx = stride * i;
      if (size2 > 1) {
        x = xStart + i / (size2 - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0;
      } else if (idx === 0) {
        table[tidx] = model.clamping ? model.nodes[0].y : 0;
      } else {
        var s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            table[tidx] = y2;
            continue;
          }
        }
        if (sharpness < 0.01) {
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = y2 - y1;
        var t = (1 - sharpness) * slope;
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;
        var min2 = y1 < y2 ? y1 : y2;
        var max2 = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min2 ? min2 : table[tidx];
        table[tidx] = table[tidx] > max2 ? max2 : table[tidx];
      }
    }
  };
}
var DEFAULT_VALUES$V = {
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};
function extend$W(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$V, initialValues);
  macro.obj(publicAPI, model);
  model.nodes = [];
  macro.setGet(publicAPI, model, ["allowDuplicateScalars", "clamping"]);
  macro.setArray(publicAPI, model, ["range"], 2);
  macro.getArray(publicAPI, model, ["range"]);
  vtkPiecewiseFunction(publicAPI, model);
}
var newInstance$T = macro.newInstance(extend$W, "vtkPiecewiseFunction");
var vtkPiecewiseFunction$1 = {
  newInstance: newInstance$T,
  extend: extend$W
};
function linePlaneIntersection(p0, p1, plane) {
  const [x0, y0, z0] = p0;
  const [x1, y1, z1] = p1;
  const [A, B, C, D] = plane;
  const a = x1 - x0;
  const b = y1 - y0;
  const c = z1 - z0;
  const t = -1 * (A * x0 + B * y0 + C * z0 - D) / (A * a + B * b + C * c);
  const X = a * t + x0;
  const Y = b * t + y0;
  const Z = c * t + z0;
  return [X, Y, Z];
}
function planeEquation(normal, point) {
  const [A, B, C] = normal;
  const D = A * point[0] + B * point[1] + C * point[2];
  return [A, B, C, D];
}
function threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {
  const [A1, B1, C1, D1] = firstPlane;
  const [A2, B2, C2, D2] = secondPlane;
  const [A3, B3, C3, D3] = thirdPlane;
  const m0 = fromValues$4(A1, A2, A3, B1, B2, B3, C1, C2, C3);
  const m1 = fromValues$4(D1, D2, D3, B1, B2, B3, C1, C2, C3);
  const m2 = fromValues$4(A1, A2, A3, D1, D2, D3, C1, C2, C3);
  const m3 = fromValues$4(A1, A2, A3, B1, B2, B3, D1, D2, D3);
  const x = determinant(m1) / determinant(m0);
  const y = determinant(m2) / determinant(m0);
  const z = determinant(m3) / determinant(m0);
  return [x, y, z];
}
function toWindowLevel(low, high) {
  const windowWidth = Math.abs(low - high);
  const windowCenter = low + windowWidth / 2;
  return { windowWidth, windowCenter };
}
function toLowHighRange(windowWidth, windowCenter) {
  const lower = windowCenter - windowWidth / 2;
  const upper = windowCenter + windowWidth / 2;
  return { lower, upper };
}
var Wrap$1 = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
var Filter$1 = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants$9 = {
  Wrap: Wrap$1,
  Filter: Filter$1
};
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
function toHalf(val) {
  floatView[0] = val;
  var x = int32View[0];
  var bits = x >> 16 & 32768;
  var m = x >> 12 & 2047;
  var e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e === 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  var s = (h & 32768) >> 15;
  var e = (h & 31744) >> 10;
  var f = h & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  }
  if (e === 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var HalfFloat = {
  fromHalf,
  toHalf
};
var vtkErrorMacro$d = macro.vtkErrorMacro;
var PASS_TYPES = ["Build", "Render"];
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  publicAPI.build = function(prepass) {
  };
  publicAPI.render = function(prepass) {
  };
  publicAPI.traverse = function(renderPass) {
    var passTraversal = renderPass.getTraverseOperation();
    var fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (var index2 = 0; index2 < model.children.length; index2++) {
      model.children[index2].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = function(renderPass, prepass) {
    var customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = function(dataObject) {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (var index2 = 0; index2 < model.children.length; ++index2) {
      var child = model.children[index2];
      var vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return void 0;
  };
  publicAPI.getFirstAncestorOfType = function(type) {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.addMissingNode = function(dobj) {
    if (!dobj) {
      return;
    }
    var result = model._renderableChildMap.get(dobj);
    if (result !== void 0) {
      result.setVisited(true);
    } else {
      var newNode = publicAPI.createViewNode(dobj);
      if (newNode) {
        newNode.setParent(publicAPI);
        newNode.setVisited(true);
        model._renderableChildMap.set(dobj, newNode);
        model.children.push(newNode);
      }
    }
  };
  publicAPI.addMissingNodes = function(dataObjs) {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (var index2 = 0; index2 < dataObjs.length; ++index2) {
      var dobj = dataObjs[index2];
      var result = model._renderableChildMap.get(dobj);
      if (result !== void 0) {
        result.setVisited(true);
      } else {
        var newNode = publicAPI.createViewNode(dobj);
        if (newNode) {
          newNode.setParent(publicAPI);
          newNode.setVisited(true);
          model._renderableChildMap.set(dobj, newNode);
          model.children.push(newNode);
        }
      }
    }
  };
  publicAPI.addMissingChildren = function(children) {
    if (!children || !children.length) {
      return;
    }
    for (var index2 = 0; index2 < children.length; ++index2) {
      var child = children[index2];
      var cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
      }
      child.setVisited(true);
    }
  };
  publicAPI.prepareNodes = function() {
    for (var index2 = 0; index2 < model.children.length; ++index2) {
      model.children[index2].setVisited(false);
    }
  };
  publicAPI.setVisited = function(val) {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = function() {
    var deleted = null;
    for (var index2 = 0; index2 < model.children.length; ++index2) {
      var child = model.children[index2];
      var visited = child.getVisited();
      if (!visited) {
        var renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        if (!deleted) {
          deleted = [];
        }
        deleted.push(child);
      } else {
        child.setVisited(false);
      }
    }
    if (deleted) {
      model.children = model.children.filter(function(el) {
        return !deleted.includes(el);
      });
    }
  };
  publicAPI.createViewNode = function(dataObj) {
    if (!model.myFactory) {
      vtkErrorMacro$d("Cannot create view nodes without my own factory");
      return null;
    }
    var ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
}
var DEFAULT_VALUES$U = {
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};
function extend$V(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$U, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var newInstance$S = macro.newInstance(extend$V, "vtkViewNode");
var vtkViewNode$1 = {
  newInstance: newInstance$S,
  extend: extend$V,
  PASS_TYPES
};
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = function(dataObject) {
    if (dataObject.isDeleted()) {
      return null;
    }
    var cpt = 0;
    var className = dataObject.getClassName(cpt++);
    var isObject2 = false;
    var keys4 = Object.keys(model.overrides);
    while (className && !isObject2) {
      if (keys4.indexOf(className) !== -1) {
        isObject2 = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject2) {
      return null;
    }
    var vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
  publicAPI.registerOverride = function(className, func) {
    model.overrides[className] = func;
  };
}
var DEFAULT_VALUES$T = {};
function extend$U(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$T, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var newInstance$R = macro.newInstance(extend$U, "vtkViewNodeFactory");
var vtkViewNodeFactory$1 = {
  newInstance: newInstance$R,
  extend: extend$U
};
var CLASS_MAPPING$1 = /* @__PURE__ */ Object.create(null);
function registerOverride$1(className, fn) {
  CLASS_MAPPING$1[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
var DEFAULT_VALUES$S = {};
function extend$T(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$S, initialValues);
  model.overrides = CLASS_MAPPING$1;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
macro.newInstance(extend$T, "vtkOpenGLViewNodeFactory");
function ownKeys$f(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Wrap = Constants$9.Wrap, Filter = Constants$9.Filter;
var VtkDataTypes$1 = vtkDataArray$1.VtkDataTypes;
var vtkDebugMacro$6 = vtkDebugMacro$8, vtkErrorMacro$c = vtkErrorMacro$j, vtkWarningMacro$4 = vtkWarningMacro$7;
function vtkOpenGLTexture(publicAPI, model) {
  var _this = this;
  model.classHierarchy.push("vtkOpenGLTexture");
  publicAPI.render = function() {
    var renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter.NEAREST);
      publicAPI.setMagnificationFilter(Filter.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap.REPEAT);
      publicAPI.setWrapS(Wrap.REPEAT);
      publicAPI.setWrapT(Wrap.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        var canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes$1.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        var jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes$1.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      var input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        var ext = input.getExtent();
        var inScalars = input.getPointData().getScalars();
        var data = [];
        for (var i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          var indata = model.renderable.getInputData(i);
          var scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  publicAPI.destroyTexture = function() {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = function() {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = function() {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = function() {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = function() {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = function(rwin) {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = function() {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = function() {
    var result = false;
    if (model.context && model.handle) {
      var target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro$4("impossible case");
          break;
      }
      var oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = function() {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = function(vtktype, numComps) {
    if (!model.internalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro$6("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = function(vtktype, numComps) {
    var result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, false);
    if (result) {
      return result;
    }
    result = _this._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, true);
    if (!result) {
      vtkDebugMacro$6("Unsupported internal texture type!");
      vtkDebugMacro$6("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return result;
  };
  publicAPI.setInternalFormat = function(iFormat) {
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = function(vtktype, numComps) {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = function(vtktype, numComps) {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = function() {
    model.format = 0;
    model.internalFormat = 0;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes$1.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (useHalfFloatType && VtkDataTypes$1.SHORT):
          return model.context.HALF_FLOAT;
        case (useHalfFloatType && VtkDataTypes$1.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes$1.FLOAT:
        case VtkDataTypes$1.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes$1.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes$1.FLOAT:
      case VtkDataTypes$1.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          var halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.openGLDataType) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType, useHalfFloatType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = function() {
    var shift = 0;
    var scale2 = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale2 = 127.5;
        shift = scale2 - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale2 = 255;
        shift = 0;
        break;
      case model.context.SHORT:
        scale2 = 32767.5;
        shift = scale2 - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale2 = 65536;
        shift = 0;
        break;
      case model.context.INT:
        scale2 = 21474836475e-1;
        shift = scale2 - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale2 = 4294967295;
        shift = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale: scale2
    };
  };
  publicAPI.getOpenGLFilterMode = function(emode) {
    switch (emode) {
      case Filter.NEAREST:
        return model.context.NEAREST;
      case Filter.LINEAR:
        return model.context.LINEAR;
      case Filter.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = function(vtktype) {
    switch (vtktype) {
      case Wrap.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap.REPEAT:
        return model.context.REPEAT;
      case Wrap.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  function updateArrayDataType(dataType, data) {
    var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var pixData = [];
    var pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    if (dataType !== VtkDataTypes$1.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          var dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Float32Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes$1.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (var _idx = 0; _idx < data.length; _idx++) {
        if (data[_idx]) {
          var _dataArrayToCopy = data[_idx].length > pixCount ? data[_idx].subarray(0, pixCount) : data[_idx];
          pixData.push(new Uint8Array(_dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var halfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (halfFloat) {
      for (var _idx2 = 0; _idx2 < data.length; _idx2++) {
        if (data[_idx2]) {
          var newArray = new Uint16Array(pixCount);
          for (var i = 0; i < pixCount; i++) {
            newArray[i] = HalfFloat.toHalf(data[_idx2][i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i = 0; _i < data.length; _i++) {
        pixData.push(data[_i]);
      }
    }
    return pixData;
  }
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    var pixData = [];
    var width = model.width;
    var height = model.height;
    var numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      var halfFloat = model.context.getExtension("OES_texture_half_float");
      var newWidth = nearestPowerOfTwo(width);
      var newHeight = nearestPowerOfTwo(height);
      var pixCount = newWidth * newHeight * model.components;
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          var newArray = null;
          var jFactor = height / newHeight;
          var iFactor = width / newWidth;
          var usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (var j = 0; j < newHeight; j++) {
            var joff = j * newWidth * numComps;
            var jidx = j * jFactor;
            var jlow = Math.floor(jidx);
            var jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            var jmix = jidx - jlow;
            var jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (var i = 0; i < newWidth; i++) {
              var ioff = i * numComps;
              var iidx = i * iFactor;
              var ilow = Math.floor(iidx);
              var ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              var imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (var c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i2 = 0; _i2 < data.length; _i2++) {
        pixData.push(data[_i2]);
      }
    }
    return pixData;
  }
  publicAPI.create2DFromRaw = function(width, height, numComps, dataType, data) {
    var flip = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var pixData = updateArrayDataType(dataType, dataArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = function(width, height, numComps, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    var pixData = updateArrayDataType(dataType, data);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    var invertedData = [];
    var widthLevel = model.width;
    var heightLevel = model.height;
    for (var i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (var y = 0; y < heightLevel; ++y) {
        var row1 = y * widthLevel * model.components;
        var row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    for (var _i3 = 0; _i3 < 6; _i3++) {
      var j = 0;
      var w = model.width;
      var h = model.height;
      while (w >= 1 && h >= 1) {
        var tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + _i3];
        }
        model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + _i3, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        j++;
        w /= 2;
        h /= 2;
      }
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = function(width, height, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes$1.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = function(image) {
    publicAPI.getOpenGLDataType(VtkDataTypes$1.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes$1.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes$1.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.width = image.width;
    model.height = image.height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    var needNearestPowerOfTwo = !isPowerOfTwo(image.width) || !isPowerOfTwo(image.height);
    var canvas = document.createElement("canvas");
    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;
    var ctx = canvas.getContext("2d");
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    var safeImage = canvas;
    model.context.texImage2D(model.target, 0, model.internalFormat, model.format, model.openGLDataType, safeImage);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(numComps, numPixelsIn, data) {
    var min2 = [];
    var max2 = [];
    for (var c = 0; c < numComps; ++c) {
      min2[c] = data[c];
      max2[c] = data[c];
    }
    var count = 0;
    for (var i = 0; i < numPixelsIn; ++i) {
      for (var _c = 0; _c < numComps; ++_c) {
        if (data[count] < min2[_c]) {
          min2[_c] = data[count];
        }
        if (data[count] > max2[_c]) {
          max2[_c] = data[count];
        }
        count++;
      }
    }
    var offset = [];
    var scale2 = [];
    for (var _c2 = 0; _c2 < numComps; ++_c2) {
      if (min2[_c2] === max2[_c2]) {
        max2[_c2] = min2[_c2] + 1;
      }
      offset[_c2] = min2[_c2];
      scale2[_c2] = max2[_c2] - min2[_c2];
    }
    return {
      scale: scale2,
      offset
    };
  }
  function hasExactHalfFloat(offset, scale2) {
    for (var c = 0; c < offset.length; c++) {
      var min2 = offset[c];
      var max2 = scale2[c] + min2;
      if (min2 < -2048 || min2 > 2048 || max2 < -2048 || max2 > 2048) {
        return false;
      }
    }
    return true;
  }
  function checkUseHalfFloat(dataType, offset, scale2, preferSizeOverAccuracy) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var useHalfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (!useHalfFloat) {
      return false;
    }
    if (!hasExactHalfFloat(offset, scale2) && !preferSizeOverAccuracy) {
      return false;
    }
    return true;
  }
  publicAPI.create3DFromRaw = function(width, height, depth, numComps, dataType, data) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var is3DArray = true;
    var pixData = updateArrayDataType(dataType, dataArray, is3DArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function(width, height, depth, numComps, dataType, data) {
    var preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    var numPixelsIn = width * height * depth;
    var offset = [];
    var scale2 = [];
    for (var c = 0; c < numComps; ++c) {
      offset[c] = 0;
      scale2[c] = 1;
    }
    model.volumeInfo = {
      scale: scale2,
      offset,
      width,
      height,
      depth
    };
    var _computeScaleOffsets = computeScaleOffsets(numComps, numPixelsIn, data), computedOffset = _computeScaleOffsets.offset, computedScale = _computeScaleOffsets.scale;
    model.volumeInfo.dataComputedScale = computedScale;
    model.volumeInfo.dataComputedOffset = computedOffset;
    var useHalfFloat = checkUseHalfFloat(dataType, computedOffset, computedScale, preferSizeOverAccuracy);
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes$1.FLOAT || useHalfFloat && (dataType === VtkDataTypes$1.SHORT || dataType === VtkDataTypes$1.UNSIGNED_SHORT)) {
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (dataType === VtkDataTypes$1.UNSIGNED_CHAR) {
        for (var _c3 = 0; _c3 < numComps; ++_c3) {
          model.volumeInfo.scale[_c3] = 255;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      var _newArray = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = computedOffset;
      model.volumeInfo.scale = computedScale;
      var count = 0;
      var scaleInverse = computedScale.map(function(s) {
        return 1 / s;
      });
      for (var i = 0; i < numPixelsIn; i++) {
        for (var nc = 0; nc < numComps; nc++) {
          _newArray[count] = (data[count] - computedOffset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes$1.FLOAT, _newArray);
    }
    var res = computeScaleOffsets(numComps, numPixelsIn, data);
    var volCopyData = function volCopyData2(outArray, outIdx2, inValue, smin, smax) {
      outArray[outIdx2] = inValue;
    };
    var dataTypeToUse = VtkDataTypes$1.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes$1.UNSIGNED_CHAR) {
      for (var _c4 = 0; _c4 < numComps; ++_c4) {
        res.offset[_c4] = 0;
        res.scale[_c4] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes$1.FLOAT;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes$1.UNSIGNED_CHAR;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro$c("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    var maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes$1.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    var xstride = 1;
    var ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    var targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    var xreps = Math.floor(targetWidth * xstride / width);
    var yreps = Math.ceil(depth / xreps);
    var targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = res.offset;
    model.volumeInfo.scale = res.scale;
    var newArray;
    var pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes$1.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    var outIdx = 0;
    var tileWidth = Math.floor(width / xstride);
    var tileHeight = Math.floor(height / ystride);
    for (var yRep = 0; yRep < yreps; yRep++) {
      var xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      var outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (var tileY = 0; tileY < tileHeight; tileY++) {
        for (var xRep = 0; xRep < xrepsThisRow; xRep++) {
          var inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (var tileX = 0; tileX < tileWidth; tileX++) {
            for (var _nc = 0; _nc < numComps; _nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + _nc], res.offset[_nc], res.scale[_nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = function(ctx) {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
}
var DEFAULT_VALUES$R = {
  _openGLRenderWindow: null,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap.CLAMP_TO_EDGE,
  wrapT: Wrap.CLAMP_TO_EDGE,
  wrapR: Wrap.CLAMP_TO_EDGE,
  minificationFilter: Filter.NEAREST,
  magnificationFilter: Filter.NEAREST,
  minLOD: -1e3,
  maxLOD: 1e3,
  baseLevel: 0,
  maxLevel: 1e3,
  generateMipmap: false
};
function extend$S(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$R, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target"]);
  vtkOpenGLTexture(publicAPI, model);
}
var newInstance$Q = newInstance$X(extend$S, "vtkOpenGLTexture");
var vtkOpenGLTexture$1 = _objectSpread$f({
  newInstance: newInstance$Q,
  extend: extend$S
}, Constants$9);
registerOverride$1("vtkTexture", newInstance$Q);
function vtkFramebuffer(publicAPI, model) {
  model.classHierarchy.push("vtkFramebuffer");
  publicAPI.getBothMode = function() {
    return model.context.FRAMEBUFFER;
  };
  publicAPI.saveCurrentBindingsAndBuffers = function(modeIn) {
    var mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = function(modeIn) {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
      return;
    }
    var gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = function(modeIn) {
  };
  publicAPI.restorePreviousBindingsAndBuffers = function(modeIn) {
    var mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = function(modeIn) {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
      return;
    }
    var gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = function(modeIn) {
  };
  publicAPI.bind = function() {
    var modeArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (var i = 0; i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = function(width, height) {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling create");
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function(texture) {
    var attachment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var gl = model.context;
    if (!gl) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling setColorBuffer");
      return;
    }
    var glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro$j("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function() {
    var attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var gl = model.context;
    if (!gl) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling removeColorBuffer");
      return;
    }
    var glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro$j("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = function(texture) {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling setDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      var gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      vtkErrorMacro$j("Attaching depth buffer textures to fbo requires WebGL 2");
    }
  };
  publicAPI.removeDepthBuffer = function() {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      var gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      vtkErrorMacro$j("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }
  };
  publicAPI.getGLFramebuffer = function() {
    return model.glFramebuffer;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = function() {
    var size2 = [0, 0];
    if (model.glFramebuffer !== null) {
      size2[0] = model.glFramebuffer.width;
      size2[1] = model.glFramebuffer.height;
    }
    return size2;
  };
  publicAPI.populateFramebuffer = function() {
    if (!model.context) {
      vtkErrorMacro$j("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
      return;
    }
    publicAPI.bind();
    var gl = model.context;
    var texture = vtkOpenGLTexture$1.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(Filter$1.LINEAR);
    texture.setMagnificationFilter(Filter$1.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, VtkDataTypes$3.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };
  publicAPI.getColorTexture = function() {
    return model.colorBuffers[0];
  };
}
var DEFAULT_VALUES$Q = {
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};
function extend$R(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$Q, initialValues);
  obj(publicAPI, model);
  if (model.colorBuffers) {
    vtkErrorMacro$j("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
  }
  model.colorBuffers = [];
  getArray(publicAPI, model, ["colorBuffers"]);
  vtkFramebuffer(publicAPI, model);
}
var newInstance$P = newInstance$X(extend$R, "vtkFramebuffer");
var vtkOpenGLFramebuffer = {
  newInstance: newInstance$P,
  extend: extend$R
};
var ObjectType$1 = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants$8 = {
  ObjectType: ObjectType$1
};
function ownKeys$e(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ObjectType = Constants$8.ObjectType;
var STATIC$4 = {};
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  var internalType = null;
  var internalHandle = null;
  var dirty = true;
  var error = "";
  publicAPI.getType = function() {
    return internalType;
  };
  publicAPI.setType = function(value) {
    internalType = value;
  };
  publicAPI.getHandle = function() {
    return internalHandle;
  };
  publicAPI.isReady = function() {
    return dirty === false;
  };
  publicAPI.generateBuffer = function(type) {
    var objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = function(data, type) {
    var alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    dirty = false;
    return true;
  };
  publicAPI.bind = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = function() {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
    }
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = function() {
    return error;
  };
}
var DEFAULT_VALUES$P = {
  objectType: ObjectType.ARRAY_BUFFER,
  context: null
};
function extend$Q(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$P, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var newInstance$O = macro.newInstance(extend$Q);
var vtkBufferObject = _objectSpread$e(_objectSpread$e({
  newInstance: newInstance$O,
  extend: extend$Q
}, STATIC$4), Constants$8);
var Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
var Representation$2 = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
var Interpolation$1 = Shading;
var PropertyConst = {
  Shading,
  Representation: Representation$2,
  Interpolation: Interpolation$1
};
var vtkErrorMacro$b = macro.vtkErrorMacro;
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  var inverseScale = new Float64Array(3);
  inverse(inverseScale, coordScale);
  var matrix = new Float64Array(16);
  fromRotationTranslationScale(matrix, create$1(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(exactEquals(coordShift, [0, 0, 0]) && exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType$1.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    var selectionMaps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    var pointData = options.points.getData();
    var normalData = null;
    var tcoordData = null;
    var colorData = null;
    var colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    var textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach(function(a) {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    var pointIdx = 0;
    var normalIdx = 0;
    var tcoordIdx = 0;
    var colorIdx = 0;
    var custIdx = 0;
    var cellCount = 0;
    var addAPoint;
    var cellBuilders = {
      anythingToPoints: function anythingToPoints2(numPoints, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints; ++i2) {
          addAPoint(cellPts[offset + i2]);
        }
      },
      linesToWireframe: function linesToWireframe2(numPoints, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints - 1; ++i2) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1]);
        }
      },
      polysToWireframe: function polysToWireframe2(numPoints, cellPts, offset) {
        if (numPoints > 2) {
          for (var i2 = 0; i2 < numPoints; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + (i2 + 1) % numPoints]);
          }
        }
      },
      stripsToWireframe: function stripsToWireframe2(numPoints, cellPts, offset) {
        if (numPoints > 2) {
          for (var i2 = 0; i2 < numPoints - 1; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + i2 + 1]);
          }
          for (var _i = 0; _i < numPoints - 2; _i++) {
            addAPoint(cellPts[offset + _i]);
            addAPoint(cellPts[offset + _i + 2]);
          }
        }
      },
      polysToSurface: function polysToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + 0]);
          addAPoint(cellPts[offset + i2 + 1]);
          addAPoint(cellPts[offset + i2 + 2]);
        }
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1 + i2 % 2]);
          addAPoint(cellPts[offset + i2 + 1 + (i2 + 1) % 2]);
        }
      }
    };
    var cellCounters = {
      anythingToPoints: function anythingToPoints2(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe: function linesToWireframe2(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe: function polysToWireframe2(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe: function stripsToWireframe2(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface: function polysToSurface2(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    var func = null;
    var countFunc = null;
    if (outRep === Representation$2.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Representation$2.WIREFRAME || inRep === "lines") {
      func = cellBuilders["".concat(inRep, "ToWireframe")];
      countFunc = cellCounters["".concat(inRep, "ToWireframe")];
    } else {
      func = cellBuilders["".concat(inRep, "ToSurface")];
      countFunc = cellCounters["".concat(inRep, "ToSurface")];
    }
    var array = cellArray.getData();
    var size2 = array.length;
    var caboCount = 0;
    for (var index2 = 0; index2 < size2; ) {
      caboCount += countFunc(array[index2], array);
      index2 += array[index2] + 1;
    }
    var packedUCVBO = null;
    var packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    var vboidx = 0;
    var ucidx = 0;
    var diagSq = 0;
    var distSq = 0;
    for (var i = 0; i < 3; ++i) {
      var range = options.points.getRange(i);
      var delta = range[1] - range[0];
      diagSq += delta * delta;
      var distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    var useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || Math.abs(Math.log10(diagSq)) > 3 || diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      var coordShift = new Float64Array(3);
      var coordScale = new Float64Array(3);
      for (var _i2 = 0; _i2 < 3; ++_i2) {
        var _range = options.points.getRange(_i2);
        var _delta = _range[1] - _range[0];
        coordShift[_i2] = 0.5 * (_range[1] + _range[0]);
        coordScale[_i2] = _delta > 0 ? 1 / _delta : 1;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        var newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        var newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    var pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(i2) {
      if (selectionMaps) {
        selectionMaps.points[pointCount] = i2;
        selectionMaps.cells[pointCount] = cellCount;
      }
      ++pointCount;
      pointIdx = i2 * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = i2 * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach(function(attr) {
        custIdx = i2 * attr.components;
        for (var j2 = 0; j2 < attr.components; ++j2) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        tcoordIdx = i2 * textureComponents;
        for (var j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = i2 * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (var _index = 0; _index < size2; ) {
      func(array[_index], array, _index + 1);
      _index += array[_index] + 1;
      cellCount++;
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType$1.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType$1.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = function(coordShift, coordScale) {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro$b("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro$b("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
var DEFAULT_VALUES$O = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};
function extend$P(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$O, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var newInstance$N = macro.newInstance(extend$P);
var vtkCellArrayBufferObject = {
  newInstance: newInstance$N,
  extend: extend$P
};
var vtkErrorMacro$a = macro.vtkErrorMacro;
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = function() {
    var stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    var isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro$a("Error compiling shader '".concat(model.source, "': ").concat(lastError));
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
var DEFAULT_VALUES$N = {
  shaderType: "Unknown",
  source: "",
  error: "",
  handle: 0,
  dirty: false,
  context: null
};
function extend$O(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$N, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var newInstance$M = macro.newInstance(extend$O, "vtkShader");
var vtkShader$1 = {
  newInstance: newInstance$M,
  extend: extend$O
};
var vtkErrorMacro$9 = macro.vtkErrorMacro;
function substitute$1(source, search, replace, all) {
  var replaceStr = typeof replace === "string" ? replace : replace.join("\n");
  var replaceSearch = all === false ? search : new RegExp(search, "g");
  var resultstr = source.replace(replaceSearch, replaceStr);
  return {
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = function() {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro$9(model.vertexShader.getSource().split("\n").map(function(line, index2) {
        return "".concat(index2, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro$9(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro$9(model.fragmentShader.getSource().split("\n").map(function(line, index2) {
        return "".concat(index2, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro$9(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro$9(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro$9(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro$9("Links failed: ".concat(model.error));
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
  };
  publicAPI.bind = function() {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = function() {
    return !!model.bound;
  };
  publicAPI.release = function() {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = function(ctx) {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = function() {
    if (model.inked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    var isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro$9("Error linking shader ".concat(lastError));
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = function(name, a1, a2, a3) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (a3 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = function(name, a) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = function(name) {
    if (!name || !model.linked) {
      return -1;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = "Uniform ".concat(name, " not found in current shader program.");
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = function(name) {
    if (!name) {
      return false;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro$9("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = function(name) {
    if (!name) {
      return false;
    }
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro$9("attempt to find uniform when the shader program is not linked");
      return false;
    }
    var loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      var thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.comntext.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = function(ctx) {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = function(mtime) {
    model.lastCameraMTime = mtime;
  };
}
var DEFAULT_VALUES$M = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: "",
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};
function extend$N(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$M, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var newInstance$L = macro.newInstance(extend$N, "vtkShaderProgram");
var vtkShaderProgram$1 = {
  newInstance: newInstance$L,
  extend: extend$N,
  substitute: substitute$1
};
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = function() {
  };
  publicAPI.initialize = function() {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = function() {
    return model.handleVAO !== 0 || model.supported === false;
  };
  publicAPI.bind = function() {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = function() {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = function() {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = function() {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2) {
    return publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, 0, false);
  };
  publicAPI.addAttributeArrayWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, isMatrix) {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType$1.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    var gl = model.context;
    var attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize2;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      var buffFound = false;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          var found = false;
          for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
            var attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor) {
    var result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, true);
    if (!result) {
      return result;
    }
    var gl = model.context;
    var index2 = gl.getAttribLocation(model.handleProgram, name);
    for (var i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index2 + i);
      gl.vertexAttribPointer(index2 + i, elementTupleSize, elementType, normalize2, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index2 + i, 1);
        } else {
          gl.vertexAttribDivisor(index2 + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = function(name) {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES$L = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
};
function extend$M(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$L, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var newInstance$K = macro.newInstance(extend$M, "vtkOpenGLVertexArrayObject");
var vtkVertexArrayObject = {
  newInstance: newInstance$K,
  extend: extend$M
};
var primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = function(win) {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = function(oglwin) {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = function(ren, actor, rep, oglMapper) {
    if (model.CABO.getElementCount()) {
      var mode = publicAPI.getOpenGLMode(rep);
      var wideLines = publicAPI.haveWideLines(ren, actor);
      var gl = model.context;
      var depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      var drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        gl.lineWidth(1);
      }
      var stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = function(rep) {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    var type = model.primitiveType;
    if (rep === Representation$2.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation$2.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = function(ren, actor) {
    if (actor.getProperty().getLineWidth() > 1) {
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = function(ren, actor, oglMapper) {
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(ren, actor, oglMapper) {
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);
      var newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(ren, actor, size2) {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f("viewportSize", size2.usize, size2.vsize);
      var lineWidth = parseFloat(actor.getProperty().getLineWidth());
      var halfLineWidth = lineWidth / 2;
      publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation$2.POINTS) {
      publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = function() {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
}
var DEFAULT_VALUES$K = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};
function extend$L(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$K, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var newInstance$J = macro.newInstance(extend$L);
var vtkHelper = {
  newInstance: newInstance$J,
  extend: extend$L,
  primTypes
};
function ownKeys$d(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Representation$1 = PropertyConst.Representation, Interpolation = PropertyConst.Interpolation;
function notImplemented$1(method) {
  return function() {
    return macro.vtkErrorMacro("vtkProperty::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = function(r, g2, b) {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g2 || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g2;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented$1("ComputeCompositeColor");
  publicAPI.getColor = function() {
    var norm2 = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm2 = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (var i = 0; i < 3; i++) {
      model.color[i] = norm2 * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = function(specularPower) {
    var roughness = 1 / Math.max(1, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower;
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented$1("AddShaderVariable");
  publicAPI.setInterpolationToFlat = function() {
    return publicAPI.setInterpolation(Interpolation.FLAT);
  };
  publicAPI.setInterpolationToGouraud = function() {
    return publicAPI.setInterpolation(Interpolation.GOURAUD);
  };
  publicAPI.setInterpolationToPhong = function() {
    return publicAPI.setInterpolation(Interpolation.PHONG);
  };
  publicAPI.getInterpolationAsString = function() {
    return macro.enumToString(Interpolation, model.interpolation);
  };
  publicAPI.setRepresentationToWireframe = function() {
    return publicAPI.setRepresentation(Representation$1.WIREFRAME);
  };
  publicAPI.setRepresentationToSurface = function() {
    return publicAPI.setRepresentation(Representation$1.SURFACE);
  };
  publicAPI.setRepresentationToPoints = function() {
    return publicAPI.setRepresentation(Representation$1.POINTS);
  };
  publicAPI.getRepresentationAsString = function() {
    return macro.enumToString(Representation$1, model.representation);
  };
}
var DEFAULT_VALUES$J = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation.GOURAUD,
  representation: Representation$1.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null
};
function extend$K(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$J, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var newInstance$I = macro.newInstance(extend$K, "vtkProperty");
var vtkProperty$1 = _objectSpread$d({
  newInstance: newInstance$I,
  extend: extend$K
}, PropertyConst);
var vtkErrorMacro$8 = macro.vtkErrorMacro, vtkWarningMacro$3 = macro.vtkWarningMacro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  var superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map(function(item) {
      return {
        data: vtk(item.data)
      };
    });
  }
  publicAPI.initialize = function() {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = function() {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = function(other) {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map(function(x) {
      return x;
    });
    model.arrays = other.arrays().map(function(x) {
      return {
        array: x
      };
    });
  };
  publicAPI.getNumberOfArrays = function() {
    return model.arrays.length;
  };
  publicAPI.getNumberOfActiveArrays = function() {
    return model.arrays.length;
  };
  publicAPI.addArray = function(arr) {
    var name = arr.getName();
    var _publicAPI$getArrayWi = publicAPI.getArrayWithIndex(name), array = _publicAPI$getArrayWi.array, index2 = _publicAPI$getArrayWi.index;
    if (array != null) {
      model.arrays[index2] = {
        data: arr
      };
      return index2;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry) {
      return arrayName !== entry.data.getName();
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
  };
  publicAPI.getArrays = function() {
    return model.arrays.map(function(entry) {
      return entry.data;
    });
  };
  publicAPI.getArray = function(arraySpec) {
    return typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  };
  publicAPI.getArrayByName = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data.getName() === arrayName ? b.data : a;
    }, null);
  };
  publicAPI.getArrayWithIndex = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data && b.data.getName() === arrayName ? {
        array: b.data,
        index: i
      } : a;
    }, {
      array: null,
      index: -1
    });
  };
  publicAPI.getArrayByIndex = function(idx) {
    return idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  };
  publicAPI.hasArray = function(arrayName) {
    return publicAPI.getArrayWithIndex(arrayName).index >= 0;
  };
  publicAPI.getArrayName = function(idx) {
    var arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = function() {
    return model.copyFieldFlags;
  };
  publicAPI.getFlag = function(arrayName) {
    return model.copyFieldFlags[arrayName];
  };
  publicAPI.passData = function(other) {
    var fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    var toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach(function(arr) {
      var copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        var destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            var ncomps = arr.getNumberOfComponents();
            var newSize = arr.getNumberOfValues();
            var tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            var _tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(_tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro$8("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    var fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    var fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    var toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    var t = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    other.getArrays().forEach(function(arr) {
      var copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        var destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            var ncomps = arr.getNumberOfComponents();
            var newSize = arr.getNumberOfValues();
            var tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            var _tId2 = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(_tId2, arr, fromId1, arr, fromId2, t);
            vtkWarningMacro$3("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro$8("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = function(arrayName) {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = function(arrayName) {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = function() {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = function() {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = function() {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = function(other) {
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = function(other) {
    return other.getCopyFieldFlags().map(function(x) {
      return x;
    });
  };
  publicAPI.reset = function() {
    return model.arrays.forEach(function(entry) {
      return entry.data.reset();
    });
  };
  publicAPI.getMTime = function() {
    return model.arrays.reduce(function(a, b) {
      return b.data.getMTime() > a ? b.data.getMTime() : a;
    }, model.mtime);
  };
  publicAPI.getNumberOfComponents = function() {
    return model.arrays.reduce(function(a, b) {
      return a + b.data.getNumberOfComponents();
    }, 0);
  };
  publicAPI.getNumberOfTuples = function() {
    return model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  };
  publicAPI.getState = function() {
    var result = superGetState();
    if (result) {
      result.arrays = model.arrays.map(function(item) {
        return {
          data: item.data.getState()
        };
      });
    }
    return result;
  };
}
var DEFAULT_VALUES$I = {
  arrays: [],
  copyFieldFlags: [],
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend$J(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$I, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance$H = macro.newInstance(extend$J, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance: newInstance$H,
  extend: extend$J
};
var AttributeTypes$1 = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  HIGHCONNECTIVITYCELL: 2,
  LOWCONNECTIVITYCELL: 4,
  REFINEDCELL: 8,
  EXTERIORCELL: 16,
  HIDDENCELL: 32
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  HIDDENPOINT: 2
};
var AttributeCopyOperations$1 = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  SINGLE: 1,
  DOUBLE: 2
};
var Constants$7 = {
  AttributeCopyOperations: AttributeCopyOperations$1,
  AttributeLimitTypes,
  AttributeTypes: AttributeTypes$1,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};
function ownKeys$c(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var AttributeTypes = Constants$7.AttributeTypes, AttributeCopyOperations = Constants$7.AttributeCopyOperations;
var vtkWarningMacro$2 = macro.vtkWarningMacro;
function vtkDataSetAttributes(publicAPI, model) {
  var attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    var cleanAttType = attrTypes.find(function(ee) {
      return AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase();
    });
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  publicAPI.checkNumberOfComponents = function(x) {
    return true;
  };
  publicAPI.setAttribute = function(arr, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro$2("Cannot set attribute ".concat(attType, ". The attribute must be a vtkDataArray."));
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro$2("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
      return -1;
    }
    var currentAttribute = model["active".concat(attType)];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model["active".concat(attType)] = currentAttribute;
    } else {
      model["active".concat(attType)] = -1;
    }
    publicAPI.modified();
    return model["active".concat(attType)];
  };
  publicAPI.getAttributes = function(arr) {
    return attrTypes.filter(function(attrType) {
      return publicAPI["get".concat(attrType)]() === arr;
    });
  };
  publicAPI.setActiveAttributeByName = function(arrayName, attType) {
    return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  };
  publicAPI.setActiveAttributeByIndex = function(arrayIdx, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        var arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro$2("Cannot set attribute ".concat(attType, ". Only vtkDataArray subclasses can be set as active attributes."));
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro$2("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
          return -1;
        }
      }
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = function(attType) {
    var cleanAttType = cleanAttributeType(attType);
    return publicAPI["get".concat(cleanAttType)]();
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
    attrTypes.forEach(function(attType) {
      model["active".concat(attType)] = -1;
    });
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      if (arrayName === entry.data.getName()) {
        attrTypes.forEach(function(attType) {
          if (idx === model["active".concat(attType)]) {
            model["active".concat(attType)] = -1;
          }
        });
        return false;
      }
      return true;
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
    attrTypes.forEach(function(attType) {
      if (arrayIdx === model["active".concat(attType)]) {
        model["active".concat(attType)] = -1;
      }
    });
  };
  attrTypes.forEach(function(value) {
    var activeVal = "active".concat(value);
    publicAPI["get".concat(value)] = function() {
      return publicAPI.getArrayByIndex(model[activeVal]);
    };
    publicAPI["set".concat(value)] = function(da) {
      return publicAPI.setAttribute(da, value);
    };
    publicAPI["setActive".concat(value)] = function(arrayName) {
      return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    };
    publicAPI["copy".concat(value, "Off")] = function() {
      var attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;
    };
    publicAPI["copy".concat(value, "On")] = function() {
      var attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = function() {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations).filter(function(op) {
      return op !== "ALLCOPY";
    }).forEach(function(attCopyOp) {
      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(function(ty) {
        return ty !== "NUM_ATTRIBUTES";
      }).reduce(function(a, b) {
        a[AttributeTypes[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach(function(name) {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other, debug) {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES$H = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend$I(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$H, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance$G = macro.newInstance(extend$I, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = _objectSpread$c({
  newInstance: newInstance$G,
  extend: extend$I
}, Constants$7);
var FieldDataTypes = {
  UNIFORM: 0,
  DATA_OBJECT_FIELD: 0,
  COORDINATE: 1,
  POINT_DATA: 1,
  POINT: 2,
  POINT_FIELD_DATA: 2,
  CELL: 3,
  CELL_FIELD_DATA: 3,
  VERTEX: 4,
  VERTEX_FIELD_DATA: 4,
  EDGE: 5,
  EDGE_FIELD_DATA: 5,
  ROW: 6,
  ROW_DATA: 6
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants$6 = {
  FieldDataTypes,
  FieldAssociations
};
function ownKeys$b(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach(function(fieldName) {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach(function(fieldName) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}
var DEFAULT_VALUES$G = {};
function extend$H(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$G, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  vtkDataSet(publicAPI, model);
}
var newInstance$F = macro.newInstance(extend$H, "vtkDataSet");
var vtkDataSet$1 = _objectSpread$b({
  newInstance: newInstance$F,
  extend: extend$H
}, Constants$6);
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      var tsize = model.openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = function(ren) {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      copy$1(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      invert$1(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      var aspectRatio = model.openGLRenderer.getAspectRatio();
      copy$1(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      multiply$2(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES$F = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend$G(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$F, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var newInstance$E = newInstance$X(extend$G);
registerOverride$1("vtkCamera", newInstance$E);
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = function() {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = function(plane) {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = function() {
    return model.clippingPlanes.length;
  };
  publicAPI.removeAllClippingPlanes = function() {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = function(clippingPlane) {
    var i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = function() {
    return model.clippingPlanes;
  };
  publicAPI.setClippingPlanes = function(planes) {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      var nbPlanes = planes.length;
      for (var i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = function(propMatrix, i, hnormal) {
    var clipPlanes = model.clippingPlanes;
    var mat = propMatrix;
    if (clipPlanes) {
      var n = clipPlanes.length;
      if (i >= 0 && i < n) {
        var plane = clipPlanes[i];
        var normal = plane.getNormal();
        var origin = plane.getOrigin();
        var v1 = normal[0];
        var v2 = normal[1];
        var v3 = normal[2];
        var v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro("Clipping plane index ".concat(i, " is out of range."));
  };
}
var DEFAULT_VALUES$E = {
  clippingPlanes: []
};
function extend$F(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$E, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var vtkAbstractMapper$1 = {
  extend: extend$F
};
function ownKeys$a(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var PLANE_TOLERANCE = 1e-6;
var COINCIDE = "coincide";
var DISJOINT = "disjoint";
function evaluate(normal, origin, x) {
  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
}
function distanceToPlane(x, origin, normal) {
  var distance2 = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  return Math.abs(distance2);
}
function projectPoint(x, origin, normal, xproj) {
  var xo = [];
  subtract(x, origin, xo);
  var t = dot(normal, xo);
  xproj[0] = x[0] - t * normal[0];
  xproj[1] = x[1] - t * normal[1];
  xproj[2] = x[2] - t * normal[2];
}
function projectVector(v, normal, vproj) {
  var t = dot(v, normal);
  var n2 = dot(normal, normal);
  if (n2 === 0) {
    n2 = 1;
  }
  vproj[0] = v[0] - t * normal[0] / n2;
  vproj[1] = v[1] - t * normal[1] / n2;
  vproj[2] = v[2] - t * normal[2] / n2;
  return vproj;
}
function generalizedProjectPoint(x, origin, normal, xproj) {
  var xo = [];
  subtract(x, origin, xo);
  var t = dot(normal, xo);
  var n2 = dot(normal, normal);
  if (n2 !== 0) {
    xproj[0] = x[0] - t * normal[0] / n2;
    xproj[1] = x[1] - t * normal[1] / n2;
    xproj[2] = x[2] - t * normal[2] / n2;
  } else {
    xproj[0] = x[0];
    xproj[1] = x[1];
    xproj[2] = x[2];
  }
}
function intersectWithLine(p1, p2, origin, normal) {
  var outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: []
  };
  var p21 = [];
  var p1Origin = [];
  subtract(p2, p1, p21);
  subtract(origin, p1, p1Origin);
  var num = dot(normal, p1Origin);
  var den = dot(normal, p21);
  var fabsden;
  var fabstolerance;
  if (den < 0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }
  outObj.t = num / den;
  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];
  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
  return outObj;
}
function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
  var outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null
  };
  var cross$12 = [];
  cross(plane1Normal, plane2Normal, cross$12);
  var absCross = cross$12.map(function(n) {
    return Math.abs(n);
  });
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    var v = [];
    subtract(plane1Origin, plane2Origin, v);
    if (dot(plane1Normal, v) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }
  var maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = "x";
  } else if (absCross[1] > absCross[2]) {
    maxc = "y";
  } else {
    maxc = "z";
  }
  var iP = [];
  var d1 = -dot(plane1Normal, plane1Origin);
  var d2 = -dot(plane2Normal, plane2Origin);
  switch (maxc) {
    case "x":
      iP[0] = 0;
      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$12[0];
      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$12[0];
      break;
    case "y":
      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$12[1];
      iP[1] = 0;
      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$12[1];
      break;
    case "z":
      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$12[2];
      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$12[2];
      iP[2] = 0;
      break;
  }
  outObj.l0 = iP;
  add(iP, cross$12, outObj.l1);
  outObj.intersection = true;
  return outObj;
}
var STATIC$3 = {
  evaluate,
  distanceToPlane,
  projectPoint,
  projectVector,
  generalizedProjectPoint,
  intersectWithLine,
  intersectWithPlane,
  DISJOINT,
  COINCIDE
};
function vtkPlane(publicAPI, model) {
  model.classHierarchy.push("vtkPlane");
  publicAPI.distanceToPlane = function(x) {
    return distanceToPlane(x, model.origin, model.normal);
  };
  publicAPI.projectPoint = function(x, xproj) {
    projectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.projectVector = function(v, vproj) {
    return projectVector(v, model.normal, vproj);
  };
  publicAPI.push = function(distance2) {
    if (distance2 === 0) {
      return;
    }
    for (var i = 0; i < 3; i++) {
      model.origin[i] += distance2 * model.normal[i];
    }
  };
  publicAPI.generalizedProjectPoint = function(x, xproj) {
    generalizedProjectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.evaluateFunction = function(x, y, z) {
    if (!Array.isArray(x)) {
      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
    }
    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
  };
  publicAPI.evaluateGradient = function(xyz) {
    var retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };
  publicAPI.intersectWithLine = function(p1, p2) {
    return intersectWithLine(p1, p2, model.origin, model.normal);
  };
  publicAPI.intersectWithPlane = function(planeOrigin, planeNormal) {
    return intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
  };
}
var DEFAULT_VALUES$D = {
  normal: [0, 0, 1],
  origin: [0, 0, 0]
};
function extend$E(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$D, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
  vtkPlane(publicAPI, model);
}
var newInstance$D = macro.newInstance(extend$E, "vtkPlane");
var vtkPlane$1 = _objectSpread$a({
  newInstance: newInstance$D,
  extend: extend$E
}, STATIC$3);
function ownKeys$9(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var INIT_BOUNDS = [
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  Number.MAX_VALUE,
  -Number.MAX_VALUE
];
function _equals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function _isValid(bounds) {
  return bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
}
function _setBounds(bounds, otherBounds) {
  bounds[0] = otherBounds[0];
  bounds[1] = otherBounds[1];
  bounds[2] = otherBounds[2];
  bounds[3] = otherBounds[3];
  bounds[4] = otherBounds[4];
  bounds[5] = otherBounds[5];
  return bounds;
}
function _reset(bounds) {
  return _setBounds(bounds, INIT_BOUNDS);
}
function _addPoint(bounds) {
  var _bounds = _slicedToArray(bounds, 6), xMin = _bounds[0], xMax = _bounds[1], yMin = _bounds[2], yMax = _bounds[3], zMin = _bounds[4], zMax = _bounds[5];
  bounds[0] = xMin < (arguments.length <= 1 ? void 0 : arguments[1]) ? xMin : arguments.length <= 1 ? void 0 : arguments[1];
  bounds[1] = xMax > (arguments.length <= 1 ? void 0 : arguments[1]) ? xMax : arguments.length <= 1 ? void 0 : arguments[1];
  bounds[2] = yMin < (arguments.length <= 2 ? void 0 : arguments[2]) ? yMin : arguments.length <= 2 ? void 0 : arguments[2];
  bounds[3] = yMax > (arguments.length <= 2 ? void 0 : arguments[2]) ? yMax : arguments.length <= 2 ? void 0 : arguments[2];
  bounds[4] = zMin < (arguments.length <= 3 ? void 0 : arguments[3]) ? zMin : arguments.length <= 3 ? void 0 : arguments[3];
  bounds[5] = zMax > (arguments.length <= 3 ? void 0 : arguments[3]) ? zMax : arguments.length <= 3 ? void 0 : arguments[3];
  return bounds;
}
function _addPoints(bounds, points) {
  if (points.length === 0) {
    return bounds;
  }
  if (Array.isArray(points[0])) {
    for (var i = 0; i < points.length; ++i) {
      _addPoint(bounds, points[i]);
    }
  } else {
    for (var _i = 0; _i < points.length; _i += 3) {
      _addPoint(bounds, points.slice(_i, _i + 3));
    }
  }
  return bounds;
}
function _addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
  var _bounds2 = _slicedToArray(bounds, 6), _xMin = _bounds2[0], _xMax = _bounds2[1], _yMin = _bounds2[2], _yMax = _bounds2[3], _zMin = _bounds2[4], _zMax = _bounds2[5];
  if (zMax === void 0) {
    bounds[0] = Math.min(xMin[0], _xMin);
    bounds[1] = Math.max(xMin[1], _xMax);
    bounds[2] = Math.min(xMin[2], _yMin);
    bounds[3] = Math.max(xMin[3], _yMax);
    bounds[4] = Math.min(xMin[4], _zMin);
    bounds[5] = Math.max(xMin[5], _zMax);
  } else {
    bounds[0] = Math.min(xMin, _xMin);
    bounds[1] = Math.max(xMax, _xMax);
    bounds[2] = Math.min(yMin, _yMin);
    bounds[3] = Math.max(yMax, _yMax);
    bounds[4] = Math.min(zMin, _zMin);
    bounds[5] = Math.max(zMax, _zMax);
  }
  return bounds;
}
function _setMinPoint(bounds, x, y, z) {
  var _bounds3 = _slicedToArray(bounds, 6), xMin = _bounds3[0], xMax = _bounds3[1], yMin = _bounds3[2], yMax = _bounds3[3], zMin = _bounds3[4], zMax = _bounds3[5];
  bounds[0] = x;
  bounds[1] = x > xMax ? x : xMax;
  bounds[2] = y;
  bounds[3] = y > yMax ? y : yMax;
  bounds[4] = z;
  bounds[5] = z > zMax ? z : zMax;
  return xMin !== x || yMin !== y || zMin !== z;
}
function _setMaxPoint(bounds, x, y, z) {
  var _bounds4 = _slicedToArray(bounds, 6), xMin = _bounds4[0], xMax = _bounds4[1], yMin = _bounds4[2], yMax = _bounds4[3], zMin = _bounds4[4], zMax = _bounds4[5];
  bounds[0] = x < xMin ? x : xMin;
  bounds[1] = x;
  bounds[2] = y < yMin ? y : yMin;
  bounds[3] = y;
  bounds[4] = z < zMin ? z : zMin;
  bounds[5] = z;
  return xMax !== x || yMax !== y || zMax !== z;
}
function _inflate(bounds, delta) {
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
function _scale(bounds, sx, sy, sz) {
  if (!_isValid(bounds)) {
    return false;
  }
  if (sx >= 0) {
    bounds[0] *= sx;
    bounds[1] *= sx;
  } else {
    bounds[0] = sx * bounds[1];
    bounds[1] = sx * bounds[0];
  }
  if (sy >= 0) {
    bounds[2] *= sy;
    bounds[3] *= sy;
  } else {
    bounds[2] = sy * bounds[3];
    bounds[3] = sy * bounds[2];
  }
  if (sz >= 0) {
    bounds[4] *= sz;
    bounds[5] *= sz;
  } else {
    bounds[4] = sz * bounds[5];
    bounds[5] = sz * bounds[4];
  }
  return true;
}
function _getCenter(bounds) {
  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
}
function scaleAboutCenter(bounds, sx, sy, sz) {
  if (!_isValid(bounds)) {
    return false;
  }
  var center = _getCenter(bounds);
  bounds[0] -= center[0];
  bounds[1] -= center[0];
  bounds[2] -= center[1];
  bounds[3] -= center[1];
  bounds[4] -= center[2];
  bounds[5] -= center[2];
  _scale(bounds, sx, sy, sz);
  bounds[0] += center[0];
  bounds[1] += center[0];
  bounds[2] += center[1];
  bounds[3] += center[1];
  bounds[4] += center[2];
  bounds[5] += center[2];
  return true;
}
function _getLength(bounds, index2) {
  return bounds[index2 * 2 + 1] - bounds[index2 * 2];
}
function _getLengths(bounds) {
  return [_getLength(bounds, 0), _getLength(bounds, 1), _getLength(bounds, 2)];
}
function _getXRange(bounds) {
  return bounds.slice(0, 2);
}
function _getYRange(bounds) {
  return bounds.slice(2, 4);
}
function _getZRange(bounds) {
  return bounds.slice(4, 6);
}
function _getMaxLength(bounds) {
  var l = _getLengths(bounds);
  if (l[0] > l[1]) {
    if (l[0] > l[2]) {
      return l[0];
    }
    return l[2];
  }
  if (l[1] > l[2]) {
    return l[1];
  }
  return l[2];
}
function _getDiagonalLength(bounds) {
  if (_isValid(bounds)) {
    var l = _getLengths(bounds);
    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);
  }
  return null;
}
function _getMinPoint(bounds) {
  return [bounds[0], bounds[2], bounds[4]];
}
function _getMaxPoint(bounds) {
  return [bounds[1], bounds[3], bounds[5]];
}
function oppositeSign(a, b) {
  return a <= 0 && b >= 0 || a >= 0 && b <= 0;
}
function _getCorners(bounds, corners) {
  var count = 0;
  for (var ix = 0; ix < 2; ix++) {
    for (var iy = 2; iy < 4; iy++) {
      for (var iz = 4; iz < 6; iz++) {
        corners[count] = [bounds[ix], bounds[iy], bounds[iz]];
        count++;
      }
    }
  }
  return corners;
}
function _computeCornerPoints(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function _computeScale(bounds) {
  var scale3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  scale3[0] = 0.5 * (bounds[1] - bounds[0]);
  scale3[1] = 0.5 * (bounds[3] - bounds[2]);
  scale3[2] = 0.5 * (bounds[5] - bounds[4]);
  return scale3;
}
function _computeLocalBounds(points, u, v, w) {
  var bounds = [].concat(INIT_BOUNDS);
  var pointsData = points.getData();
  for (var i = 0; i < pointsData.length; i += 3) {
    var point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
    var du = dot(point, u);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    var dv = dot(point, v);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    var dw = dot(point, w);
    bounds[4] = Math.min(dw, bounds[4]);
    bounds[5] = Math.max(dw, bounds[5]);
  }
  return bounds;
}
function _intersectBox(bounds, origin, dir, coord, tolerance) {
  var inside = true;
  var quadrant = [];
  var whichPlane = 0;
  var maxT = [];
  var candidatePlane = [0, 0, 0];
  var RIGHT = 0;
  var LEFT = 1;
  var MIDDLE = 2;
  for (var i = 0; i < 3; i++) {
    if (origin[i] < bounds[2 * i]) {
      quadrant[i] = LEFT;
      candidatePlane[i] = bounds[2 * i];
      inside = false;
    } else if (origin[i] > bounds[2 * i + 1]) {
      quadrant[i] = RIGHT;
      candidatePlane[i] = bounds[2 * i + 1];
      inside = false;
    } else {
      quadrant[i] = MIDDLE;
    }
  }
  if (inside) {
    coord[0] = origin[0];
    coord[1] = origin[1];
    coord[2] = origin[2];
    tolerance[0] = 0;
    return 1;
  }
  for (var _i2 = 0; _i2 < 3; _i2++) {
    if (quadrant[_i2] !== MIDDLE && dir[_i2] !== 0) {
      maxT[_i2] = (candidatePlane[_i2] - origin[_i2]) / dir[_i2];
    } else {
      maxT[_i2] = -1;
    }
  }
  for (var _i3 = 0; _i3 < 3; _i3++) {
    if (maxT[whichPlane] < maxT[_i3]) {
      whichPlane = _i3;
    }
  }
  if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
    return 0;
  }
  tolerance[0] = maxT[whichPlane];
  for (var _i4 = 0; _i4 < 3; _i4++) {
    if (whichPlane !== _i4) {
      coord[_i4] = origin[_i4] + maxT[whichPlane] * dir[_i4];
      if (coord[_i4] < bounds[2 * _i4] || coord[_i4] > bounds[2 * _i4 + 1]) {
        return 0;
      }
    } else {
      coord[_i4] = candidatePlane[_i4];
    }
  }
  return 1;
}
function _intersectPlane(bounds, origin, normal) {
  var p2 = [];
  var d = 0;
  var sign = 1;
  var firstOne = 1;
  for (var z = 4; z <= 5; ++z) {
    p2[2] = bounds[z];
    for (var y = 2; y <= 3; ++y) {
      p2[1] = bounds[y];
      for (var x = 0; x <= 1; ++x) {
        p2[0] = bounds[x];
        d = vtkPlane$1.evaluate(normal, origin, p2);
        if (firstOne) {
          sign = d >= 0 ? 1 : -1;
          firstOne = 0;
        }
        if (d === 0 || sign > 0 && d < 0 || sign < 0 && d > 0) {
          return 1;
        }
      }
    }
  }
  return 0;
}
function _intersect(bounds, bBounds) {
  if (!(_isValid(bounds) && _isValid(bBounds))) {
    return false;
  }
  var newBounds = [0, 0, 0, 0, 0, 0];
  var intersection;
  for (var i = 0; i < 3; i++) {
    intersection = false;
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2] = bBounds[i * 2];
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2] = bounds[i * 2];
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2 + 1] = bBounds[2 * i + 1];
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2 + 1] = bounds[i * 2 + 1];
    }
    if (!intersection) {
      return false;
    }
  }
  bounds[0] = newBounds[0];
  bounds[1] = newBounds[1];
  bounds[2] = newBounds[2];
  bounds[3] = newBounds[3];
  bounds[4] = newBounds[4];
  bounds[5] = newBounds[5];
  return true;
}
function _intersects(bounds, bBounds) {
  if (!(_isValid(bounds) && _isValid(bBounds))) {
    return false;
  }
  for (var i = 0; i < 3; i++) {
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      continue;
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      continue;
    }
    return false;
  }
  return true;
}
function _containsPoint(bounds, x, y, z) {
  if (x < bounds[0] || x > bounds[1]) {
    return false;
  }
  if (y < bounds[2] || y > bounds[3]) {
    return false;
  }
  if (z < bounds[4] || z > bounds[5]) {
    return false;
  }
  return true;
}
function contains(bounds, otherBounds) {
  if (!_intersects(bounds, otherBounds)) {
    return false;
  }
  if (!_containsPoint.apply(void 0, [bounds].concat(_toConsumableArray(_getMinPoint(otherBounds))))) {
    return false;
  }
  if (!_containsPoint.apply(void 0, [bounds].concat(_toConsumableArray(_getMaxPoint(otherBounds))))) {
    return false;
  }
  return true;
}
function _cutWithPlane(bounds, origin, normal) {
  var index2 = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
  var d = [0, 0, 0, 0, 0, 0, 0, 0];
  var idx = 0;
  for (var ix = 0; ix < 2; ix++) {
    for (var iy = 2; iy < 4; iy++) {
      for (var iz = 4; iz < 6; iz++) {
        var x = [bounds[ix], bounds[iy], bounds[iz]];
        d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
      }
    }
  }
  var dir = 2;
  while (dir--) {
    if (oppositeSign(d[index2[dir][0]], d[index2[dir][4]]) && oppositeSign(d[index2[dir][1]], d[index2[dir][5]]) && oppositeSign(d[index2[dir][2]], d[index2[dir][6]]) && oppositeSign(d[index2[dir][3]], d[index2[dir][7]])) {
      break;
    }
  }
  if (dir < 0) {
    return false;
  }
  var sign = Math.sign(normal[dir]);
  var size2 = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
  var t = sign > 0 ? 1 : 0;
  for (var i = 0; i < 4; i++) {
    if (size2 === 0) {
      continue;
    }
    var ti = Math.abs(d[index2[dir][i]]) / size2;
    if (sign > 0 && ti < t) {
      t = ti;
    }
    if (sign < 0 && ti > t) {
      t = ti;
    }
  }
  var bound2 = (1 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
  if (sign > 0) {
    bounds[dir * 2] = bound2;
  } else {
    bounds[dir * 2 + 1] = bound2;
  }
  return true;
}
var BoundingBox = /* @__PURE__ */ function() {
  function BoundingBox2(refBounds) {
    _classCallCheck(this, BoundingBox2);
    this.bounds = refBounds;
    if (!this.bounds) {
      this.bounds = new Float64Array(INIT_BOUNDS);
    }
  }
  _createClass(BoundingBox2, [{
    key: "getBounds",
    value: function getBounds() {
      return this.bounds;
    }
  }, {
    key: "equals",
    value: function equals2(otherBounds) {
      return _equals(this.bounds, otherBounds);
    }
  }, {
    key: "isValid",
    value: function isValid() {
      return _isValid(this.bounds);
    }
  }, {
    key: "setBounds",
    value: function setBounds(otherBounds) {
      return _setBounds(this.bounds, otherBounds);
    }
  }, {
    key: "reset",
    value: function reset() {
      return _reset(this.bounds);
    }
  }, {
    key: "addPoint",
    value: function addPoint() {
      for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
        xyz[_key] = arguments[_key];
      }
      return _addPoint(this.bounds, xyz);
    }
  }, {
    key: "addPoints",
    value: function addPoints(points) {
      return _addPoints(this.bounds, points);
    }
  }, {
    key: "addBounds",
    value: function addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
      return _addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
    }
  }, {
    key: "setMinPoint",
    value: function setMinPoint(x, y, z) {
      return _setMinPoint(this.bounds, x, y, z);
    }
  }, {
    key: "setMaxPoint",
    value: function setMaxPoint(x, y, z) {
      return _setMaxPoint(this.bounds, x, y, z);
    }
  }, {
    key: "inflate",
    value: function inflate(delta) {
      return _inflate(this.bounds, delta);
    }
  }, {
    key: "scale",
    value: function scale2(sx, sy, sz) {
      return _scale(this.bounds, sx, sy, sz);
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return _getCenter(this.bounds);
    }
  }, {
    key: "getLength",
    value: function getLength(index2) {
      return _getLength(this.bounds, index2);
    }
  }, {
    key: "getLengths",
    value: function getLengths() {
      return _getLengths(this.bounds);
    }
  }, {
    key: "getMaxLength",
    value: function getMaxLength() {
      return _getMaxLength(this.bounds);
    }
  }, {
    key: "getDiagonalLength",
    value: function getDiagonalLength() {
      return _getDiagonalLength(this.bounds);
    }
  }, {
    key: "getMinPoint",
    value: function getMinPoint() {
      return _getMinPoint(this.bounds);
    }
  }, {
    key: "getMaxPoint",
    value: function getMaxPoint() {
      return _getMaxPoint(this.bounds);
    }
  }, {
    key: "getXRange",
    value: function getXRange() {
      return _getXRange(this.bounds);
    }
  }, {
    key: "getYRange",
    value: function getYRange() {
      return _getYRange(this.bounds);
    }
  }, {
    key: "getZRange",
    value: function getZRange() {
      return _getZRange(this.bounds);
    }
  }, {
    key: "getCorners",
    value: function getCorners(corners) {
      return _getCorners(this.bounds, corners);
    }
  }, {
    key: "computeCornerPoints",
    value: function computeCornerPoints(point1, point2) {
      return _computeCornerPoints(this.bounds, point1, point2);
    }
  }, {
    key: "computeLocalBounds",
    value: function computeLocalBounds(u, v, w) {
      return _computeLocalBounds(this.bounds, u, v, w);
    }
  }, {
    key: "computeScale3",
    value: function computeScale3(scale3) {
      return _computeScale(this.bounds, scale3);
    }
  }, {
    key: "cutWithPlane",
    value: function cutWithPlane(origin, normal) {
      return _cutWithPlane(this.bounds, origin, normal);
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(origin, dir, coord, tolerance) {
      return _intersectBox(this.bounds, origin, dir, coord, tolerance);
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(origin, normal) {
      return _intersectPlane(this.bounds, origin, normal);
    }
  }, {
    key: "intersect",
    value: function intersect(otherBounds) {
      return _intersect(this.bounds, otherBounds);
    }
  }, {
    key: "intersects",
    value: function intersects(otherBounds) {
      return _intersects(this.bounds, otherBounds);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(x, y, z) {
      return _containsPoint(this.bounds, x, y, z);
    }
  }, {
    key: "contains",
    value: function contains2(otherBounds) {
      return _intersects(this.bounds, otherBounds);
    }
  }]);
  return BoundingBox2;
}();
function newInstance$C(initialValues) {
  var bounds = initialValues && initialValues.bounds;
  return new BoundingBox(bounds);
}
var STATIC$2 = {
  equals: _equals,
  isValid: _isValid,
  setBounds: _setBounds,
  reset: _reset,
  addPoint: _addPoint,
  addPoints: _addPoints,
  addBounds: _addBounds,
  setMinPoint: _setMinPoint,
  setMaxPoint: _setMaxPoint,
  inflate: _inflate,
  scale: _scale,
  scaleAboutCenter,
  getCenter: _getCenter,
  getLength: _getLength,
  getLengths: _getLengths,
  getMaxLength: _getMaxLength,
  getDiagonalLength: _getDiagonalLength,
  getMinPoint: _getMinPoint,
  getMaxPoint: _getMaxPoint,
  getXRange: _getXRange,
  getYRange: _getYRange,
  getZRange: _getZRange,
  getCorners: _getCorners,
  computeCornerPoints: _computeCornerPoints,
  computeLocalBounds: _computeLocalBounds,
  computeScale3: _computeScale,
  cutWithPlane: _cutWithPlane,
  intersectBox: _intersectBox,
  intersectPlane: _intersectPlane,
  intersect: _intersect,
  intersects: _intersects,
  containsPoint: _containsPoint,
  contains,
  INIT_BOUNDS
};
var vtkBoundingBox = _objectSpread$9({
  newInstance: newInstance$C
}, STATIC$2);
var StructuredType$1 = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9
};
var Constants$5 = {
  StructuredType: StructuredType$1
};
function ownKeys$8(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var StructuredType = Constants$5.StructuredType;
function getDataDescriptionFromExtent(inExt) {
  var dataDim = 0;
  for (var i = 0; i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType.XZ_PLANE;
    }
    return StructuredType.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType.Y_LINE;
    }
    return StructuredType.Z_LINE;
  }
  return StructuredType.SINGLE_POINT;
}
var vtkStructuredData = _objectSpread$8({
  getDataDescriptionFromExtent
}, Constants$5);
var vtkErrorMacro$7 = macro.vtkErrorMacro;
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro$7("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    var extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    var changeDetected = model.extent.some(function(item, index2) {
      return item !== extentArray[index2];
    });
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    var i;
    var j;
    var k;
    if (model.deleted) {
      vtkErrorMacro$7("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      var array = arguments.length <= 0 ? void 0 : arguments[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? void 0 : arguments[0];
      j = arguments.length <= 1 ? void 0 : arguments[1];
      k = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      vtkErrorMacro$7("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = function() {
    return [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  };
  publicAPI.getNumberOfCells = function() {
    var dims = publicAPI.getDimensions();
    var nCells = 1;
    for (var i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = function() {
    var dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = function(index2) {
    var dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro$7("Requesting a point from an empty image.");
      return null;
    }
    var ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType$1.EMPTY:
        return null;
      case StructuredType$1.SINGLE_POINT:
        break;
      case StructuredType$1.X_LINE:
        ijk[0] = index2;
        break;
      case StructuredType$1.Y_LINE:
        ijk[1] = index2;
        break;
      case StructuredType$1.Z_LINE:
        ijk[2] = index2;
        break;
      case StructuredType$1.XY_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0];
        break;
      case StructuredType$1.YZ_PLANE:
        ijk[1] = index2 % dims[1];
        ijk[2] = index2 / dims[1];
        break;
      case StructuredType$1.XZ_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[2] = index2 / dims[0];
        break;
      case StructuredType$1.XYZ_GRID:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0] % dims[1];
        ijk[2] = index2 / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro$7("Invalid dataDescription");
        break;
    }
    var coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = function() {
    return publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  };
  publicAPI.extentToBounds = function(ex) {
    var corners = [[ex[0], ex[2], ex[4]], [ex[1], ex[2], ex[4]], [ex[0], ex[3], ex[4]], [ex[1], ex[3], ex[4]], [ex[0], ex[2], ex[5]], [ex[1], ex[2], ex[5]], [ex[0], ex[3], ex[5]], [ex[1], ex[3], ex[5]]];
    var bounds = _toConsumableArray(vtkBoundingBox.INIT_BOUNDS);
    var vout = [];
    for (var i = 0; i < 8; ++i) {
      publicAPI.indexToWorld(corners[i], vout);
      vtkBoundingBox.addPoint.apply(vtkBoundingBox, [bounds].concat(vout));
    }
    return bounds;
  };
  publicAPI.getSpatialExtent = function() {
    return vtkBoundingBox.inflate(_toConsumableArray(model.extent), 0.5);
  };
  publicAPI.computeTransforms = function() {
    fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    scale$2(model.indexToWorld, model.indexToWorld, model.spacing);
    invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.setDirection = function() {
    if (model.deleted) {
      vtkErrorMacro$7("instance deleted - cannot call any method");
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var array = args;
    if (array.length === 1 && (Array.isArray(array[0]) || array[0].constructor === Float32Array || array[0].constructor === Float64Array)) {
      array = array[0];
    }
    if (array.length !== 9) {
      throw new RangeError("Invalid number of values for array setter");
    }
    var changeDetected = false;
    model.direction.forEach(function(item, index2) {
      if (item !== array[index2]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });
    if (changeDetected) {
      for (var i = 0; i < 9; ++i) {
        model.direction[i] = array[i];
      }
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.indexToWorld = function(ain) {
    var aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    transformMat4$1(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    var aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    transformMat4$1(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin) {
    var bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var in1 = [0, 0, 0];
    var in2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bin, in1, in2);
    var out1 = [0, 0, 0];
    var out2 = [0, 0, 0];
    transformMat4$1(out1, in1, model.indexToWorld);
    transformMat4$1(out2, in2, model.indexToWorld);
    return computeBoundsFromPoints(out1, out2, bout);
  };
  publicAPI.worldToIndexBounds = function(bin) {
    var bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var in1 = [0, 0, 0];
    var in2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bin, in1, in2);
    var out1 = [0, 0, 0];
    var out2 = [0, 0, 0];
    transformMat4$1(out1, in1, model.worldToIndex);
    transformMat4$1(out2, in2, model.worldToIndex);
    return computeBoundsFromPoints(out1, out2, bout);
  };
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();
  publicAPI.getCenter = function() {
    return vtkBoundingBox.getCenter(publicAPI.getBounds());
  };
  publicAPI.computeHistogram = function(worldBounds) {
    var voxelFunc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    var point1 = [0, 0, 0];
    var point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    var dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    var yStride = dimensions[0];
    var zStride = dimensions[0] * dimensions[1];
    var pixels = publicAPI.getPointData().getScalars().getData();
    var maximum = -Infinity;
    var minimum = Infinity;
    var sumOfSquares = 0;
    var isum = 0;
    var inum = 0;
    for (var z = point1[2]; z <= point2[2]; z++) {
      for (var y = point1[1]; y <= point2[1]; y++) {
        var index2 = point1[0] + y * yStride + z * zStride;
        for (var x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {
            var pixel = pixels[index2];
            if (pixel > maximum)
              maximum = pixel;
            if (pixel < minimum)
              minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index2;
        }
      }
    }
    var average = inum > 0 ? isum / inum : 0;
    var variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    var sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent) {
    var numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var increments = [];
    var incr = numberOfComponents;
    for (var idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = function(_ref) {
    var _ref2 = _slicedToArray(_ref, 3), i = _ref2[0], j = _ref2[1], k = _ref2[2];
    var extent = publicAPI.getExtent();
    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    var increments = publicAPI.computeIncrements(extent, numberOfComponents);
    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = function(xyz) {
    var extent = publicAPI.getExtent();
    var index2 = publicAPI.worldToIndex(xyz);
    for (var idx = 0; idx < 3; ++idx) {
      if (index2[idx] < extent[idx * 2] || index2[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro$7("GetScalarPointer: Pixel ".concat(index2, " is not in memory. Current extent = ").concat(extent));
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index2);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    var comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro$7("GetScalarPointer: Scalar Component ".concat(comp, " is not within bounds. Current Scalar numberOfComponents: ").concat(numberOfComponents));
      return NaN;
    }
    var offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
}
var DEFAULT_VALUES$C = {
  direction: null,
  indexToWorld: null,
  worldToIndex: null,
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: StructuredType$1.EMPTY
};
function extend$D(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$C, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = identity$2(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["direction", "indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var newInstance$B = macro.newInstance(extend$D, "vtkImageData");
var vtkImageData$1 = {
  newInstance: newInstance$B,
  extend: extend$D
};
var resolveCoincidentTopologyPolygonOffsetFaces = 1;
var resolveCoincidentTopology = 0;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  resolveCoincidentTopologyPolygonOffsetFaces = value;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  resolveCoincidentTopology = mode;
}
function setResolveCoincidentTopologyToDefault() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToOff() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  setResolveCoincidentTopology(1);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods$1 = {
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach(function(item) {
    publicAPI["get".concat(item.method)] = function() {
      return model[item.key];
    };
    publicAPI["set".concat(item.method)] = function(factor, offset) {
      model[item.key] = {
        factor,
        offset
      };
    };
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var staticOffsetAPI$1 = {};
addCoincidentTopologyMethods(staticOffsetAPI$1, staticOffsetModel, CATEGORIES.map(function(key) {
  return {
    key,
    method: "ResolveCoincidentTopology".concat(key, "OffsetParameters")
  };
}));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods$1).forEach(function(methodName) {
    publicAPI[methodName] = otherStaticMethods$1[methodName];
  });
  Object.keys(staticOffsetAPI$1).forEach(function(methodName) {
    publicAPI[methodName] = staticOffsetAPI$1[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(function(key) {
    return {
      key,
      method: "RelativeCoincidentTopology".concat(key, "OffsetParameters")
    };
  }));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = function() {
    var globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyPolygonOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = function() {
    var globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyLineOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = function() {
    var globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyPointOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI: staticOffsetAPI$1,
  otherStaticMethods: otherStaticMethods$1,
  CATEGORIES
};
var CoordinateSystem$1 = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants$4 = {
  CoordinateSystem: CoordinateSystem$1
};
function ownKeys$7(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var CoordinateSystem = Constants$4.CoordinateSystem;
function notImplemented(method) {
  return function() {
    return macro.vtkErrorMacro("vtkProp::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = function() {
    var m1 = model.mtime;
    for (var index2 = 0; index2 < model.textures.length; ++index2) {
      var m2 = model.textures[index2].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = function(selector, pixeloffsets) {
  };
  publicAPI.getNestedProps = function() {
    return null;
  };
  publicAPI.getActors = function() {
    return [];
  };
  publicAPI.getActors2D = function() {
    return [];
  };
  publicAPI.getVolumes = function() {
    return [];
  };
  publicAPI.pick = notImplemented("pick");
  publicAPI.hasKey = notImplemented("hasKey");
  publicAPI.getNestedVisibility = function() {
    return model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  };
  publicAPI.getNestedPickable = function() {
    return model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  };
  publicAPI.getNestedDragable = function() {
    return model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  };
  publicAPI.getRedrawMTime = function() {
    return model.mtime;
  };
  publicAPI.setEstimatedRenderTime = function(t) {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = function() {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = function(t) {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = function(t) {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = function() {
    return false;
  };
  publicAPI.getTextures = function() {
    return model.textures;
  };
  publicAPI.hasTexture = function(texture) {
    return model.textures.indexOf(texture) !== -1;
  };
  publicAPI.addTexture = function(texture) {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = function(texture) {
    var newTextureList = model.textures.filter(function(item) {
      return item !== texture;
    });
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = function() {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = function() {
    return publicAPI.setCoordinateSystem(CoordinateSystem.WORLD);
  };
  publicAPI.setCoordinateSystemToDisplay = function() {
    return publicAPI.setCoordinateSystem(CoordinateSystem.DISPLAY);
  };
}
var DEFAULT_VALUES$B = {
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend$C(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$B, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance$A = macro.newInstance(extend$C, "vtkProp");
var vtkProp$1 = _objectSpread$7({
  newInstance: newInstance$A,
  extend: extend$C
}, Constants$4);
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = function(shaders, ren, actor) {
    var cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      var FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset
};
var SlicingMode$3 = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants$3 = {
  SlicingMode: SlicingMode$3
};
var InterpolationType$3 = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants$2 = {
  InterpolationType: InterpolationType$3
};
var vtkErrorMacro$6 = vtkErrorMacro$j;
var SlicingMode$2 = Constants$3.SlicingMode;
function computeFnToString$1(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = function(ren, actor) {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = function() {
    var actor = model.openGLImageSlice.getRenderable();
    var ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    var tNumComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      "uniform float cshift0;",
      "uniform float cscale0;",
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;"
    ];
    if (iComps) {
      for (var comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          "uniform float cshift".concat(comp, ";"),
          "uniform float cscale".concat(comp, ";"),
          "uniform float pwfshift".concat(comp, ";"),
          "uniform float pwfscale".concat(comp, ";")
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro$6("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    if (iComps) {
      var rgba = ["r", "g", "b", "a"];
      var tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (var _comp = 0; _comp < tNumComp; _comp++) {
        tcoordImpl = tcoordImpl.concat(["vec3 tcolor".concat(_comp, " = mix").concat(_comp, " * texture2D(colorTexture1, vec2(tvalue.").concat(rgba[_comp], " * cscale").concat(_comp, " + cshift").concat(_comp, ", height").concat(_comp, ")).rgb;"), "float compWeight".concat(_comp, " = mix").concat(_comp, " * texture2D(pwfTexture1, vec2(tvalue.").concat(rgba[_comp], " * pwfscale").concat(_comp, " + pwfshift").concat(_comp, ", height").concat(_comp, ")).r;")]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro$6("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["float intensity = texture2D(texture1, tcoordVCVSOutput).r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        case 3:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro$j("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var tNumComp = model.openGLTexture.getComponents();
    var iComp = actor.getProperty().getIndependentComponents();
    var needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {
      needRebuild = true;
      model.lastRenderPassShaderReplacement = null;
    }
    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro$6("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro$6("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    var texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    var numComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (var i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    var oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (var _i = 0; _i < numComp; _i++) {
      var cw = actor.getProperty().getColorWindow();
      var cl = actor.getProperty().getColorLevel();
      var target = iComps ? _i : 0;
      var cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        var cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      var scale2 = oglShiftScale.scale / cw;
      var shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf("cshift".concat(_i), shift);
      cellBO.getProgram().setUniformf("cscale".concat(_i), scale2);
    }
    for (var _i2 = 0; _i2 < numComp; _i2++) {
      var pwfScale = 1;
      var pwfShift = 0;
      var _target = iComps ? _i2 : 0;
      var pwfun = actor.getProperty().getPiecewiseFunction(_target);
      if (pwfun) {
        var pwfRange = pwfun.getRange();
        var length2 = pwfRange[1] - pwfRange[0];
        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length2;
        pwfShift = (oglShiftScale.shift - mid) / length2 + 0.5;
      }
      cellBO.getProgram().setUniformf("pwfshift".concat(_i2), pwfShift);
      cellBO.getProgram().setUniformf("pwfscale".concat(_i2), pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      var cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    var texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    var texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro$j("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      var mat = inverseShiftScaleMatrix ? copy$1(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        transpose(mat, mat);
        multiply$2(mat, mat, inverseShiftScaleMatrix);
        transpose(mat, mat);
      }
      transpose(model.imagemat, model.currentInput.getIndexToWorld());
      multiply$2(model.imagematinv, mat, model.imagemat);
      var planeEquations = [];
      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {
        var planeEquation2 = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation2);
        for (var j = 0; j < 4; j++) {
          planeEquations.push(planeEquation2[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var actMats = model.openGLImageSlice.getKeyMatrices();
    var image = model.currentInput;
    var i2wmat4 = image.getIndexToWorld();
    multiply$2(model.imagemat, actMats.mcwc, i2wmat4);
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    multiply$2(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      multiply$2(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var ppty = actor.getProperty();
    var opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro$6("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    var actorProperty = actor.getProperty();
    var iType = actorProperty.getInterpolationType();
    if (iType === InterpolationType$3.NEAREST) {
      model.colorTexture.setMinificationFilter(Filter$1.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter$1.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter$1.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter$1.NEAREST);
    } else {
      model.colorTexture.setMinificationFilter(Filter$1.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter$1.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter$1.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter$1.LINEAR);
    }
    var numComp = imgScalars.getNumberOfComponents();
    var iComps = actorProperty.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var textureHeight = iComps ? 2 * numIComps : 1;
    var cfunToString = computeFnToString$1(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      var cWidth = 1024;
      var cSize = cWidth * textureHeight * 3;
      var cTable = new Uint8Array(cSize);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(cWidth * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (var i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {
              cTable[c * cWidth * 6 + _i4] = 255 * tmpTable[_i4];
            }
          }
        }
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes$3.UNSIGNED_CHAR, cTable);
      } else {
        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {
          cTable[_i5] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 1] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 2] = 255 * _i5 / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes$3.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = cfunToString;
    }
    var pwfunToString = computeFnToString$1(actorProperty, actorProperty.getPiecewiseFunction, numIComps);
    if (model.pwfTextureString !== pwfunToString) {
      var pwfWidth = 1024;
      var pwfSize = pwfWidth * textureHeight;
      var pwfTable = new Uint8Array(pwfSize);
      var pwfun = actorProperty.getPiecewiseFunction();
      model.pwfTexture.resetFormatAndType();
      if (pwfun) {
        var pwfFloatTable = new Float32Array(pwfSize);
        var _tmpTable = new Float32Array(pwfWidth);
        for (var _c = 0; _c < numIComps; ++_c) {
          pwfun = actorProperty.getPiecewiseFunction(_c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            var pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1);
            if (iComps) {
              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];
                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];
              }
            } else {
              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];
              }
            }
          }
        }
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes$3.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes$3.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = pwfunToString;
    }
    var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
    var slice2 = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice2 = model.renderable.getSliceAtPosition(slice2);
    }
    var nSlice = Math.round(slice2);
    var ext = image.getExtent();
    var sliceOffset;
    if (ijkMode === SlicingMode$2.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode$2.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode$2.K || ijkMode === SlicingMode$2.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    var toString2 = "".concat(slice2, "A").concat(image.getMTime(), "A").concat(imgScalars.getMTime(), "B").concat(publicAPI.getMTime(), "C").concat(model.renderable.getSlicingMode(), "D").concat(actor.getProperty().getMTime());
    if (model.VBOBuildString !== toString2) {
      var dims = image.getDimensions();
      if (iType === InterpolationType$3.NEAREST) {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter$1.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter$1.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter$1.NEAREST);
      } else {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter$1.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter$1.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap$1.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap$1.CLAMP_TO_EDGE);
      var sliceSize = dims[0] * dims[1] * numComp;
      var ptsArray = new Float32Array(12);
      var tcoordArray = new Float32Array(8);
      for (var _i8 = 0; _i8 < 4; _i8++) {
        tcoordArray[_i8 * 2] = _i8 % 2 ? 1 : 0;
        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1 : 0;
      }
      var sliceDepth = [SlicingMode$2.X, SlicingMode$2.Y, SlicingMode$2.Z].includes(model.renderable.getSlicingMode()) ? slice2 : nSlice;
      var spatialExt = image.getSpatialExtent();
      var basicScalars = imgScalars.getData();
      var scalars = null;
      if (ijkMode === SlicingMode$2.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        var id = 0;
        for (var k = 0; k < dims[2]; k++) {
          for (var j = 0; j < dims[1]; j++) {
            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode$2.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        var _id = 0;
        for (var _k = 0; _k < dims[2]; _k++) {
          for (var _i9 = 0; _i9 < dims[0]; _i9++) {
            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;
            _id = (_k * dims[0] + _i9) * numComp;
            scalars.set(basicScalars.subarray(_bsIdx, _bsIdx + numComp), _id);
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode$2.K || ijkMode === SlicingMode$2.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro$6("Reformat slicing not yet supported.");
      }
      model.openGLTexture.create2DFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars);
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation$2.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString2;
    }
  };
}
var DEFAULT_VALUES$A = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
};
function extend$B(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$A, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.pwfTexture = vtkOpenGLTexture$1.newInstance();
  model.imagemat = identity$1(new Float64Array(16));
  model.imagematinv = identity$1(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var newInstance$z = newInstance$X(extend$B, "vtkOpenGLImageMapper");
registerOverride$1("vtkImageMapper", newInstance$z);
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaqueZBufferPass = function(renderPass) {
    publicAPI.traverseOpaquePass(renderPass);
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    return publicAPI.opaquePass(prepass, renderPass);
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      copy$1(model.keyMatrices.mcwc, model.renderable.getMatrix());
      transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES$z = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend$A(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$z, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: identity$1(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var newInstance$y = newInstance$X(extend$A, "vtkOpenGLImageSlice");
registerOverride$1("vtkImageSlice", newInstance$y);
var vtkDebugMacro$5 = vtkDebugMacro$8;
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = function(prepass, renderPass) {
    model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model.openGLRenderer.getParent();
    var aspectRatio = model.openGLRenderer.getAspectRatio();
    var camera = model.openGLRenderer ? model.openGLRenderer.getRenderable().getActiveCamera() : null;
    var tsize = model.openGLRenderer.getTiledSizeAndOrigin();
    var texels = null;
    if (model.renderable.getUseZValues()) {
      var zbt = renderPass.getZBufferTexture();
      var width = Math.floor(zbt.getWidth());
      var height = Math.floor(zbt.getHeight());
      var gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      var fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro$5("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
var DEFAULT_VALUES$y = {};
function extend$z(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$y, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance$x = newInstance$X(extend$z, "vtkOpenGLPixelSpaceCallbackMapper");
registerOverride$1("vtkPixelSpaceCallbackMapper", newInstance$x);
var vtkDebugMacro$4 = vtkDebugMacro$8;
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = function() {
    var count = 0;
    var lights = model.renderable.getLightsByReference();
    for (var index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro$4("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      var clearMask = 0;
      var gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      var ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.cameraPass = function(prepass) {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = function() {
    var size2 = model._parent.getSizeByReference();
    var viewport = model.renderable.getViewportByReference();
    return size2[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size2[1]);
  };
  publicAPI.getTiledSizeAndOrigin = function() {
    var vport = model.renderable.getViewportByReference();
    var tileViewPort = [0, 0, 1, 1];
    var vpu = vport[0] - tileViewPort[0];
    var vpv = vport[1] - tileViewPort[1];
    var ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    var lowerLeftU = Math.round(ndvp[0]);
    var lowerLeftV = Math.round(ndvp[1]);
    var vpu2 = vport[2] - tileViewPort[0];
    var vpv2 = vport[3] - tileViewPort[1];
    var ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    var usize = Math.round(ndvp2[0]) - lowerLeftU;
    var vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = function() {
    var clearMask = 0;
    var gl = model.context;
    if (!model.renderable.getTransparent()) {
      var background = model.renderable.getBackgroundByReference();
      model.context.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      model.context.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    var ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES$x = {
  context: null,
  selector: null
};
function extend$y(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$x, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var newInstance$w = newInstance$X(extend$y, "vtkOpenGLRenderer");
registerOverride$1("vtkRenderer", newInstance$w);
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      copy$1(model.MCWCMatrix, model.renderable.getMatrix());
      transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        identity$2(model.normalMatrix);
      } else {
        fromMat4(model.normalMatrix, model.MCWCMatrix);
        invert$1(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
var DEFAULT_VALUES$w = {};
function extend$x(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$w, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var newInstance$v = newInstance$X(extend$x, "vtkOpenGLVolume");
registerOverride$1("vtkVolume", newInstance$v);
var InterpolationType$2 = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
var OpacityMode$1 = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
var Constants$1 = {
  InterpolationType: InterpolationType$2,
  OpacityMode: OpacityMode$1
};
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";
var vtkVolumeFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define vtkIndependentComponents
//VTK::IndependentComponentsOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

#ifdef vtkImageLabelOutlineOn
uniform int outlineThickness;
uniform float outlineOpacity;
uniform float vpWidth;
uniform float vpHeight;
uniform float vpOffsetX;
uniform float vpOffsetY;
uniform mat4 PCWCMatrix;
uniform mat4 vWCtoIDX;
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents >= 3
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#endif
#if vtkNumComponents >= 4
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

// jitter texture
uniform sampler2D jtexture;

// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;

// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef vtkIndependentComponentsOn
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);
#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.a = tmp.g;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if vtkLightComplexity > 0
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 + 
         posVC.y * vPlaneNormal2 + 
         posVC.z * vPlaneNormal4 + 
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));  
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));  
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
#if defined(vtkGradientOpacityOn)
  return clamp(normalMag * goscale + goshift, gomin, gomax);
#else
  return 1.0;
#endif
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkComputeNormalFromOpacity
    #ifdef vtkGradientOpacityOn
      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out mat3 scalarInterp, out vec3 secondaryGradientMag)
      {
        vec4 result;
        scalarInterp[0][0] = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a;
        scalarInterp[0][1] = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a;
        scalarInterp[0][2] = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a;
        // look up scalar values for computing secondary gradient
        scalarInterp[1][0] = getTextureValue(pos + vec3(2.0*tstep.x, 0.0, 0.0)).a;
        scalarInterp[1][1] = getTextureValue(pos + vec3(0.0, 2.0*tstep.y, 0.0)).a;
        scalarInterp[1][2] = getTextureValue(pos + vec3(0.0, 0.0, 2.0*tstep.z)).a;
        scalarInterp[2][0] = getTextureValue(pos + vec3(tstep.x, tstep.y, 0.0)).a;
        scalarInterp[2][1] = getTextureValue(pos + vec3(tstep.x, 0.0, tstep.z)).a;
        scalarInterp[2][2] = getTextureValue(pos + vec3(0.0, tstep.y, tstep.z)).a;
        result.x = scalarInterp[0][0] - scalar;
        result.y = scalarInterp[0][1] - scalar;
        result.z = scalarInterp[0][2] - scalar;
        // divide by spacing
        result.xyz /= vSpacing;
        result.w = length(result.xyz);
        rotateToViewCoord(result.xyz);
        secondaryGradientMag.x = length(vec3(scalarInterp[1][0] - scalarInterp[0][0],
                                             scalarInterp[2][0] - scalarInterp[0][0],
                                             scalarInterp[2][1] - scalarInterp[0][0]) / vSpacing);
        secondaryGradientMag.y = length(vec3(scalarInterp[2][0] - scalarInterp[0][1],
                                             scalarInterp[1][1] - scalarInterp[0][1],
                                             scalarInterp[2][2] - scalarInterp[0][1]) / vSpacing);
        secondaryGradientMag.z = length(vec3(scalarInterp[2][1] - scalarInterp[0][2],
                                             scalarInterp[2][2] - scalarInterp[0][2],
                                             scalarInterp[1][2] - scalarInterp[0][2]) / vSpacing);
        if (length(result.xyz) > 0.0) {
          return vec4(normalize(result.xyz),result.w);
        } else {
          return vec4(0.0);
        }
      }

      vec4 computeDensityNormal(float scalar, float gradientMag, mat3 scalarInterp, vec3 secondaryGradientMag)
      {
        vec4 opacityG;
        vec3 opacityInterp = vec3(0.0);
        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r;
        if (gradientMag >= 0.0){
          opacity *= computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);
        }
        opacityInterp.x = texture2D(otexture, vec2(scalarInterp[0][0] * oscale0 + oshift0, 0.5)).r; 
        if (secondaryGradientMag.x >= 0.0){
          opacityInterp.x *= computeGradientOpacityFactor(secondaryGradientMag.x, goscale0, goshift0, gomin0, gomax0);
        }
    
        opacityInterp.y = texture2D(otexture, vec2(scalarInterp[0][1] * oscale0 + oshift0, 0.5)).r;
        if (secondaryGradientMag.y >= 0.0){
          opacityInterp.y *= computeGradientOpacityFactor(secondaryGradientMag.y, goscale0, goshift0, gomin0, gomax0);
        }

        opacityInterp.z = texture2D(otexture, vec2(scalarInterp[0][2] * oscale0 + oshift0, 0.5)).r;
        if (secondaryGradientMag.z >= 0.0){
          opacityInterp.z *= computeGradientOpacityFactor(secondaryGradientMag.z, goscale0, goshift0, gomin0, gomax0);
        }

        opacityG.xyz = opacityInterp - vec3(opacity,opacity,opacity);
        // divide by spacing
        opacityG.xyz /= vSpacing;
        opacityG.w = length(opacityG.xyz);
        rotateToViewCoord(opacityG.xyz);
        if (length(opacityG.xyz) > 0.0) {  
          return vec4(normalize(opacityG.xyz),opacityG.w);
        } else {
          return vec4(0.0);
        }
      } 

    #else
    //if gradient opacity not on but using density gradient
      vec4 computeDensityNormal(float scalar, vec3 scalarInterp) 
      { 
        vec4 opacityG; 
        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r; 
        opacityG.x = texture2D(otexture, vec2(scalarInterp.x * oscale0 + oshift0, 0.5)).r - opacity; 
        opacityG.y = texture2D(otexture, vec2(scalarInterp.y * oscale0 + oshift0, 0.5)).r - opacity; 
        opacityG.z = texture2D(otexture, vec2(scalarInterp.z * oscale0 + oshift0, 0.5)).r - opacity; 
        // divide by spacing 
        opacityG.xyz /= vSpacing; 
        opacityG.w = length(opacityG.xyz); 
        // rotate to View Coords 
        rotateToViewCoord(opacityG.xyz);
        if (length(opacityG.xyz) > 0.0) {     
          return vec4(normalize(opacityG.xyz),opacityG.w); 
        } else { 
          return vec4(0.0); 
        } 
      } 
      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out vec3 scalarInterp) 
      { 
        vec4 result; 
        scalarInterp.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a; 
        scalarInterp.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a; 
        scalarInterp.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a; 
        result.x = scalarInterp.x - scalar; 
        result.y = scalarInterp.y - scalar; 
        result.z = scalarInterp.z - scalar;   
        // divide by spacing
        result.xyz /= vSpacing;
        result.w = length(result.xyz); 
        // rotate to View Coords 
        rotateToViewCoord(result.xyz);      
        if (length(result.xyz) > 0.0) {     
          return vec4(normalize(result.xyz),result.w); 
        } else { 
          return vec4(0.0); 
        } 
      }           
    #endif
  #endif
  // compute scalar density
  vec4 computeNormal(vec3 pos, float scalar, vec3 tstep)  
  {  
    vec4 result;  
    result.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a - scalar;  
    result.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a - scalar;  
    result.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a - scalar;  
    // divide by spacing  
    result.xyz /= vSpacing;  
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords  
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);  
    } else {
      return vec4(0.0);
    }
  }  
#endif

#ifdef vtkImageLabelOutlineOn
vec3 fragCoordToIndexSpace(vec4 fragCoord) {
  vec4 pcPos = vec4(
    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
    (fragCoord.z - 0.5) * 2.0,
    1.0);

  vec4 worldCoord = PCWCMatrix * pcPos;
  vec4 vertex = (worldCoord/worldCoord.w);

  vec3 index = (vWCtoIDX * vertex).xyz;

  // half voxel fix for labelmapOutline 
  return (index + vec3(0.5)) / vec3(volumeDimensions);
}
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{ 
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 0.8 and 1.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(0.8, 1.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;
  
  // in case the first sample near surface has a very tiled light ray, we need to offset start position 
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;  

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;  
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;
  
  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  vec4 scalar = vec4(0.0);
  float maxdist = hit.tmax;
  if(maxdist < EPSILON) {
    return 1.0;
  }

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);

  // support gradient opacity
  #ifdef vtkGradientOpacityOn
    vec4 normal;
  #endif

  vec3 current_step = sampleDistanceISVS_jitter * lightDirNormIS;
  float maxSteps = ceil(maxdist/sampleDistanceISVS_jitter);
  float opacityDelta = 0.0;

  for (float i = 0.0; i < maxSteps; i++)
  {
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #ifdef vtkGradientOpacityOn 
      normal = computeNormal(posIS, scalar.a, vec3(1.0/vec3(volumeDimensions))); 
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif    
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    // optimization: increase/decrease sample distance based on changed in opacity value
    opacityDelta = opacityPrev - opacity;
    opacityPrev = opacity;
    if (opacityDelta > 0.0){
      current_step *= 0.9;
    } else if (opacityDelta < 0.0){
      current_step *= 1.1;
    }
    posIS += current_step;
  }

  return shadow;  
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;     
    secondary_contrib += tColor * vAmbient;
  } 
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float opacity, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && opacity > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0); 
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif        
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }  
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else 
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif    
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif      
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i]; 
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif          
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif          
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else 
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif 
  #endif
#endif

//=======================================================================
// Given a texture value compute the color and opacity
//
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{
#ifdef vtkImageLabelOutlineOn
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  if (float(tColor.a) > 0.01) {
    for (int i = -outlineThickness; i <= outlineThickness; i++) {
      for (int j = -outlineThickness; j <= outlineThickness; j++) {
        if (i == 0 || j == 0) {
          continue;
        }

        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
          gl_FragCoord.y + float(j),
          gl_FragCoord.z, gl_FragCoord.w);

        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
        vec4 value = getTextureValue(neighborPosIS);

        // If any of my neighbours are not the same value as I
        // am, this means I am on the border of the segment.
        // We can break the loops
        if (any(notEqual(value, centerValue))) {
          pixelOnBorder = true;
          break;
        }
      }

      if (pixelOnBorder == true) {
        break;
      }
    }

    // If I am on the border, I am displayed at full opacity
    if (pixelOnBorder == true) {
      tColor.a = outlineOpacity;
    }
  }

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4
  //
  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);

  // compute the normal vectors as needed
  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #if !defined(vtkComponent0Proportional)
        vec4 normal0 = normalMat[0];
      #endif
      #if !defined(vtkComponent1Proportional)
        vec4 normal1 = normalMat[1];
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          vec4 normal2 = normalMat[2];
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            vec4 normal3 = normalMat[3];
          #endif
        #endif
      #endif
    #else
      vec4 normalLight;
      #ifdef vtkComputeNormalFromOpacity
        #ifdef vtkGradientOpacityOn
          mat3 scalarInterp;  
          vec3 secondaryGradientMag;  
          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp, secondaryGradientMag);  
          normalLight = computeDensityNormal(tValue.a, normal0.w, scalarInterp,secondaryGradientMag);       
          if (length(normalLight) == 0.0){  
            normalLight = normal0;   
          }                      
        #else
          vec3 scalarInterp;  
          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp);  
          if (length(normal0)>0.0){  
            normalLight = computeDensityNormal(tValue.a,scalarInterp);  
            if (length(normalLight)==0.0){  
              normalLight = normal0;  
            }  
          }                
        #endif
      #else 
        vec4 normal0 = computeNormal(posIS, tValue.a, tstep);  
        normalLight = normal0;             
      #endif
    #endif
  #endif

  // compute gradient opacity factors as needed
  #if defined(vtkGradientOpacityOn)
    #if !defined(vtkComponent0Proportional)
      goFactor.x =
        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #endif
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      #if !defined(vtkComponent1Proportional)
        goFactor.y =
          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          goFactor.z =
            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            goFactor.w =
              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);
          #endif
        #endif
      #endif
    #endif
  #endif

  // single component is always independent
  #if vtkNumComponents == 1
    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
    if (tColor.a < EPSILON){
      return vec4(0.0);
    }    
  #endif

  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));
    #if !defined(vtkComponent0Proportional)
      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
      tColor *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));
    #endif

    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
    #if !defined(vtkComponent1Proportional)
      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
      tColor1 *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));
    #endif

    #if vtkNumComponents >= 3
      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
      #if !defined(vtkComponent2Proportional)
        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
      #else
        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
        tColor2 *= pwfValue;
        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));
      #endif

      #if vtkNumComponents >= 4
        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
        #if !defined(vtkComponent3Proportional)
          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #else
          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
          tColor3 *= pwfValue;
          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));
        #endif
      #endif
    #endif
  #else // then not independent

  #if vtkNumComponents == 2
    float lum = tValue.r * cscale0 + cshift0;
    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    vec4 tColor = vec4(lum, lum, lum, alpha);
  #endif
  #if vtkNumComponents == 3
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
  #endif
  #if vtkNumComponents == 4
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
  #endif
  #endif // dependent

  // apply lighting if requested as appropriate
  #if vtkLightComplexity > 0
    #if !defined(vtkComponent0Proportional) 
      #if vtkNumComponents == 1
    
        #ifdef SurfaceShadowOn
            #if vtkLightComplexity < 3
                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);
            #else
                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));
            #endif
        #endif

        #ifdef VolumeShadowOn
          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);
          #ifdef SurfaceShadowOn
            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
          #else
            tColor.rgb = tColorVS;
          #endif
        #else
            tColor.rgb = tColorS;
        #endif
        
      #else
        applyLighting(tColor.rgb, normal0);
      #endif
    #endif

    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
      #if !defined(vtkComponent1Proportional)
        applyLighting(tColor1, normal1);
      #endif
    #if vtkNumComponents >= 3
      #if !defined(vtkComponent2Proportional)
        applyLighting(tColor2, normal2);
      #endif
    #if vtkNumComponents >= 4
      #if !defined(vtkComponent3Proportional)
        applyLighting(tColor3, normal3);
      #endif
    #endif
    #endif
    #endif
  #endif

// perform final independent blend as needed
#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
  tColor.rgb += tColor1;
#if vtkNumComponents >= 3
  tColor.rgb += tColor2;
#if vtkNumComponents >= 4
  tColor.rgb += tColor3;
#endif
#endif
#endif

#endif







return tColor;
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2
     if (val.r >= min.r && val.r <= max.r &&
        val.g >= min.g && val.g <= max.g) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3
    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
        all(lessThanEqual(val, ipScalarRangeMax))) {
      withinRange = true;
    }
  #endif
  return withinRange;
}

//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);

  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity * cscale0 + cshift0, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity * cscale0 + cshift0, 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;
function ownKeys$6(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var vtkWarningMacro$1 = vtkWarningMacro$7, vtkErrorMacro$5 = vtkErrorMacro$j;
function arrayEquals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  publicAPI.buildPass = function() {
    model.zBufferTexture = null;
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    if (prepass) {
      var zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.volumePass = function(prepass, renderPass) {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      var actor = model.openGLVolume.getRenderable();
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType$2.LINEAR) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result;
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
    }
    var numComp = model.scalarTexture.getComponents();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumComponents", "#define vtkNumComponents ".concat(numComp)).result;
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::IndependentComponentsOn", "#define vtkIndependentComponentsOn").result;
      var proportionalComponents = [];
      for (var nc = 0; nc < numComp; nc++) {
        if (actor.getProperty().getOpacityMode(nc) === OpacityMode$1.PROPORTIONAL) {
          proportionalComponents.push("#define vtkComponent".concat(nc, "Proportional"));
        }
      }
      if (proportionalComponents.length > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", proportionalComponents.join("\n")).result;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    set$1(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = length(vsize) / model.renderable.getSampleDistance();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumSamplesValue", "".concat(Math.ceil(maxSamples))).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LightComplexity", "#define vtkLightComplexity ".concat(model.lastLightComplexity)).result;
    if (model.lastLightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadowOn", "#define VolumeShadowOn").result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::SurfaceShadowOn", "#define SurfaceShadowOn").result;
      }
      if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::localAmbientOcclusionOn", "#define localAmbientOcclusionOn").result;
      }
    }
    model.gopacity = actor.getProperty().getUseGradientOpacity(0);
    for (var _nc = 1; iComps && !model.gopacity && _nc < numComp; ++_nc) {
      if (actor.getProperty().getUseGradientOpacity(_nc)) {
        model.gopacity = true;
      }
    }
    if (model.gopacity) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result;
    }
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkComputeNormalFromOpacity", "#define vtkComputeNormalFromOpacity").result;
    }
    if (model.zBufferTexture !== null) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpWidth;", "uniform float vpHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;", "zdepth = -zdepth/rayDir.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", "".concat(model.renderable.getBlendMode())).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = function(shaders, ren, actor) {
    if (model.lastLightComplexity === 0) {
      return;
    }
    var FSSource = shaders.Fragment;
    var lightNum = 0;
    ren.getLights().forEach(function(light) {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", ["uniform int lightNum;", "uniform bool twoSidedLighting;", "uniform vec3 lightColor[".concat(lightNum, "];"), "uniform vec3 lightDirectionVC[".concat(lightNum, "]; // normalized"), "uniform vec3 lightHalfAngleVC[".concat(lightNum, "];"), "//VTK::Light::Dec"], false).result;
    if (model.lastLightComplexity === 3) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", ["uniform vec3 lightPositionVC[".concat(lightNum, "];"), "uniform vec3 lightAttenuation[".concat(lightNum, "];"), "uniform float lightConeAngle[".concat(lightNum, "];"), "uniform float lightExponent[".concat(lightNum, "];"), "uniform int lightPositional[".concat(lightNum, "];")], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadow::Dec", ["uniform float volumetricScatteringBlending;", "uniform float giReach;", "uniform float volumeShadowSamplingDistFactor;", "uniform float anisotropy;", "uniform float anisotropy2;"], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LAO::Dec", ["uniform int kernelRadius;", "uniform vec2 kernelSample[".concat(model.renderable.getLAOKernelRadius(), "];"), "uniform int kernelSize;"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      var clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", ["uniform vec3 vClipPlaneNormals[6];", "uniform float vClipPlaneDistances[6];", "//VTK::ClipPlane::Dec"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", ["for(int i = 0; i < ".concat(clipPlaneSize, "; i++) {"), "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode$1.COMPOSITE_BLEND) {
      lightComplexity = 0;
      model.numberOfLights = 0;
      ren.getLights().forEach(function(light) {
        var status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    var needRebuild = false;
    if (model.lastLightComplexity !== lightComplexity) {
      model.lastLightComplexity = lightComplexity;
      needRebuild = true;
    }
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var usesProportionalComponents = false;
    var proportionalComponents = [];
    if (iComps) {
      for (var nc = 0; nc < numComp; nc++) {
        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));
      }
      if (proportionalComponents.length > 0) {
        usesProportionalComponents = true;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    set$1(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = length(vsize) / model.renderable.getSampleDistance();
    var state2 = {
      interpolationType: actor.getProperty().getInterpolationType(),
      useLabelOutline: actor.getProperty().getUseLabelOutline(),
      numComp,
      usesProportionalComponents,
      iComps,
      maxSamples,
      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      proportionalComponents
    };
    if (!model.previousState || model.previousState.interpolationType !== state2.interpolationType || model.previousState.useLabelOutline !== state2.useLabelOutline || model.previousState.numComp !== state2.numComp || model.previousState.usesProportionalComponents !== state2.usesProportionalComponents || model.previousState.iComps !== state2.iComps || model.previousState.maxSamples !== state2.maxSamples || model.previousState.useGradientOpacity !== state2.useGradientOpacity || model.previousState.blendMode !== state2.blendMode || !arrayEquals(model.previousState.proportionalComponents, state2.proportionalComponents)) {
      model.previousState = _objectSpread$6({}, state2);
      return true;
    }
    if (cellBO.getProgram() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {
      model.lastZBufferTexture = model.zBufferTexture;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro$5("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi("texture1", model.scalarTexture.getTextureUnit());
    program.setUniformf("sampleDistance", model.renderable.getSampleDistance());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var ipScalarRange = model.renderable.getIpScalarRange();
    var minVals = [];
    var maxVals = [];
    for (var i = 0; i < 4; i++) {
      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
    }
    program.setUniform4f("ipScalarRangeMin", minVals[0], minVals[1], minVals[2], minVals[3]);
    program.setUniform4f("ipScalarRangeMax", maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      var size2 = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf("vpWidth", size2[0]);
      program.setUniformf("vpHeight", size2[1]);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    var actMats = model.openGLVolume.getKeyMatrices();
    multiply$2(model.modelToView, keyMats.wcvc, actMats.mcwc);
    var program = cellBO.getProgram();
    var cam = model.openGLCamera.getRenderable();
    var crange = cam.getClippingRange();
    program.setUniformf("camThick", crange[1] - crange[0]);
    program.setUniformf("camNear", crange[0]);
    program.setUniformf("camFar", crange[1]);
    var bounds = model.currentInput.getBounds();
    var dims = model.currentInput.getDimensions();
    var pos = new Float64Array(3);
    var dir = new Float64Array(3);
    var dcxmin = 1;
    var dcxmax = -1;
    var dcymin = 1;
    var dcymax = -1;
    for (var i = 0; i < 8; ++i) {
      set$1(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      transformMat4$1(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        normalize$4(dir, pos);
        var t = -crange[0] / pos[2];
        scale$1(pos, dir, t);
      }
      transformMat4$1(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf("dcxmin", dcxmin);
    program.setUniformf("dcxmax", dcxmax);
    program.setUniformf("dcymin", dcymin);
    program.setUniformf("dcymax", dcymax);
    if (program.isUniformUsed("cameraParallel")) {
      program.setUniformi("cameraParallel", cam.getParallelProjection());
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    set$1(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f("vSpacing", spc[0], spc[1], spc[2]);
    set$1(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    transformMat4$1(pos, pos, model.modelToView);
    program.setUniform3f("vOriginVC", pos[0], pos[1], pos[2]);
    var i2wmat4 = model.currentInput.getIndexToWorld();
    multiply$2(model.idxToView, model.modelToView, i2wmat4);
    multiply$3(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    multiply$3(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirection());
    var maxSamples = length(vsize) / model.renderable.getSampleDistance();
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro$1("The number of steps required ".concat(Math.ceil(maxSamples), " is larger than the\n        specified maximum number of steps ").concat(model.renderable.getMaximumSamplesPerRay(), ".\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples."));
    }
    var vctoijk = new Float64Array(3);
    set$1(vctoijk, 1, 1, 1);
    divide(vctoijk, vctoijk, vsize);
    program.setUniform3f("vVCToIJK", vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i("volumeDimensions", dims[0], dims[1], dims[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      var volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf("texWidth", model.scalarTexture.getWidth());
      program.setUniformf("texHeight", model.scalarTexture.getHeight());
      program.setUniformi("xreps", volInfo.xreps);
      program.setUniformi("xstride", volInfo.xstride);
      program.setUniformi("ystride", volInfo.ystride);
    }
    var normal = new Float64Array(3);
    var pos2 = new Float64Array(3);
    for (var _i = 0; _i < 6; ++_i) {
      switch (_i) {
        case 1:
          set$1(normal, -1, 0, 0);
          set$1(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          set$1(normal, 0, 1, 0);
          set$1(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          set$1(normal, 0, -1, 0);
          set$1(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          set$1(normal, 0, 0, 1);
          set$1(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          set$1(normal, 0, 0, -1);
          set$1(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          set$1(normal, 1, 0, 0);
          set$1(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      transformMat3(normal, normal, model.idxNormalMatrix);
      transformMat4$1(pos2, pos2, model.idxToView);
      var dist3 = -1 * dot$1(pos2, normal);
      program.setUniform3f("vPlaneNormal".concat(_i), normal[0], normal[1], normal[2]);
      program.setUniformf("vPlaneDistance".concat(_i), dist3);
    }
    if (actor.getProperty().getUseLabelOutline()) {
      var image = model.currentInput;
      var worldToIndex = image.getWorldToIndex();
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      invert(model.projectionToWorld, keyMats.wcpc);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      var size2 = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size2[0]);
      program.setUniformf("vpHeight", size2[1]);
      var offset = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset[0] / size2[0]);
      program.setUniformf("vpOffsetY", offset[1] / size2[1]);
    }
    invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", model.projectionToView);
    if (model.lastLightComplexity === 0) {
      return;
    }
    var lightNum = 0;
    var lightColor = [];
    var lightDir = [];
    var halfAngle = [];
    ren.getLights().forEach(function(light) {
      var status = light.getSwitch();
      if (status > 0) {
        var dColor = light.getColor();
        var intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        var ldir = light.getDirection();
        set$1(normal, ldir[0], ldir[1], ldir[2]);
        transformMat3(normal, normal, keyMats.normalMatrix);
        normalize$4(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1);
        lightNum++;
      }
    });
    program.setUniformi("twoSidedLighting", ren.getTwoSidedLighting());
    program.setUniformi("lightNum", lightNum);
    program.setUniform3fv("lightColor", lightColor);
    program.setUniform3fv("lightDirectionVC", lightDir);
    program.setUniform3fv("lightHalfAngleVC", halfAngle);
    if (model.lastLightComplexity === 3) {
      lightNum = 0;
      var lightPositionVC = [];
      var lightAttenuation = [];
      var lightConeAngle = [];
      var lightExponent = [];
      var lightPositional = [];
      ren.getLights().forEach(function(light) {
        var status = light.getSwitch();
        if (status > 0) {
          var attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          var lp = light.getTransformedPosition();
          transformMat4$1(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv("lightPositionVC", lightPositionVC);
      program.setUniform3fv("lightAttenuation", lightAttenuation);
      program.setUniformfv("lightConeAngle", lightConeAngle);
      program.setUniformfv("lightExponent", lightExponent);
      program.setUniformiv("lightPositional", lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      program.setUniformf("giReach", model.renderable.getGlobalIlluminationReach());
      program.setUniformf("volumetricScatteringBlending", model.renderable.getVolumetricScatteringBlending());
      program.setUniformf("volumeShadowSamplingDistFactor", model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf("anisotropy", model.renderable.getAnisotropy());
      program.setUniformf("anisotropy2", Math.pow(model.renderable.getAnisotropy(), 2));
    }
    if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      var ks = model.renderable.getLAOKernelSize();
      program.setUniformi("kernelSize", ks);
      var kernelSample = [];
      for (var _i2 = 0; _i2 < ks; _i2++) {
        kernelSample[_i2 * 2] = Math.random() * 0.5;
        kernelSample[_i2 * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv("kernelSample", kernelSample);
      program.setUniformi("kernelRadius", model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    program.setUniformi("ctexture", model.colorTexture.getTextureUnit());
    program.setUniformi("otexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var vprop = actor.getProperty();
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps && numComp >= 2) {
      for (var i = 0; i < numComp; i++) {
        program.setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    for (var _i3 = 0; _i3 < numComp; _i3++) {
      var target = iComps ? _i3 : 0;
      var sscale = volInfo.scale[_i3];
      var ofun = vprop.getScalarOpacity(target);
      var oRange = ofun.getRange();
      var oscale = sscale / (oRange[1] - oRange[0]);
      var oshift = (volInfo.offset[_i3] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf("oshift".concat(_i3), oshift);
      program.setUniformf("oscale".concat(_i3), oscale);
      var cfun = vprop.getRGBTransferFunction(target);
      var cRange = cfun.getRange();
      program.setUniformf("cshift".concat(_i3), (volInfo.offset[_i3] - cRange[0]) / (cRange[1] - cRange[0]));
      program.setUniformf("cscale".concat(_i3), sscale / (cRange[1] - cRange[0]));
    }
    if (model.gopacity) {
      if (iComps) {
        for (var nc = 0; nc < numComp; ++nc) {
          var _sscale = volInfo.scale[nc];
          var useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            var gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            var gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf("gomin".concat(nc), gomin);
            program.setUniformf("gomax".concat(nc), gomax);
            var goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf("goscale".concat(nc), _sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf("goshift".concat(nc), -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf("gomin".concat(nc), 1);
            program.setUniformf("gomax".concat(nc), 1);
            program.setUniformf("goscale".concat(nc), 0);
            program.setUniformf("goshift".concat(nc), 1);
          }
        }
      } else {
        var _sscale2 = volInfo.scale[numComp - 1];
        var _gomin = vprop.getGradientOpacityMinimumOpacity(0);
        var _gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf("gomin0", _gomin);
        program.setUniformf("gomax0", _gomax);
        var _goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf("goscale0", _sscale2 * (_gomax - _gomin) / (_goRange[1] - _goRange[0]));
        program.setUniformf("goshift0", -_goRange[0] * (_gomax - _gomin) / (_goRange[1] - _goRange[0]) + _gomin);
      }
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      var labelOutlineThickness = actor.getProperty().getLabelOutlineThickness();
      var labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      program.setUniformi("outlineThickness", labelOutlineThickness);
      program.setUniformf("outlineOpacity", labelOutlineOpacity);
    }
    if (model.lastLightComplexity > 0) {
      program.setUniformf("vAmbient", vprop.getAmbient());
      program.setUniformf("vDiffuse", vprop.getDiffuse());
      program.setUniformf("vSpecular", vprop.getSpecular());
      program.setUniformf("vSpecularPower", vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = function(cellBO, ren, actor) {
    if (model.renderable.getClippingPlanes().length > 0) {
      var keyMats = model.openGLCamera.getKeyMatrices(ren);
      var clipPlaneNormals = [];
      var clipPlaneDistances = [];
      var clipPlanes = model.renderable.getClippingPlanes();
      var clipPlaneSize = clipPlanes.length;
      for (var i = 0; i < clipPlaneSize; ++i) {
        var clipPlaneNormal = clipPlanes[i].getNormal();
        var clipPlanePos = clipPlanes[i].getOrigin();
        transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        transformMat4$1(clipPlanePos, clipPlanePos, keyMats.wcvc);
        var clipPlaneDist = -1 * dot$1(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
      }
      var program = cellBO.getProgram();
      program.setUniform3fv("vClipPlaneNormals", clipPlaneNormals);
      program.setUniformfv("vClipPlaneDistances", clipPlaneDistances);
    }
  };
  publicAPI.delete = chain(function() {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = function() {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    var _model$openGLRenderer = model.openGLRenderer.getTiledSizeAndOrigin(), usize = _model$openGLRenderer.usize, vsize = _model$openGLRenderer.vsize;
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = function() {
    var _model$openGLRenderer2 = model.openGLRenderer.getTiledSizeAndOrigin(), lowerLeftU = _model$openGLRenderer2.lowerLeftU, lowerLeftV = _model$openGLRenderer2.lowerLeftV;
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    var rwi = ren.getVTKWindow().getInteractor();
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(function() {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          var frate = rwi.getRecentAnimationFrameRate();
          var adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
        var size3 = model._openGLRenderWindow.getFramebufferSize();
        model._smallViewportWidth = Math.ceil(size3[0] / Math.sqrt(model._lastScale));
        model._smallViewportHeight = Math.ceil(size3[1] / Math.sqrt(model._lastScale));
      });
    }
    if (model._useSmallViewport) {
      var size2 = model._openGLRenderWindow.getFramebufferSize();
      if (model._smallViewportHeight > size2[1]) {
        model._smallViewportHeight = size2[1];
      }
      if (model._smallViewportWidth > size2[0]) {
        model._smallViewportWidth = size2[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size2[0], size2[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        var fbSize = model.framebuffer.getSize();
        if (fbSize[0] !== size2[0] || fbSize[1] !== size2[1]) {
          model.framebuffer.create(size2[0], size2[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      var gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size2[0], model._smallViewportHeight / size2[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType$2.NEAREST) {
      model.scalarTexture.setMinificationFilter(Filter$1.NEAREST);
      model.scalarTexture.setMagnificationFilter(Filter$1.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Filter$1.LINEAR);
      model.scalarTexture.setMagnificationFilter(Filter$1.LINEAR);
    }
    model.lastBoundBO = null;
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"), "");
        var program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro$5("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      var size2 = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size2[0], size2[1]);
      var tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      var gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro$5("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    var vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      var oTable = new Uint8Array(32 * 32);
      for (var i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter$1.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter$1.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes$3.UNSIGNED_CHAR, oTable);
    }
    var numComp = scalars.getNumberOfComponents();
    var iComps = vprop.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var toString2 = "".concat(vprop.getMTime());
    if (model.opacityTextureString !== toString2) {
      var oWidth = 1024;
      var oSize = oWidth * 2 * numIComps;
      var ofTable = new Float32Array(oSize);
      var tmpTable = new Float32Array(oWidth);
      for (var c = 0; c < numIComps; ++c) {
        var ofun = vprop.getScalarOpacity(c);
        var opacityFactor = model.renderable.getSampleDistance() / vprop.getScalarOpacityUnitDistance(c);
        var oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (var _i4 = 0; _i4 < oWidth; ++_i4) {
          ofTable[c * oWidth * 2 + _i4] = 1 - Math.pow(1 - tmpTable[_i4], opacityFactor);
          ofTable[c * oWidth * 2 + _i4 + oWidth] = ofTable[c * oWidth * 2 + _i4];
        }
      }
      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.opacityTexture.setMinificationFilter(Filter$1.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter$1.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes$3.FLOAT, ofTable);
      } else {
        var _oTable = new Uint8Array(oSize);
        for (var _i5 = 0; _i5 < oSize; ++_i5) {
          _oTable[_i5] = 255 * ofTable[_i5];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes$3.UNSIGNED_CHAR, _oTable);
      }
      model.opacityTextureString = toString2;
    }
    toString2 = "".concat(vprop.getMTime());
    if (model.colorTextureString !== toString2) {
      var cWidth = 1024;
      var cSize = cWidth * 2 * numIComps * 3;
      var cTable = new Uint8Array(cSize);
      var _tmpTable = new Float32Array(cWidth * 3);
      for (var _c = 0; _c < numIComps; ++_c) {
        var cfun = vprop.getRGBTransferFunction(_c);
        var cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, _tmpTable, 1);
        for (var _i6 = 0; _i6 < cWidth * 3; ++_i6) {
          cTable[_c * cWidth * 6 + _i6] = 255 * _tmpTable[_i6];
          cTable[_c * cWidth * 6 + _i6 + cWidth * 3] = 255 * _tmpTable[_i6];
        }
      }
      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.colorTexture.setMinificationFilter(Filter$1.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter$1.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes$3.UNSIGNED_CHAR, cTable);
      model.colorTextureString = toString2;
    }
    toString2 = "".concat(image.getMTime());
    if (model.scalarTextureString !== toString2) {
      var dims = image.getDimensions();
      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], numComp, scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());
      model.scalarTextureString = toString2;
    }
    if (!model.tris.getCABO().getElementCount()) {
      var ptsArray = new Float32Array(12);
      for (var _i7 = 0; _i7 < 4; _i7++) {
        ptsArray[_i7 * 3] = _i7 % 2 * 2 - 1;
        ptsArray[_i7 * 3 + 1] = _i7 > 1 ? 1 : -1;
        ptsArray[_i7 * 3 + 2] = -1;
      }
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation$2.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES$v = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  scalarTextureString: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1,
  targetXYF: 1,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lastLightComplexity: 0,
  fullViewportTime: 1,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0,
  avgFrameTime: 0
};
function extend$w(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$v, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.scalarTexture = vtkOpenGLTexture$1.newInstance();
  model.opacityTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap$1.REPEAT);
  model.jitterTexture.setWrapT(Wrap$1.REPEAT);
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  model.idxToView = identity$1(new Float64Array(16));
  model.idxNormalMatrix = identity$2(new Float64Array(9));
  model.modelToView = identity$1(new Float64Array(16));
  model.projectionToView = identity$1(new Float64Array(16));
  model.projectionToWorld = identity$1(new Float64Array(16));
  model._lastScale = 1;
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var newInstance$u = newInstance$X(extend$w, "vtkOpenGLVolumeMapper");
registerOverride$1("vtkVolumeMapper", newInstance$u);
var vtkDebugMacro$3 = macro.vtkDebugMacro;
function vtkCamera(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  var origin = new Float64Array(3);
  var dopbasis = new Float64Array([0, 0, -1]);
  var upbasis = new Float64Array([0, 1, 0]);
  var tmpMatrix = identity$1(new Float64Array(16));
  var tmpMatrix2 = identity$1(new Float64Array(16));
  var tmpvec1 = new Float64Array(3);
  var tmpvec2 = new Float64Array(3);
  var tmpvec3 = new Float64Array(3);
  var rotateMatrix = identity$1(new Float64Array(16));
  var trans = identity$1(new Float64Array(16));
  var newPosition = new Float64Array(3);
  var newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = function() {
    var vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = function(x, y, z) {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = function(x, y, z) {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = function(d) {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro$3("Distance is set to minimum.");
    }
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = function() {
    var dx = model.focalPoint[0] - model.position[0];
    var dy = model.focalPoint[1] - model.position[1];
    var dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro$3("Distance is set to minimum.");
      var vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = function(amount) {
    if (amount <= 0) {
      return;
    }
    var d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = function(angle2) {
    var eye = model.position;
    var at = model.focalPoint;
    var up = model.viewUp;
    var viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    identity$1(rotateMatrix);
    var viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle2), viewDir);
    transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = function(angle2) {
    var fp = model.focalPoint;
    identity$1(trans);
    translate(trans, trans, fp);
    rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
    translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    transformMat4$1(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = function(angle2) {
    var position = model.position;
    identity$1(trans);
    translate(trans, trans, position);
    rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
    translate(trans, trans, [-position[0], -position[1], -position[2]]);
    transformMat4$1(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = function(angle2) {
    var fp = model.focalPoint;
    var vt = publicAPI.getViewMatrix();
    var axis = [-vt[0], -vt[1], -vt[2]];
    identity$1(trans);
    translate(trans, trans, fp);
    rotate(trans, trans, radiansFromDegrees(angle2), axis);
    translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    transformMat4$1(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = function(angle2) {
    var position = model.position;
    var vt = publicAPI.getViewMatrix();
    var axis = [vt[0], vt[1], vt[2]];
    identity$1(trans);
    translate(trans, trans, position);
    rotate(trans, trans, radiansFromDegrees(angle2), axis);
    translate(trans, trans, [-position[0], -position[1], -position[2]]);
    transformMat4$1(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(newFocalPoint));
  };
  publicAPI.zoom = function(factor) {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = function(x, y, z) {
    var offset = [x, y, z];
    add(model.position, offset, model.position);
    add(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = function(transformMat4$12) {
    var vuOld = [].concat(_toConsumableArray(model.viewUp), [1]);
    var posNew = [];
    var fpNew = [];
    var vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    transformMat4(posNew, [].concat(_toConsumableArray(model.position), [1]), transformMat4$12);
    transformMat4(fpNew, [].concat(_toConsumableArray(model.focalPoint), [1]), transformMat4$12);
    transformMat4(vuNew, vuOld, transformMat4$12);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition.apply(publicAPI, _toConsumableArray(posNew.slice(0, 3)));
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(fpNew.slice(0, 3)));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(vuNew.slice(0, 3)));
  };
  publicAPI.getThickness = function() {
    return model.clippingRange[1] - model.clippingRange[0];
  };
  publicAPI.setThickness = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro$3("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro$3("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };
  publicAPI.setRoll = function(angle2) {
  };
  publicAPI.getRoll = function() {
  };
  publicAPI.setObliqueAngles = function(alpha, beta) {
  };
  publicAPI.getOrientation = function() {
  };
  publicAPI.getOrientationWXYZ = function() {
  };
  publicAPI.getFrustumPlanes = function(aspect) {
  };
  publicAPI.getCameraLightTransformMatrix = function(matrix) {
    copy$1(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = function() {
    copy$1(tmpMatrix, publicAPI.getViewMatrix());
    invert(tmpMatrix, tmpMatrix);
    fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    multiply$2(tmpMatrix, tmpMatrix, tmpMatrix2);
    identity$1(model.cameraLightTransform);
    translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
  };
  publicAPI.deepCopy = function(sourceCamera) {
  };
  publicAPI.physicalOrientationToWorldDirection = function(ori) {
    var oriq = fromValues$1(ori[0], ori[1], ori[2], ori[3]);
    var coriq = create$1();
    var qdir = fromValues$1(0, 0, 1, 0);
    conjugate(coriq, oriq);
    multiply(qdir, oriq, qdir);
    multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = function(result) {
    publicAPI.getWorldToPhysicalMatrix(result);
    invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = function(result) {
    identity$1(result);
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    transpose(result, result);
    set$1(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    scale$2(result, result, tmpvec1);
    translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = function(vmat) {
    invert(tmpMatrix, vmat);
    transformMat4$1(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    var oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
    transformMat4$1(tmpvec2, dopbasis, tmpMatrix);
    subtract$3(tmpvec2, tmpvec2, tmpvec1);
    normalize$4(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    transformMat4$1(tmpvec3, upbasis, tmpMatrix);
    subtract$3(tmpvec3, tmpvec3, tmpvec1);
    normalize$4(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = function(mat) {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    multiply$2(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = function(mat) {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      copy$1(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = function() {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    lookAt(
      tmpMatrix,
      model.position,
      model.focalPoint,
      model.viewUp
    );
    transpose(tmpMatrix, tmpMatrix);
    var result = new Float64Array(16);
    copy$1(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = function(mat) {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = function(aspect, nearz, farz) {
    var result = new Float64Array(16);
    identity$1(result);
    if (model.projectionMatrix) {
      var scale2 = 1 / model.physicalScale;
      set$1(tmpvec1, scale2, scale2, scale2);
      copy$1(result, model.projectionMatrix);
      scale$2(result, result, tmpvec1);
      transpose(result, result);
      return result;
    }
    identity$1(tmpMatrix);
    var cWidth = model.clippingRange[1] - model.clippingRange[0];
    var cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      var width = model.parallelScale * aspect;
      var height = model.parallelScale;
      var xmin = (model.windowCenter[0] - 1) * width;
      var xmax = (model.windowCenter[0] + 1) * width;
      var ymin = (model.windowCenter[1] - 1) * height;
      var ymax = (model.windowCenter[1] + 1) * height;
      ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      var tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      var _width;
      var _height;
      if (model.useHorizontalViewAngle === true) {
        _width = model.clippingRange[0] * tmp;
        _height = model.clippingRange[0] * tmp / aspect;
      } else {
        _width = model.clippingRange[0] * tmp * aspect;
        _height = model.clippingRange[0] * tmp;
      }
      var _xmin = (model.windowCenter[0] - 1) * _width;
      var _xmax = (model.windowCenter[0] + 1) * _width;
      var _ymin = (model.windowCenter[1] - 1) * _height;
      var _ymax = (model.windowCenter[1] + 1) * _height;
      var znear = cRange[0];
      var zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (_xmax - _xmin);
      tmpMatrix[5] = 2 * znear / (_ymax - _ymin);
      tmpMatrix[2] = (_xmin + _xmax) / (_xmax - _xmin);
      tmpMatrix[6] = (_ymin + _ymax) / (_ymax - _ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    copy$1(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = function(aspect, nearz, farz) {
    var vMat = publicAPI.getViewMatrix();
    var pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    multiply$2(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = function(x, y, z) {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = function(alpha, beta, gamma, screen) {
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    var rotmat = identity$1(new Float64Array(16));
    rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    var dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    var vup = new Float64Array(model.physicalViewNorth);
    transformMat4$1(dop, dop, rotmat);
    transformMat4$1(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = function(degrees, x, y, z) {
    var quatMat = identity$1(new Float64Array(16));
    if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
      var angle2 = radiansFromDegrees(degrees);
      var q = create$1();
      setAxisAngle(q, [x, y, z], angle2);
      fromQuat(quatMat, q);
    }
    var newdop = new Float64Array(3);
    transformMat4$1(newdop, [0, 0, -1], quatMat);
    var newvup = new Float64Array(3);
    transformMat4$1(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection.apply(publicAPI, _toConsumableArray(newdop));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(newvup));
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = function(bounds) {
    var vn = null;
    var position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    var a = -vn[0];
    var b = -vn[1];
    var c = -vn[2];
    var d = -(a * position[0] + b * position[1] + c * position[2]);
    var range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];
    for (var k = 0; k < 2; k++) {
      for (var j = 0; j < 2; j++) {
        for (var i = 0; i < 2; i++) {
          var dist3 = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist3 < range[0] ? dist3 : range[0];
          range[1] = dist3 > range[1] ? dist3 : range[1];
        }
      }
    }
    return range;
  };
}
var DEFAULT_VALUES$u = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: create$4(),
  physicalTranslation: [0, 0, 0],
  physicalScale: 1,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};
function extend$v(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$u, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera(publicAPI, model);
}
var newInstance$t = macro.newInstance(extend$v, "vtkCamera");
var vtkCamera$1 = {
  newInstance: newInstance$t,
  extend: extend$v
};
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = function(deltaXYZ) {
    model.position = model.position.map(function(value, index2) {
      return value + deltaXYZ[index2];
    });
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = function() {
    var q = create$1();
    getRotation(q, model.rotation);
    var oaxis = new Float64Array(3);
    var w = getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.rotateX = function(val) {
    if (val === 0) {
      return;
    }
    rotateX$1(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = function(val) {
    if (val === 0) {
      return;
    }
    rotateY$1(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = function(val) {
    if (val === 0) {
      return;
    }
    rotateZ$1(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = function(degrees, x, y, z) {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    var angle2 = radiansFromDegrees(degrees);
    var q = create$1();
    setAxisAngle(q, [x, y, z], angle2);
    var quatMat = new Float64Array(16);
    fromQuat(quatMat, q);
    multiply$2(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = function(x, y, z) {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    identity$1(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = function(matrix) {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    copy$1(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = function() {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = function() {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      identity$1(model.matrix);
      if (model.userMatrix) {
        multiply$2(model.matrix, model.matrix, model.userMatrix);
      }
      translate(model.matrix, model.matrix, model.origin);
      translate(model.matrix, model.matrix, model.position);
      multiply$2(model.matrix, model.matrix, model.rotation);
      scale$2(model.matrix, model.matrix, model.scale);
      translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (var i = 0; i < 4; ++i) {
        for (var j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = function() {
    return vtkBoundingBox.getCenter(model.bounds);
  };
  publicAPI.getLength = function() {
    return vtkBoundingBox.getLength(model.bounds);
  };
  publicAPI.getXRange = function() {
    return vtkBoundingBox.getXRange(model.bounds);
  };
  publicAPI.getYRange = function() {
    return vtkBoundingBox.getYRange(model.bounds);
  };
  publicAPI.getZRange = function() {
    return vtkBoundingBox.getZRange(model.bounds);
  };
  publicAPI.getUserMatrix = function() {
    return model.userMatrix;
  };
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
var DEFAULT_VALUES$t = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend$u(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$t, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = identity$1(new Float64Array(16));
  model.rotation = identity$1(new Float64Array(16));
  model.userMatrix = identity$1(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance$s = macro.newInstance(extend$u, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance$s,
  extend: extend$u
};
function ownKeys$5(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var BlendMode = Constants$d.BlendMode, FilterMode = Constants$d.FilterMode;
function createRadonTransferFunction(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption, maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption, outputTransferFunction) {
  var ofun = null;
  if (outputTransferFunction) {
    ofun = outputTransferFunction;
    ofun.removeAllPoints();
  } else {
    ofun = vtkPiecewiseFunction$1.newInstance();
  }
  ofun.addPointLong(-1024, 0, 1, 1);
  ofun.addPoint(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption);
  ofun.addPoint(maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption);
  return ofun;
}
var STATIC$1 = {
  createRadonTransferFunction
};
function vtkVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeMapper");
  var superClass = _objectSpread$5({}, publicAPI);
  publicAPI.getBounds = function() {
    var input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = function() {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = function() {
    publicAPI.setBlendMode(BlendMode.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = function() {
    publicAPI.setBlendMode(BlendMode.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = function() {
    publicAPI.setBlendMode(BlendMode.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = function() {
    publicAPI.setBlendMode(BlendMode.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = function() {
    publicAPI.setBlendMode(BlendMode.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToRadonTransform = function() {
    publicAPI.setBlendMode(BlendMode.RADON_TRANSFORM_BLEND);
  };
  publicAPI.getBlendModeAsString = function() {
    return macro.enumToString(BlendMode, model.blendMode);
  };
  publicAPI.setAverageIPScalarRange = function(min2, max2) {
    console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange");
    publicAPI.setIpScalarRange(min2, max2);
  };
  publicAPI.getFilterModeAsString = function() {
    return macro.enumToString(FilterMode, model.filterMode);
  };
  publicAPI.setFilterModeToOff = function() {
    publicAPI.setFilterMode(FilterMode.OFF);
  };
  publicAPI.setFilterModeToNormalized = function() {
    publicAPI.setFilterMode(FilterMode.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = function() {
    publicAPI.setFilterMode(FilterMode.RAW);
  };
  publicAPI.setGlobalIlluminationReach = function(gl) {
    return superClass.setGlobalIlluminationReach(clampValue(gl, 0, 1));
  };
  publicAPI.setVolumetricScatteringBlending = function(vsb) {
    return superClass.setVolumetricScatteringBlending(clampValue(vsb, 0, 1));
  };
  publicAPI.setVolumeShadowSamplingDistFactor = function(vsdf) {
    return superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1 ? vsdf : 1);
  };
  publicAPI.setAnisotropy = function(at) {
    return superClass.setAnisotropy(clampValue(at, -0.99, 0.99));
  };
  publicAPI.setLAOKernelSize = function(ks) {
    return superClass.setLAOKernelSize(floor(clampValue(ks, 1, 32)));
  };
  publicAPI.setLAOKernelRadius = function(kr) {
    return superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
  };
}
var DEFAULT_VALUES$s = {
  bounds: [1, -1, 1, -1, 1, -1],
  sampleDistance: 1,
  imageSampleDistance: 1,
  maximumSamplesPerRay: 1e3,
  autoAdjustSampleDistances: true,
  blendMode: BlendMode.COMPOSITE_BLEND,
  ipScalarRange: [-1e6, 1e6],
  filterMode: FilterMode.OFF,
  preferSizeOverAccuracy: false,
  computeNormalFromOpacity: false,
  volumetricScatteringBlending: 0,
  globalIlluminationReach: 0,
  volumeShadowSamplingDistFactor: 5,
  anisotropy: 0,
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7
};
function extend$t(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$s, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sampleDistance", "imageSampleDistance", "maximumSamplesPerRay", "autoAdjustSampleDistances", "blendMode", "filterMode", "preferSizeOverAccuracy", "computeNormalFromOpacity", "volumetricScatteringBlending", "globalIlluminationReach", "volumeShadowSamplingDistFactor", "anisotropy", "localAmbientOcclusion", "LAOKernelSize", "LAOKernelRadius"]);
  macro.setGetArray(publicAPI, model, ["ipScalarRange"], 2);
  macro.event(publicAPI, model, "lightingActivated");
  vtkVolumeMapper(publicAPI, model);
}
var newInstance$r = macro.newInstance(extend$t, "vtkVolumeMapper");
var vtkVolumeMapper$1 = _objectSpread$5({
  newInstance: newInstance$r,
  extend: extend$t
}, STATIC$1);
function vtkSharedVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkSharedVolumeMapper");
  const superDelete = publicAPI.delete;
  publicAPI.delete = () => {
    model.scalarTexture = null;
    superDelete();
  };
}
const DEFAULT_VALUES$r = {
  scalarTexture: null
};
function extend$s(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES$r, initialValues);
  vtkVolumeMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["scalarTexture"]);
  vtkSharedVolumeMapper(publicAPI, model);
}
const newInstance$q = macro.newInstance(extend$s, "vtkSharedVolumeMapper");
const vtkSharedVolumeMapper$1 = { newInstance: newInstance$q, extend: extend$s };
function vtkSlabCamera(publicAPI, model) {
  model.classHierarchy.push("vtkSlabCamera");
  const tmpMatrix = identity$1(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = create$4();
    if (model.projectionMatrix) {
      const scale2 = 1 / model.physicalScale;
      set$1(tmpvec1, scale2, scale2, scale2);
      copy$1(result, model.projectionMatrix);
      scale$2(result, result, tmpvec1);
      transpose(result, result);
      return result;
    }
    identity$1(tmpMatrix);
    let cRange0 = model.clippingRange[0];
    let cRange1 = model.clippingRange[1];
    if (model.isPerformingCoordinateTransformation) {
      cRange0 = model.distance;
      cRange1 = model.distance + 0.1;
    }
    const cWidth = cRange1 - cRange0;
    const cRange = [
      cRange0 + (nearz + 1) * cWidth / 2,
      cRange0 + (farz + 1) * cWidth / 2
    ];
    if (model.parallelProjection) {
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      const tmp = Math.tan(vtkMath.radiansFromDegrees(model.viewAngle) / 2);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = cRange0 * tmp;
        height = cRange0 * tmp / aspect;
      } else {
        width = cRange0 * tmp * aspect;
        height = cRange0 * tmp;
      }
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (xmax - xmin);
      tmpMatrix[5] = 2 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    copy$1(result, tmpMatrix);
    return result;
  };
}
const DEFAULT_VALUES$q = {
  isPerformingCoordinateTransformation: false
};
function extend$r(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES$q, initialValues);
  vtkCamera$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["isPerformingCoordinateTransformation"]);
  vtkSlabCamera(publicAPI, model);
}
const newInstance$p = macro.newInstance(extend$r, "vtkSlabCamera");
const vtkSlabCamera$1 = { newInstance: newInstance$p, extend: extend$r };
var lodash_clonedeep = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index2 = -1, length2 = array ? array.length : 0;
    while (++index2 < length2) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index2 = -1, length2 = values.length, offset = array.length;
    while (++index2 < length2) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index2 = -1, length2 = array ? array.length : 0;
    if (initAccum && length2) {
      accumulator = array[++index2];
    }
    while (++index2 < length2) {
      accumulator = iteratee(accumulator, array[index2], index2, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function getValue(object3, key) {
    return object3 == null ? void 0 : object3[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString2 = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index2 = -1, length2 = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length2 = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length2 = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments6(value) ? baseTimes(value.length, String) : [];
    var length2 = result.length, skipIndexes = !!length2;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object3, key, value) {
    var objValue = object3[key];
    if (!(hasOwnProperty2.call(object3, key) && eq(objValue, value)) || value === void 0 && !(key in object3)) {
      object3[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length2 = array.length;
    while (length2--) {
      if (eq(array[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  function baseAssign(object3, source) {
    return object3 && copyObject(source, keys4(source), object3);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object3, stack) {
    var result;
    if (customizer) {
      result = object3 ? customizer(value, key, object3, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object3) {
        if (isHostObject(value)) {
          return object3 ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object3 ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys4(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object3, keysFunc, symbolsFunc) {
    var result = keysFunc(object3);
    return isArray2(object3) ? result : arrayPush(result, symbolsFunc(object3));
  }
  function baseGetTag(value) {
    return objectToString2.call(value);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object3) {
    if (!isPrototype(object3)) {
      return nativeKeys(object3);
    }
    var result = [];
    for (var key in Object(object3)) {
      if (hasOwnProperty2.call(object3, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index2 = -1, length2 = source.length;
    array || (array = Array(length2));
    while (++index2 < length2) {
      array[index2] = source[index2];
    }
    return array;
  }
  function copyObject(source, props, object3, customizer) {
    object3 || (object3 = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object3[key], source[key], key, object3, source) : void 0;
      assignValue(object3, key, newValue === void 0 ? source[key] : newValue);
    }
    return object3;
  }
  function copySymbols(source, object3) {
    return copyObject(source, getSymbols(source), object3);
  }
  function getAllKeys(object3) {
    return baseGetAllKeys(object3, keys4, getSymbols);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object3, key) {
    var value = getValue(object3, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length2 = array.length, result = array.constructor(length2);
    if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object3) {
    return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
  }
  function initCloneByTag(object3, tag, cloneFunc, isDeep) {
    var Ctor = object3.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object3);
      case boolTag:
      case dateTag:
        return new Ctor(+object3);
      case dataViewTag:
        return cloneDataView(object3, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object3, isDeep);
      case mapTag:
        return cloneMap(object3, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object3);
      case regexpTag:
        return cloneRegExp(object3);
      case setTag:
        return cloneSet(object3, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object3);
    }
  }
  function isIndex(value, length2) {
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments6(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys4(object3) {
    return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
})(lodash_clonedeep, lodash_clonedeep.exports);
const _cloneDeep = lodash_clonedeep.exports;
class Viewport {
  constructor(props) {
    this.flipHorizontal = false;
    this.flipVertical = false;
    this.rotation = 0;
    this._suppressCameraModifiedEvents = false;
    this.hasPixelSpacing = true;
    this.id = props.id;
    this.renderingEngineId = props.renderingEngineId;
    this.type = props.type;
    this.element = props.element;
    this.canvas = props.canvas;
    this.sx = props.sx;
    this.sy = props.sy;
    this.sWidth = props.sWidth;
    this.sHeight = props.sHeight;
    this._actors = /* @__PURE__ */ new Map();
    this.element.setAttribute("data-viewport-uid", this.id);
    this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId);
    this.defaultOptions = _cloneDeep(props.defaultOptions);
    this.suppressEvents = props.defaultOptions.suppressEvents ? props.defaultOptions.suppressEvents : false;
    this.options = _cloneDeep(props.defaultOptions);
    this.isDisabled = false;
  }
  static get useCustomRenderingPipeline() {
    return false;
  }
  getRenderingEngine() {
    return renderingEngineCache$1.get(this.renderingEngineId);
  }
  getRenderer() {
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      throw new Error("Rendering engine has been destroyed");
    }
    return renderingEngine.offscreenMultiRenderWindow.getRenderer(this.id);
  }
  render() {
    const renderingEngine = this.getRenderingEngine();
    renderingEngine.renderViewport(this.id);
  }
  setOptions(options, immediate = false) {
    this.options = _cloneDeep(options);
    if (immediate) {
      this.render();
    }
  }
  reset(immediate = false) {
    this.options = _cloneDeep(this.defaultOptions);
    if (immediate) {
      this.render();
    }
  }
  flip({ flipHorizontal, flipVertical }) {
    const imageData = this.getDefaultImageData();
    if (!imageData) {
      return;
    }
    const camera = this.getCamera();
    const { viewPlaneNormal, viewUp, focalPoint, position } = camera;
    const viewRight = cross$1(create$3(), viewPlaneNormal, viewUp);
    let viewUpToSet = copy(create$3(), viewUp);
    const viewPlaneNormalToSet = negate(create$3(), viewPlaneNormal);
    const distance2 = distance$1(position, focalPoint);
    const dimensions = imageData.getDimensions();
    const middleIJK = dimensions.map((d) => Math.floor(d / 2));
    const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
    const centeredFocalPoint = imageData.indexToWorld(idx, create$3());
    const resetFocalPoint = this._getFocalPointForResetCamera(centeredFocalPoint, camera, { resetPan: true, resetToCenter: false });
    const panDir = subtract$3(create$3(), focalPoint, resetFocalPoint);
    const panValue = length(panDir);
    const getPanDir = (mirrorVec) => {
      const panDirMirror = scale$1(create$3(), mirrorVec, 2 * dot$1(panDir, mirrorVec));
      subtract$3(panDirMirror, panDirMirror, panDir);
      normalize$4(panDirMirror, panDirMirror);
      return panDirMirror;
    };
    if (flipHorizontal) {
      const panDirMirror = getPanDir(viewUpToSet);
      const newFocalPoint = scaleAndAdd(create$3(), resetFocalPoint, panDirMirror, panValue);
      const newPosition = scaleAndAdd(create$3(), newFocalPoint, viewPlaneNormalToSet, distance2);
      this.setCamera({
        viewPlaneNormal: viewPlaneNormalToSet,
        position: newPosition,
        focalPoint: newFocalPoint
      });
      this.flipHorizontal = !this.flipHorizontal;
    }
    if (flipVertical) {
      viewUpToSet = negate(viewUpToSet, viewUp);
      const panDirMirror = getPanDir(viewRight);
      const newFocalPoint = scaleAndAdd(create$3(), resetFocalPoint, panDirMirror, panValue);
      const newPosition = scaleAndAdd(create$3(), newFocalPoint, viewPlaneNormalToSet, distance2);
      this.setCamera({
        focalPoint: newFocalPoint,
        viewPlaneNormal: viewPlaneNormalToSet,
        viewUp: viewUpToSet,
        position: newPosition
      });
      this.flipVertical = !this.flipVertical;
    }
    this.render();
  }
  getDefaultImageData() {
    const actorEntry = this.getDefaultActor();
    if (actorEntry && isImageActor(actorEntry.actor)) {
      return actorEntry.actor.getMapper().getInputData();
    }
  }
  getDefaultActor() {
    return this.getActors()[0];
  }
  getActors() {
    return Array.from(this._actors.values());
  }
  getActor(actorUID) {
    return this._actors.get(actorUID);
  }
  getActorUIDByIndex(index2) {
    const actor = this.getActors()[index2];
    if (actor) {
      return actor.uid;
    }
  }
  getActorByIndex(index2) {
    return this.getActors()[index2];
  }
  setActors(actors) {
    this.removeAllActors();
    const resetCameraPanAndZoom = true;
    this.addActors(actors, resetCameraPanAndZoom);
  }
  removeActor(actorUID) {
    const actorEntry = this.getActor(actorUID);
    if (!actorEntry) {
      console.warn(`Actor ${actorUID} does not exist for this viewport`);
      return;
    }
    const renderer2 = this.getRenderer();
    renderer2.removeViewProp(actorEntry.actor);
    this._actors.delete(actorUID);
  }
  removeActors(actorUIDs) {
    actorUIDs.forEach((actorUID) => {
      this.removeActor(actorUID);
    });
  }
  addActors(actors, resetCameraPanAndZoom = false) {
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      console.warn("Viewport::addActors::Rendering engine has not been initialized or has been destroyed");
      return;
    }
    actors.forEach((actor) => this.addActor(actor));
    this.resetCamera(resetCameraPanAndZoom, resetCameraPanAndZoom);
  }
  addActor(actorEntry) {
    const { uid: actorUID, actor } = actorEntry;
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      console.warn(`Cannot add actor UID of ${actorUID} Rendering Engine has been destroyed`);
      return;
    }
    if (!actorUID || !actor) {
      throw new Error("Actors should have uid and vtk Actor properties");
    }
    if (this.getActor(actorUID)) {
      console.warn(`Actor ${actorUID} already exists for this viewport`);
      return;
    }
    const renderer2 = this.getRenderer();
    renderer2.addActor(actor);
    this._actors.set(actorUID, Object.assign({}, actorEntry));
  }
  removeAllActors() {
    this.getRenderer().removeAllViewProps();
    this._actors = /* @__PURE__ */ new Map();
    return;
  }
  resetCameraNoEvent() {
    this._suppressCameraModifiedEvents = true;
    this.resetCamera();
    this._suppressCameraModifiedEvents = false;
  }
  setCameraNoEvent(camera) {
    this._suppressCameraModifiedEvents = true;
    this.setCamera(camera);
    this._suppressCameraModifiedEvents = false;
  }
  _getViewImageDataIntersections(imageData, focalPoint, normal) {
    const A = normal[0];
    const B = normal[1];
    const C = normal[2];
    const D = A * focalPoint[0] + B * focalPoint[1] + C * focalPoint[2];
    const bounds = imageData.getBounds();
    const edges = this._getEdges(bounds);
    const intersections = [];
    for (const edge of edges) {
      const [[x0, y0, z0], [x1, y1, z1]] = edge;
      if (A * (x1 - x0) + B * (y1 - y0) + C * (z1 - z0) === 0) {
        continue;
      }
      const intersectionPoint = linePlaneIntersection([x0, y0, z0], [x1, y1, z1], [A, B, C, D]);
      if (this._isInBounds(intersectionPoint, bounds)) {
        intersections.push(intersectionPoint);
      }
    }
    return intersections;
  }
  resetCamera(resetPan = true, resetZoom = true, resetToCenter = true, storeAsInitialCamera = true) {
    const renderer2 = this.getRenderer();
    this.setCamera({
      flipHorizontal: false,
      flipVertical: false
    });
    const previousCamera = _cloneDeep(this.getCamera());
    const bounds = renderer2.computeVisiblePropBounds();
    const focalPoint = [0, 0, 0];
    const imageData = this.getDefaultImageData();
    if (imageData) {
      const spc = imageData.getSpacing();
      bounds[0] = bounds[0] + spc[0] / 2;
      bounds[1] = bounds[1] - spc[0] / 2;
      bounds[2] = bounds[2] + spc[1] / 2;
      bounds[3] = bounds[3] - spc[1] / 2;
      bounds[4] = bounds[4] + spc[2] / 2;
      bounds[5] = bounds[5] - spc[2] / 2;
    }
    const activeCamera = this.getVtkActiveCamera();
    const viewPlaneNormal = activeCamera.getViewPlaneNormal();
    const viewUp = activeCamera.getViewUp();
    focalPoint[0] = (bounds[0] + bounds[1]) / 2;
    focalPoint[1] = (bounds[2] + bounds[3]) / 2;
    focalPoint[2] = (bounds[4] + bounds[5]) / 2;
    if (imageData) {
      const dimensions = imageData.getDimensions();
      const middleIJK = dimensions.map((d) => Math.floor(d / 2));
      const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
      imageData.indexToWorld(idx, focalPoint);
    }
    const { widthWorld, heightWorld } = this._getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal);
    const canvasSize = [this.sWidth, this.sHeight];
    const boundsAspectRatio = widthWorld / heightWorld;
    const canvasAspectRatio = canvasSize[0] / canvasSize[1];
    let radius;
    if (boundsAspectRatio < canvasAspectRatio) {
      radius = heightWorld / 2;
    } else {
      const scaleFactor = boundsAspectRatio / canvasAspectRatio;
      radius = heightWorld * scaleFactor / 2;
    }
    const parallelScale = 1.1 * radius;
    let w1 = bounds[1] - bounds[0];
    let w2 = bounds[3] - bounds[2];
    let w3 = bounds[5] - bounds[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    const distance2 = 1.1 * radius;
    const viewUpToSet = Math.abs(vtkMath.dot(viewUp, viewPlaneNormal)) > 0.999 ? [-viewUp[2], viewUp[0], viewUp[1]] : viewUp;
    const focalPointToSet = this._getFocalPointForResetCamera(focalPoint, previousCamera, { resetPan, resetToCenter });
    const positionToSet = [
      focalPointToSet[0] + distance2 * viewPlaneNormal[0],
      focalPointToSet[1] + distance2 * viewPlaneNormal[1],
      focalPointToSet[2] + distance2 * viewPlaneNormal[2]
    ];
    renderer2.resetCameraClippingRange(bounds);
    const clippingRangeToUse = [
      -RENDERING_DEFAULTS$2.MAXIMUM_RAY_DISTANCE,
      RENDERING_DEFAULTS$2.MAXIMUM_RAY_DISTANCE
    ];
    activeCamera.setPhysicalScale(radius);
    activeCamera.setPhysicalTranslation(-focalPointToSet[0], -focalPointToSet[1], -focalPointToSet[2]);
    this.setCamera({
      parallelScale: resetZoom ? parallelScale : previousCamera.parallelScale,
      focalPoint: focalPointToSet,
      position: positionToSet,
      viewAngle: 90,
      viewUp: viewUpToSet,
      clippingRange: clippingRangeToUse
    });
    const modifiedCamera = _cloneDeep(this.getCamera());
    if (storeAsInitialCamera) {
      this.setInitialCamera(modifiedCamera);
    }
    const RESET_CAMERA_EVENT = {
      type: "ResetCameraEvent",
      renderer: renderer2
    };
    renderer2.invokeEvent(RESET_CAMERA_EVENT);
    this.triggerCameraModifiedEventIfNecessary(previousCamera, modifiedCamera);
    return true;
  }
  setInitialCamera(camera) {
    this.initialCamera = camera;
  }
  getPan() {
    const activeCamera = this.getVtkActiveCamera();
    const focalPoint = activeCamera.getFocalPoint();
    const zero3 = this.canvasToWorld([0, 0]);
    const initialCanvasFocal = this.worldToCanvas(subtract$3(create$3(), this.initialCamera.focalPoint, zero3));
    const currentCanvasFocal = this.worldToCanvas(subtract$3(create$3(), focalPoint, zero3));
    const result = subtract$1(create(), initialCanvasFocal, currentCanvasFocal);
    return result;
  }
  setPan(pan, storeAsInitialCamera = false) {
    const previousCamera = this.getCamera();
    const { focalPoint, position } = previousCamera;
    const zero3 = this.canvasToWorld([0, 0]);
    const delta2 = subtract$1(create(), pan, this.getPan());
    if (Math.abs(delta2[0]) < 1 && Math.abs(delta2[1]) < 1 && !storeAsInitialCamera) {
      return;
    }
    const delta = subtract$3(create$3(), this.canvasToWorld(delta2), zero3);
    const newFocal = subtract$3(create$3(), focalPoint, delta);
    const newPosition = subtract$3(create$3(), position, delta);
    this.setCamera({
      ...previousCamera,
      focalPoint: newFocal,
      position: newPosition
    }, storeAsInitialCamera);
  }
  getZoom() {
    const activeCamera = this.getVtkActiveCamera();
    const { parallelScale: initialParallelScale } = this.initialCamera;
    return initialParallelScale / activeCamera.getParallelScale();
  }
  setZoom(value, storeAsInitialCamera = false) {
    const camera = this.getCamera();
    const { parallelScale: initialParallelScale } = this.initialCamera;
    const parallelScale = initialParallelScale / value;
    if (camera.parallelScale === parallelScale && !storeAsInitialCamera) {
      return;
    }
    this.setCamera({
      ...camera,
      parallelScale
    }, storeAsInitialCamera);
  }
  _getFocalPointForViewPlaneReset(imageData) {
    const { focalPoint, viewPlaneNormal: normal } = this.getCamera();
    const intersections = this._getViewImageDataIntersections(imageData, focalPoint, normal);
    let x = 0;
    let y = 0;
    let z = 0;
    intersections.forEach(([point_x, point_y, point_z]) => {
      x += point_x;
      y += point_y;
      z += point_z;
    });
    const newFocalPoint = [
      x / intersections.length,
      y / intersections.length,
      z / intersections.length
    ];
    return newFocalPoint;
  }
  getCanvas() {
    return this.canvas;
  }
  getVtkActiveCamera() {
    const renderer2 = this.getRenderer();
    return renderer2.getActiveCamera();
  }
  getCamera() {
    const vtkCamera2 = this.getVtkActiveCamera();
    return {
      viewUp: vtkCamera2.getViewUp(),
      viewPlaneNormal: vtkCamera2.getViewPlaneNormal(),
      position: vtkCamera2.getPosition(),
      focalPoint: vtkCamera2.getFocalPoint(),
      parallelProjection: vtkCamera2.getParallelProjection(),
      parallelScale: vtkCamera2.getParallelScale(),
      viewAngle: vtkCamera2.getViewAngle(),
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical
    };
  }
  setCamera(cameraInterface, storeAsInitialCamera = false) {
    var _a2, _b;
    const vtkCamera2 = this.getVtkActiveCamera();
    const previousCamera = _cloneDeep(this.getCamera());
    const updatedCamera = Object.assign({}, previousCamera, cameraInterface);
    const { viewUp, viewPlaneNormal, position, focalPoint, parallelScale, viewAngle, flipHorizontal, flipVertical, clippingRange } = cameraInterface;
    if (flipHorizontal !== void 0) {
      const flipH = flipHorizontal && !this.flipHorizontal || !flipHorizontal && this.flipHorizontal;
      if (flipH) {
        this.flip({ flipHorizontal: flipH });
      }
    }
    if (flipVertical !== void 0) {
      const flipV = flipVertical && !this.flipVertical || !flipVertical && this.flipVertical;
      if (flipV) {
        this.flip({ flipVertical: flipV });
      }
    }
    if (viewUp !== void 0) {
      vtkCamera2.setViewUp(viewUp);
    }
    if (viewPlaneNormal !== void 0) {
      vtkCamera2.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    }
    if (position !== void 0) {
      vtkCamera2.setPosition(...position);
    }
    if (focalPoint !== void 0) {
      vtkCamera2.setFocalPoint(...focalPoint);
    }
    if (parallelScale !== void 0) {
      vtkCamera2.setParallelScale(parallelScale);
    }
    if (viewAngle !== void 0) {
      vtkCamera2.setViewAngle(viewAngle);
    }
    if (clippingRange !== void 0) {
      vtkCamera2.setClippingRange(clippingRange);
    }
    const actorEntry = this.getDefaultActor();
    if ((_a2 = actorEntry == null ? void 0 : actorEntry.actor) == null ? void 0 : _a2.isA("vtkVolume")) {
      this.updateClippingPlanesForActors(updatedCamera);
    }
    if ((_b = actorEntry == null ? void 0 : actorEntry.actor) == null ? void 0 : _b.isA("vtkImageSlice")) {
      const renderer2 = this.getRenderer();
      renderer2.resetCameraClippingRange();
    }
    if (storeAsInitialCamera) {
      this.setInitialCamera(updatedCamera);
    }
    this.triggerCameraModifiedEventIfNecessary(previousCamera, this.getCamera());
  }
  triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera) {
    if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
      const eventDetail = {
        previousCamera,
        camera: updatedCamera,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId,
        rotation: this.rotation
      };
      triggerEvent(this.element, Events$2.CAMERA_MODIFIED, eventDetail);
    }
  }
  updateClippingPlanesForActors(updatedCamera) {
    const actorEntries = this.getActors();
    actorEntries.forEach((actorEntry) => {
      if (!actorEntry.actor || !isImageActor(actorEntry.actor)) {
        return;
      }
      const mapper = actorEntry.actor.getMapper();
      const vtkPlanes = mapper.getClippingPlanes();
      let slabThickness = RENDERING_DEFAULTS$2.MINIMUM_SLAB_THICKNESS;
      if (actorEntry.slabThickness) {
        slabThickness = actorEntry.slabThickness;
      }
      const { viewPlaneNormal, focalPoint } = updatedCamera;
      this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
    });
  }
  setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint) {
    if (vtkPlanes.length < 2) {
      return;
    }
    const scaledDistance = [
      viewPlaneNormal[0],
      viewPlaneNormal[1],
      viewPlaneNormal[2]
    ];
    vtkMath.multiplyScalar(scaledDistance, slabThickness);
    vtkPlanes[0].setNormal(viewPlaneNormal);
    const newOrigin1 = [0, 0, 0];
    vtkMath.subtract(focalPoint, scaledDistance, newOrigin1);
    vtkPlanes[0].setOrigin(newOrigin1);
    vtkPlanes[1].setNormal(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    const newOrigin2 = [0, 0, 0];
    vtkMath.add(focalPoint, scaledDistance, newOrigin2);
    vtkPlanes[1].setOrigin(newOrigin2);
  }
  _getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal) {
    const viewUpCorners = this._getCorners(bounds);
    const viewRightCorners = this._getCorners(bounds);
    const viewRight = cross$1(create$3(), viewUp, viewPlaneNormal);
    let transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(viewUp, [1, 0, 0]);
    viewUpCorners.forEach((pt) => transform.apply(pt));
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < 8; i++) {
      const y = viewUpCorners[i][0];
      if (y > maxY) {
        maxY = y;
      }
      if (y < minY) {
        minY = y;
      }
    }
    transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections([viewRight[0], viewRight[1], viewRight[2]], [1, 0, 0]);
    viewRightCorners.forEach((pt) => transform.apply(pt));
    let minX = Infinity;
    let maxX = -Infinity;
    for (let i = 0; i < 8; i++) {
      const x = viewRightCorners[i][0];
      if (x > maxX) {
        maxX = x;
      }
      if (x < minX) {
        minX = x;
      }
    }
    return { widthWorld: maxX - minX, heightWorld: maxY - minY };
  }
  _getCorners(bounds) {
    return [
      [bounds[0], bounds[2], bounds[4]],
      [bounds[0], bounds[2], bounds[5]],
      [bounds[0], bounds[3], bounds[4]],
      [bounds[0], bounds[3], bounds[5]],
      [bounds[1], bounds[2], bounds[4]],
      [bounds[1], bounds[2], bounds[5]],
      [bounds[1], bounds[3], bounds[4]],
      [bounds[1], bounds[3], bounds[5]]
    ];
  }
  _getFocalPointForResetCamera(centeredFocalPoint, previousCamera, { resetPan = true, resetToCenter = true }) {
    if (resetToCenter && resetPan) {
      return centeredFocalPoint;
    }
    if (resetToCenter && !resetPan) {
      return hasNaNValues(previousCamera.focalPoint) ? centeredFocalPoint : previousCamera.focalPoint;
    }
    if (!resetToCenter && resetPan) {
      const oldCamera = previousCamera;
      const oldFocalPoint = oldCamera.focalPoint;
      const oldViewPlaneNormal = oldCamera.viewPlaneNormal;
      const vectorFromOldFocalPointToCenteredFocalPoint = subtract$3(create$3(), centeredFocalPoint, oldFocalPoint);
      const distanceFromOldFocalPointToCenteredFocalPoint = dot$1(vectorFromOldFocalPointToCenteredFocalPoint, oldViewPlaneNormal);
      const newFocalPoint = scaleAndAdd(create$3(), centeredFocalPoint, oldViewPlaneNormal, -1 * distanceFromOldFocalPointToCenteredFocalPoint);
      return [newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]];
    }
    if (!resetPan && !resetToCenter) {
      return hasNaNValues(previousCamera.focalPoint) ? centeredFocalPoint : previousCamera.focalPoint;
    }
  }
  _isInBounds(point, bounds) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    const [x, y, z] = point;
    if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
      return false;
    }
    return true;
  }
  _getEdges(bounds) {
    const [p1, p2, p3, p4, p5, p6, p7, p8] = this._getCorners(bounds);
    return [
      [p1, p2],
      [p1, p5],
      [p1, p3],
      [p2, p4],
      [p2, p6],
      [p3, p4],
      [p3, p7],
      [p4, p8],
      [p5, p7],
      [p5, p6],
      [p6, p8],
      [p7, p8]
    ];
  }
}
const Viewport$1 = Viewport;
function ownKeys$4(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var InterpolationType$1 = Constants$1.InterpolationType, OpacityMode = Constants$1.OpacityMode;
var vtkErrorMacro$4 = macro.vtkErrorMacro;
var VTK_MAX_VRCOMP$1 = 4;
function vtkVolumeProperty(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeProperty");
  publicAPI.getMTime = function() {
    var mTime = model.mtime;
    var time;
    for (var index2 = 0; index2 < VTK_MAX_VRCOMP$1; index2++) {
      if (model.componentData[index2].colorChannels === 1) {
        if (model.componentData[index2].grayTransferFunction) {
          time = model.componentData[index2].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index2].colorChannels === 3) {
        if (model.componentData[index2].rGBTransferFunction) {
          time = model.componentData[index2].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
      if (model.componentData[index2].scalarOpacity) {
        time = model.componentData[index2].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index2].gradientOpacity) {
        if (!model.componentData[index2].disableGradientOpacity) {
          time = model.componentData[index2].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = function(index2) {
    if (index2 < 0 || index2 > 3) {
      vtkErrorMacro$4("Bad index - must be between 0 and 3");
      return 0;
    }
    return model.componentData[index2].colorChannels;
  };
  publicAPI.setGrayTransferFunction = function(index2, func) {
    var modified = false;
    if (model.componentData[index2].grayTransferFunction !== func) {
      model.componentData[index2].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index2].colorChannels !== 1) {
      model.componentData[index2].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getGrayTransferFunction = function(index2) {
    if (model.componentData[index2].grayTransferFunction === null) {
      model.componentData[index2].grayTransferFunction = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index2].grayTransferFunction.addPoint(0, 0);
      model.componentData[index2].grayTransferFunction.addPoint(1024, 1);
      if (model.componentData[index2].colorChannels !== 1) {
        model.componentData[index2].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index2].grayTransferFunction;
  };
  publicAPI.setRGBTransferFunction = function(index2, func) {
    var modified = false;
    if (model.componentData[index2].rGBTransferFunction !== func) {
      model.componentData[index2].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index2].colorChannels !== 3) {
      model.componentData[index2].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getRGBTransferFunction = function(index2) {
    if (model.componentData[index2].rGBTransferFunction === null) {
      model.componentData[index2].rGBTransferFunction = vtkColorTransferFunction$1.newInstance();
      model.componentData[index2].rGBTransferFunction.addRGBPoint(0, 0, 0, 0);
      model.componentData[index2].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1);
      if (model.componentData[index2].colorChannels !== 3) {
        model.componentData[index2].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index2].rGBTransferFunction;
  };
  publicAPI.setScalarOpacity = function(index2, func) {
    if (model.componentData[index2].scalarOpacity !== func) {
      model.componentData[index2].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getScalarOpacity = function(index2) {
    if (model.componentData[index2].scalarOpacity === null) {
      model.componentData[index2].scalarOpacity = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index2].scalarOpacity.addPoint(0, 1);
      model.componentData[index2].scalarOpacity.addPoint(1024, 1);
      publicAPI.modified();
    }
    return model.componentData[index2].scalarOpacity;
  };
  publicAPI.setComponentWeight = function(index2, value) {
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP$1) {
      vtkErrorMacro$4("Invalid index");
      return false;
    }
    var val = Math.min(1, Math.max(0, value));
    if (model.componentData[index2].componentWeight !== val) {
      model.componentData[index2].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function(index2) {
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP$1) {
      vtkErrorMacro$4("Invalid index");
      return 0;
    }
    return model.componentData[index2].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = function() {
    return publicAPI.setInterpolationType(InterpolationType$1.NEAREST);
  };
  publicAPI.setInterpolationTypeToLinear = function() {
    return publicAPI.setInterpolationType(InterpolationType$1.LINEAR);
  };
  publicAPI.setInterpolationTypeToFastLinear = function() {
    return publicAPI.setInterpolationType(InterpolationType$1.FAST_LINEAR);
  };
  publicAPI.getInterpolationTypeAsString = function() {
    return macro.enumToString(InterpolationType$1, model.interpolationType);
  };
  var sets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode"];
  sets.forEach(function(val) {
    var cap = macro.capitalize(val);
    publicAPI["set".concat(cap)] = function(index2, value) {
      if (model.componentData[index2]["".concat(val)] !== value) {
        model.componentData[index2]["".concat(val)] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  var gets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode"];
  gets.forEach(function(val) {
    var cap = macro.capitalize(val);
    publicAPI["get".concat(cap)] = function(index2) {
      return model.componentData[index2]["".concat(val)];
    };
  });
}
var DEFAULT_VALUES$p = {
  independentComponents: true,
  interpolationType: InterpolationType$1.FAST_LINEAR,
  shade: false,
  ambient: 0.1,
  diffuse: 0.7,
  specular: 0.2,
  specularPower: 10,
  useLabelOutline: false,
  labelOutlineThickness: 1,
  labelOutlineOpacity: 1
};
function extend$q(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$p, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (var i = 0; i < VTK_MAX_VRCOMP$1; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1,
        opacityMode: OpacityMode.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0,
        gradientOpacityMaximumValue: 1,
        gradientOpacityMaximumOpacity: 1,
        useGradientOpacity: false,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "shade", "ambient", "diffuse", "specular", "specularPower", "useLabelOutline", "labelOutlineThickness", "labelOutlineOpacity"]);
  vtkVolumeProperty(publicAPI, model);
}
var newInstance$o = macro.newInstance(extend$q, "vtkVolumeProperty");
var vtkVolumeProperty$1 = _objectSpread$4({
  newInstance: newInstance$o,
  extend: extend$q
}, Constants$1);
var vtkDebugMacro$2 = macro.vtkDebugMacro;
function vtkVolume(publicAPI, model) {
  model.classHierarchy.push("vtkVolume");
  publicAPI.getVolumes = function() {
    return publicAPI;
  };
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getProperty = function() {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = function() {
    if (model.mapper === null) {
      return model.bounds;
    }
    var bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    var zip = function zip2(rows) {
      return rows[0].map(function(_, c) {
        return rows.map(function(row) {
          return row[c];
        });
      });
    };
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce(function(a, b) {
      return a && b[0] === b[1];
    }, true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro$2("Recomputing bounds...");
      model.mapperBounds = bds.map(function(x) {
        return x;
      });
      var bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      var tmp4 = new Float64Array(16);
      transpose(tmp4, model.matrix);
      bbox.forEach(function(pt) {
        return transformMat4$1(pt, pt, tmp4);
      });
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map(function(d, i) {
        return i % 2 === 0 ? bbox.reduce(function(a, b) {
          return a > b[i / 2] ? b[i / 2] : a;
        }, d) : bbox.reduce(function(a, b) {
          return a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a;
        }, d);
      });
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = function() {
    var mt = model.mtime;
    if (model.property !== null) {
      var time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = function() {
    var mt = model.mtime;
    if (model.mapper !== null) {
      var time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}
var DEFAULT_VALUES$o = {
  mapper: null,
  property: null,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend$p(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$o, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkVolume(publicAPI, model);
}
var newInstance$n = macro.newInstance(extend$p, "vtkVolume");
var vtkVolume$1 = {
  newInstance: newInstance$n,
  extend: extend$p
};
var CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
var DEFAULT_VALUES$n = {};
function extend$o(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$n, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
macro.newInstance(extend$o, "vtkWebGPUViewNodeFactory");
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = function(outMat, aspect, cRange, windowCenter) {
    identity$1(outMat);
    if (model.renderable.getParallelProjection()) {
      var parallelScale = model.renderable.getParallelScale();
      var width = parallelScale * aspect;
      var height = parallelScale;
      var xmin = (windowCenter[0] - 1) * width;
      var xmax = (windowCenter[0] + 1) * width;
      var ymin = (windowCenter[1] - 1) * height;
      var ymax = (windowCenter[1] + 1) * height;
      var xr = 1 / (xmax - xmin);
      var yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      var tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      var _width;
      var _height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        _width = cRange[0] * tmp;
        _height = cRange[0] * tmp / aspect;
      } else {
        _width = cRange[0] * tmp * aspect;
        _height = cRange[0] * tmp;
      }
      var _xmin = (windowCenter[0] - 1) * _width;
      var _xmax = (windowCenter[0] + 1) * _width;
      var _ymin = (windowCenter[1] - 1) * _height;
      var _ymax = (windowCenter[1] + 1) * _height;
      outMat[0] = 2 * cRange[0] / (_xmax - _xmin);
      outMat[5] = 2 * cRange[0] / (_ymax - _ymin);
      outMat[12] = (_xmin + _xmax) / (_xmax - _xmin);
      outMat[13] = (_ymin + _ymax) / (_ymax - _ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = function(val) {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    var cRange = model.renderable.getClippingRangeByReference();
    var zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = function(webGPURenderer) {
    var ren = webGPURenderer.getRenderable();
    var webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      var wcvc = model.renderable.getViewMatrix();
      copy$1(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      transpose(model.keyMatrices.wcvc, wcvc);
      var center = webGPURenderer.getStabilizedCenterByReference();
      translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      var aspectRatio = webGPURenderer.getAspectRatio();
      var cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      multiply$2(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES$m = {
  keyMatrixTime: null,
  keyMatrices: null
};
function extend$n(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$m, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var newInstance$m = macro.newInstance(extend$n);
registerOverride("vtkCamera", newInstance$m);
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = function(bindables) {
    if (model.bindables.length === bindables.length) {
      var allMatch = true;
      for (var i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = function(device) {
    var entries = [];
    for (var i = 0; i < model.bindables.length; i++) {
      var entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = function(device) {
    var mtime = publicAPI.getMTime();
    for (var i = 0; i < model.bindables.length; i++) {
      var tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    var entries = [];
    for (var _i = 0; _i < model.bindables.length; _i++) {
      var entry = model.bindables[_i].getBindGroupEntry();
      entry.binding = _i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = function(pipeline) {
    var lines = [];
    var bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (var i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join("\n");
  };
}
var DEFAULT_VALUES$l = {
  device: null,
  handle: null,
  label: null
};
function extend$m(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$l, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var newInstance$l = macro.newInstance(extend$m);
var vtkWebGPUBindGroup$1 = {
  newInstance: newInstance$l,
  extend: extend$m
};
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = function(device, shaderDesc) {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
var DEFAULT_VALUES$k = {
  device: null,
  handle: null
};
function extend$l(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$k, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var newInstance$k = macro.newInstance(extend$l, "vtkWebGPUShaderModule");
var vtkWebGPUShaderModule$1 = {
  newInstance: newInstance$k,
  extend: extend$l
};
function substitute(source, search, replace) {
  var all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  var replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  var gflag = "";
  if (all) {
    gflag = "g";
  }
  var regex2 = new RegExp(search, gflag);
  var resultstr = source.replace(regex2, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = function(shaderDesc) {
    var sType = shaderDesc.getType();
    var sHash = shaderDesc.getHash();
    var keys4 = model._shaderModules.keys();
    for (var i = 0; i < keys4.length; i++) {
      var key = keys4[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    var sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
var DEFAULT_VALUES$j = {
  shaderModules: null,
  device: null,
  window: null
};
function extend$k(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$j, initialValues);
  model._shaderModules = /* @__PURE__ */ new Map();
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var newInstance$j = macro.newInstance(extend$k, "vtkWebGPUShaderCache");
var vtkWebGPUShaderCache$1 = {
  newInstance: newInstance$j,
  extend: extend$k,
  substitute
};
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = function() {
    return model.shaderDescriptions;
  };
  publicAPI.initialize = function(device, hash) {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    var bindGroupLayouts = [];
    for (var i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (var _i = 0; _i < model.shaderDescriptions.length; _i++) {
      var sd = model.shaderDescriptions[_i];
      var sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = function(stype) {
    for (var i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype)
        return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = function(bindGroup) {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = function(idx) {
    return model.layouts[idx].layout;
  };
  publicAPI.getBindGroupLayoutCount = function(llabel) {
    for (var i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = function(renderEncoder, vInput) {
    vInput.bindBuffers(renderEncoder);
  };
}
var DEFAULT_VALUES$i = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};
function extend$j(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$i, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var newInstance$i = newInstance$X(extend$j, "vtkWebGPUPipeline");
var vtkWebGPUPipeline$1 = {
  newInstance: newInstance$i,
  extend: extend$j
};
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = function(name) {
    return model.outputNames.includes(name);
  };
  publicAPI.addOutput = function(type, name) {
    var interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = function(type, name) {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = function(type, name) {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = function(priorStage, vertexInput) {
    var inputImpl = [];
    var iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      var inputStruct = [];
      inputStruct.push("struct ".concat(model.type, "Input\n{"));
      if (priorStage) {
        var inputNames = priorStage.getOutputNamesByReference();
        var inputTypes = priorStage.getOutputTypesByReference();
        var inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (var i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== void 0) {
            inputStruct.push("  @location(".concat(i, ") @interpolate(").concat(inputInterpolations[i], ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ","));
          } else {
            inputStruct.push("  @location(".concat(i, ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ","));
          }
        }
      }
      for (var _i = 0; _i < model.builtinInputNames.length; _i++) {
        inputStruct.push("  ".concat(model.builtinInputNames[_i], " : ").concat(model.builtinInputTypes[_i], ","));
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push("input: ".concat(model.type, "Input"));
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      var outputStruct = ["struct ".concat(model.type, "Output\n{")];
      for (var _i2 = 0; _i2 < model.outputNames.length; _i2++) {
        if (model.outputInterpolations[_i2] !== void 0) {
          outputStruct.push("  @location(".concat(_i2, ") @interpolate(").concat(model.outputInterpolations[_i2], ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ","));
        } else {
          outputStruct.push("  @location(".concat(_i2, ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ","));
        }
      }
      for (var _i3 = 0; _i3 < model.builtinOutputNames.length; _i3++) {
        outputStruct.push("  ".concat(model.builtinOutputNames[_i3], " : ").concat(model.builtinOutputTypes[_i3], ","));
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", ["-> ".concat(model.type, "Output")]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
var DEFAULT_VALUES$h = {
  type: null,
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};
function extend$i(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$h, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var newInstance$h = macro.newInstance(extend$i, "vtkWebGPUShaderDescription");
var vtkWebGPUShaderDescription$1 = {
  newInstance: newInstance$h,
  extend: extend$i
};
var textureDetails = {
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "sint"
  },
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "uint"
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "sint"
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: "float"
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "uint"
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "sint"
  },
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "uint"
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "sint"
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "uint"
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "sint"
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: "float"
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "rgba8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "uint"
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "sint"
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "bgra8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: "float"
  },
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "uint"
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "sint"
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "uint"
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "sint"
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: "float"
  },
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "uint"
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "sint"
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "depth"
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: "depth"
  },
  "depth24plus-stencil8": {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "mixed"
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "depth"
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6)
    return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  vtkErrorMacro$j("unknown format ".concat(format));
  return null;
}
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  var sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  var num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro$j("unknown format ".concat(format));
    return 0;
  }
  var typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var result;
  if (format[0] === "f") {
    result = "Float";
  } else if (format[0] === "s") {
    result = "Int";
  } else if (format[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro$j("unknown format ".concat(format));
    return void 0;
  }
  var base = format.split("x")[0];
  var num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro$j("unknown format ".concat(format));
    return void 0;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  var dataType;
  if (format[0] === "f" || format[1] === "n") {
    dataType = "f32";
  } else if (format[0] === "s" && format[1] === "i") {
    dataType = "i32";
  } else if (format[0] === "u" && format[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro$j("unknown format ".concat(format));
    return void 0;
  }
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4)
    return "vec4<".concat(dataType, ">");
  if (numComp === 3)
    return "vec3<".concat(dataType, ">");
  if (numComp === 2)
    return "vec2<".concat(dataType, ">");
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format)
    return 0;
  var numComp = 1;
  if (format.substring(0, 3) === "vec") {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === "mat") {
    numComp = format[3] * format[5];
  }
  var typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format)
    return void 0;
  if (format.includes("f32"))
    return "Float32Array";
  if (format.includes("i32"))
    return "Int32Array";
  if (format.includes("u32"))
    return "Uint32Array";
  vtkErrorMacro$j("unknown format ".concat(format));
  return void 0;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};
function arraysEqual(a, b) {
  if (a === b)
    return true;
  if (a == null || b == null)
    return false;
  if (a.length !== b.length)
    return false;
  for (var i = 0; i < a.length; ++i) {
    if (!b.includes(a[i]))
      return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    var stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
    var names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (var i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort(function(v1, v2) {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = function() {
    var result = "";
    var nameCount = 0;
    for (var i = 0; i < model.inputs.length; i++) {
      for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
        var arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        var type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ",\n";
        }
        result = "".concat(result, "  @location(").concat(nameCount, ") ").concat(model.inputs[i].names[nm], " : ").concat(type);
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = function() {
    var info = {};
    if (model.inputs.length) {
      var vertexBuffers = [];
      var nameCount = 0;
      for (var i = 0; i < model.inputs.length; i++) {
        var buf = model.inputs[i].buffer;
        var buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        var arrayInfo = buf.getArrayInformation();
        for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = function(renderEncoder) {
    for (var i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = function() {
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
var DEFAULT_VALUES$g = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};
function extend$h(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$g, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var newInstance$g = newInstance$X(extend$h, "vtkWebGPUVertexInput");
var vtkWebGPUVertexInput$1 = {
  newInstance: newInstance$g,
  extend: extend$h
};
var vtkWebGPUSimpleMapperVS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n";
var vtkWebGPUSimpleMapperFS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
function vtkWebGPUSimpleMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSimpleMapper");
  publicAPI.generateShaderDescriptions = function(hash, pipeline, vertexInput) {
    var vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    var fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    var sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    var scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    var re = new RegExp("//VTK::[^:]*::", "g");
    var unique = scode.match(re).filter(function(v, i2, a) {
      return a.indexOf(v) === i2;
    });
    var fnames = unique.map(function(v) {
      return "replaceShader".concat(v.substring(7, v.length - 2));
    });
    for (var i = 0; i < fnames.length; i++) {
      var fname = fnames[i];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = function(hash, pipeline, vertexInput) {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = function(hash, pipeline, vertexInput) {
    if (!model.WebGPURenderer) {
      return;
    }
    var ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = function(hash, pipeline, vertexInput) {
    var ubocode = model.bindGroup.getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = function(view) {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.prepareToDraw = function(renderEncoder) {
    model.renderEncoder = renderEncoder;
    publicAPI.updateInput();
    publicAPI.updateBuffers();
    publicAPI.updateBindings();
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = function() {
  };
  publicAPI.updateBuffers = function() {
  };
  publicAPI.updateBindings = function() {
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = function() {
  };
  publicAPI.registerDrawCallback = function(encoder) {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = function(encoder) {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };
  publicAPI.draw = function(renderEncoder) {
    var pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    var indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = function() {
    var bindables = _toConsumableArray(model.additionalBindables);
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (var t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      var samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = function() {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
var DEFAULT_VALUES$f = {
  additionalBindables: void 0,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: "triangle-list",
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};
function extend$g(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$f, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUSimpleMapper(publicAPI, model);
}
var newInstance$f = macro.newInstance(extend$g, "vtkWebGPUSimpleMapper");
var vtkWebGPUSimpleMapper$1 = {
  newInstance: newInstance$f,
  extend: extend$g
};
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    vDesc.addOutput("vec4<f32>", "vertexVC");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = function() {
    var buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
  };
}
var DEFAULT_VALUES$e = {};
function extend$f(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$e, initialValues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var newInstance$e = macro.newInstance(extend$f, "vtkWebGPUFullScreenQuad");
var vtkWebGPUFullScreenQuad$1 = {
  newInstance: newInstance$e,
  extend: extend$f
};
var BufferUsage$3 = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
var PrimitiveTypes$1 = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants = {
  BufferUsage: BufferUsage$3,
  PrimitiveTypes: PrimitiveTypes$1
};
function ownKeys$3(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var forwarded = ["getMappedRange", "mapAsync", "unmap"];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  var byteCount = srcArrayBuffer.byteLength;
  var srcBuffer = device.createBuffer({
    size: byteCount,
    usage: GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  var arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  var encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  var commandBuffer = encoder.finish();
  var queue2 = device.queue;
  queue2.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = function(sizeInBytes, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = function(data) {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = function(data, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  var _loop = function _loop2(i2) {
    publicAPI[forwarded[i2]] = function() {
      var _model$handle;
      return (_model$handle = model.handle)[forwarded[i2]].apply(_model$handle, arguments);
    };
  };
  for (var i = 0; i < forwarded.length; i++) {
    _loop(i);
  }
}
var DEFAULT_VALUES$d = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};
function extend$e(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$d, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var newInstance$d = macro.newInstance(extend$e);
var vtkWebGPUBuffer$1 = _objectSpread$3({
  newInstance: newInstance$d,
  extend: extend$e
}, Constants);
function ownKeys$2(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Representation = vtkProperty$1.Representation;
var PrimitiveTypes = Constants.PrimitiveTypes;
var _LimitedMap = /* @__PURE__ */ function() {
  function _LimitedMap2() {
    _classCallCheck(this, _LimitedMap2);
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  _createClass(_LimitedMap2, [{
    key: "clear",
    value: function clear2() {
      this.count = 0;
    }
  }, {
    key: "has",
    value: function has2(key) {
      for (var i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return true;
        }
      }
      return void 0;
    }
  }, {
    key: "get",
    value: function get2(key) {
      for (var i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return this.values[i];
        }
      }
      return void 0;
    }
  }, {
    key: "set",
    value: function set2(key, value) {
      if (this.count < 9) {
        this.keys[this.count] = key;
        this.values[this.count++] = value;
      }
    }
  }]);
  return _LimitedMap2;
}();
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes.Points:
      return "points";
    case PrimitiveTypes.Lines:
      return "lines";
    case PrimitiveTypes.Triangles:
    case PrimitiveTypes.TriangleEdges:
      return "polys";
    case PrimitiveTypes.TriangleStripEdges:
    case PrimitiveTypes.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function _getOrAddFlatId(state2, ptId, cellId) {
  var flatId = state2.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state2.flatId;
    state2.pointIdToFlatId[ptId] = flatId;
    state2.flatIdToPointId[state2.flatId] = ptId;
    state2.flatIdToCellId[state2.flatId] = cellId;
    state2.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state2) {
  var numPtIds = ptIds.length;
  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    var _ptId = ptIds[ptIdx];
    if (state2.cellProvokedMap.has(_ptId)) {
      state2.ibo[state2.iboId++] = state2.cellProvokedMap.get(_ptId);
      for (var ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        _ptId = ptIds[ptIdx2 % numPtIds];
        var _flatId = _getOrAddFlatId(state2, _ptId, cellId);
        state2.ibo[state2.iboId++] = _flatId;
      }
      return;
    }
  }
  for (var _ptIdx = 0; _ptIdx < numPtIds; _ptIdx++) {
    var _ptId2 = ptIds[_ptIdx];
    if (!state2.provokedPointIds[_ptId2]) {
      var _flatId2 = _getOrAddFlatId(state2, _ptId2, cellId);
      state2.provokedPointIds[_ptId2] = 1;
      state2.cellProvokedMap.set(_ptId2, _flatId2);
      state2.flatIdToCellId[_flatId2] = cellId;
      state2.ibo[state2.iboId++] = _flatId2;
      for (var _ptIdx2 = _ptIdx + 1; _ptIdx2 < _ptIdx + numPtIds; _ptIdx2++) {
        _ptId2 = ptIds[_ptIdx2 % numPtIds];
        _flatId2 = _getOrAddFlatId(state2, _ptId2, cellId);
        state2.ibo[state2.iboId++] = _flatId2;
      }
      return;
    }
  }
  var ptId = ptIds[0];
  var flatId = state2.flatId;
  state2.cellProvokedMap.set(ptId, flatId);
  state2.flatIdToPointId[state2.flatId] = ptId;
  state2.flatIdToCellId[state2.flatId] = cellId;
  state2.flatId++;
  state2.ibo[state2.iboId++] = flatId;
  for (var _ptIdx3 = 1; _ptIdx3 < numPtIds; _ptIdx3++) {
    ptId = ptIds[_ptIdx3];
    flatId = _getOrAddFlatId(state2, ptId, cellId);
    state2.ibo[state2.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state2) {
  var numPtIds = ptIds.length;
  state2.iboSize += numPtIds;
  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    var ptId = ptIds[ptIdx];
    if (state2.cellProvokedMap.has(ptId)) {
      return;
    }
  }
  for (var _ptIdx4 = 0; _ptIdx4 < numPtIds; _ptIdx4++) {
    var _ptId3 = ptIds[_ptIdx4];
    if (!state2.provokedPointIds[_ptId3]) {
      state2.provokedPointIds[_ptId3] = 1;
      state2.cellProvokedMap.set(_ptId3, 1);
      return;
    }
  }
  state2.cellProvokedMap.set(ptIds[0], 1);
  state2.extraPoints++;
}
var processCell;
var _single = new Uint32Array(1);
var _double = new Uint32Array(2);
var _triple = new Uint32Array(3);
var _indexCellBuilders = {
  anythingToPoints: function anythingToPoints(numPoints, cellPts, offset, cellId, state2) {
    for (var i = 0; i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state2);
    }
  },
  linesToWireframe: function linesToWireframe(numPoints, cellPts, offset, cellId, state2) {
    for (var i = 0; i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state2);
    }
  },
  polysToWireframe: function polysToWireframe(numPoints, cellPts, offset, cellId, state2) {
    if (numPoints > 2) {
      for (var i = 0; i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state2);
      }
    }
  },
  stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset, cellId, state2) {
    if (numPoints > 2) {
      for (var i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state2);
      }
      for (var _i = 0; _i < numPoints - 2; _i++) {
        _double[0] = cellPts[offset + _i];
        _double[1] = cellPts[offset + _i + 2];
        processCell(_double, cellId, state2);
      }
    }
  },
  polysToSurface: function polysToSurface(npts, cellPts, offset, cellId, state2) {
    for (var i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state2);
    }
  },
  stripsToSurface: function stripsToSurface(npts, cellPts, offset, cellId, state2) {
    for (var i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state2);
    }
  }
};
function vtkWebGPUIndexBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUIndexBuffer");
  publicAPI.buildIndexBuffer = function(req) {
    var cellArray = req.cells;
    var primitiveType = req.primitiveType;
    var representation = req.representation;
    var cellOffset = req.cellOffset;
    var array = cellArray.getData();
    var cellArraySize = array.length;
    var inRepName = getPrimitiveName(primitiveType);
    var numPts = req.numberOfPoints;
    var state2 = {
      provokedPointIds: new Uint8Array(numPts),
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    var func = null;
    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {
      func = _indexCellBuilders["".concat(inRepName, "ToWireframe")];
    } else {
      func = _indexCellBuilders["".concat(inRepName, "ToSurface")];
    }
    processCell = countCell;
    var cellId = cellOffset || 0;
    for (var cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state2.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state2);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    if (numPts <= 65535) {
      state2.flatIdToPointId = new Uint16Array(numPts + state2.extraPoints);
    } else {
      state2.flatIdToPointId = new Uint32Array(numPts + state2.extraPoints);
    }
    if (numPts + state2.extraPoints < 36863) {
      state2.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state2.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state2.extraPoints <= 65535) {
      state2.ibo = new Uint16Array(state2.iboSize);
      req.format = "uint16";
    } else {
      state2.ibo = new Uint32Array(state2.iboSize);
      req.format = "uint32";
    }
    if (cellId <= 65535) {
      state2.flatIdToCellId = new Uint16Array(numPts + state2.extraPoints);
    } else {
      state2.flatIdToCellId = new Uint32Array(numPts + state2.extraPoints);
    }
    state2.pointIdToFlatId.fill(-1);
    state2.provokedPointIds.fill(0);
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (var _cellArrayIndex = 0; _cellArrayIndex < cellArraySize; ) {
      state2.cellProvokedMap.clear();
      func(array[_cellArrayIndex], array, _cellArrayIndex + 1, cellId, state2);
      _cellArrayIndex += array[_cellArrayIndex] + 1;
      cellId++;
    }
    delete state2.provokedPointIds;
    delete state2.pointIdToFlatId;
    req.nativeArray = state2.ibo;
    model.flatIdToPointId = state2.flatIdToPointId;
    model.flatIdToCellId = state2.flatIdToCellId;
    model.flatSize = state2.flatId;
    model.indexCount = state2.iboId;
  };
}
var DEFAULT_VALUES$c = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};
function extend$d(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$c, initialValues);
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
  vtkWebGPUIndexBuffer(publicAPI, model);
}
var newInstance$c = macro.newInstance(extend$d);
var vtkWebGPUIndexBuffer$1 = _objectSpread$2({
  newInstance: newInstance$c,
  extend: extend$d
}, Constants);
function ownKeys$1(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var BufferUsage$2 = Constants.BufferUsage;
var vtkErrorMacro$3 = vtkErrorMacro$j;
var VtkDataTypes = vtkDataArray$1.VtkDataTypes;
var STATIC = {};
function _getFormatForDataArray(dataArray) {
  var format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes.UNSIGNED_CHAR:
      format = "uint8";
      break;
    case VtkDataTypes.FLOAT:
      format = "float32";
      break;
    case VtkDataTypes.UNSIGNED_INT:
      format = "uint32";
      break;
    case VtkDataTypes.INT:
      format = "sint32";
      break;
    case VtkDataTypes.DOUBLE:
      format = "float32";
      break;
    case VtkDataTypes.UNSIGNED_SHORT:
      format = "uint16";
      break;
    case VtkDataTypes.SHORT:
      format = "sin16";
      break;
    default:
      format = "float32";
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += "x2";
      break;
    case 3:
      if (!format.includes("32")) {
        vtkErrorMacro$3("unsupported x3 type for ".concat(format));
      }
      format += "x3";
      break;
    case 4:
      format += "x4";
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  var result = {};
  var flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }
  var shift = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  var scale2 = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale2 = options.scale;
    } else {
      scale2.fill(options.scale);
    }
  }
  var packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  var addAPoint;
  var vboidx = 0;
  var stride = numComp + (packExtra ? 1 : 0);
  var packedVBO = newTypedArray(outputType, flatSize * stride);
  var flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale2[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale2[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale2[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale2[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale2[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale2[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale2[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale2[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale2[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale2[3] * 1 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale2[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale2[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale2[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale2[3] * inArrayData[i + 3] + shift[3];
    };
  }
  for (var index2 = 0; index2 < flatSize; index2++) {
    var inArrayId = numComp * flatIdMap[index2];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i2) {
  var v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  var v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  var result = [];
  cross(v1, v2, result);
  normalize(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  var pointData = pointArray.getData();
  var cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }
  var packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  var size2 = cellArrayData.length;
  var vboidx = 0;
  for (var index2 = 0; index2 < size2; ) {
    var normal = getNormal(pointData, cellArrayData[index2 + 1], cellArrayData[index2 + 2], cellArrayData[index2 + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index2 += cellArrayData[index2] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    var buffer;
    var gpuUsage;
    if (req.usage === BufferUsage$2.Index) {
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }
    if (req.usage === BufferUsage$2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage$2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage$2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage$2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      var result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? "flat" : "perspective"
      }]);
    }
    if (req.usage === BufferUsage$2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var _arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      var normals = generateNormals(req.cells, req.dataArray);
      var _result = packArray(req.indexBuffer, normals, 4, _arrayType, {
        cellData: true
      });
      buffer.createAndWrite(_result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: "flat"
      }]);
    }
    if (req.usage === BufferUsage$2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = function(hash) {
    return model.device.hasCachedObject(hash);
  };
  publicAPI.getBuffer = function(req) {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = function(dataArray, indexBuffer) {
    var format = _getFormatForDataArray(dataArray);
    var buffRequest = {
      hash: "".concat(dataArray.getMTime(), "I").concat(indexBuffer.getMTime()).concat(format),
      usage: BufferUsage$2.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = function() {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    var array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
var DEFAULT_VALUES$b = {
  device: null,
  fullScreenQuadBuffer: null
};
function extend$c(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$b, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var newInstance$b = newInstance$X(extend$c);
var vtkWebGPUBufferManager$1 = _objectSpread$1(_objectSpread$1({
  newInstance: newInstance$b,
  extend: extend$c
}, STATIC), Constants);
var BufferUsage$1 = vtkWebGPUBufferManager$1.BufferUsage;
var vtkErrorMacro$2 = macro.vtkErrorMacro;
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro$2("entry named ".concat(name, " already exists"));
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    var sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = function(device) {
    if (!model._buffer) {
      var req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage$1.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, instance, val) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$2("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = function(name, instance, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$2("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (var i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$2("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$2("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$2("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = 9;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var j = 0; j < 3; j++) {
        for (var i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = function() {
    return model._sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding2, group) {
    var lines = ["struct ".concat(model.label, "StructEntry\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ","));
    }
    lines.push("\n};\nstruct ".concat(model.label, "Struct\n{\n  values: array<").concat(model.label, "StructEntry>,\n};\n@binding(").concat(binding2, ") @group(").concat(group, ") var<storage, read> ").concat(model.label, ": ").concat(model.label, "Struct;\n"));
    return lines.join("\n");
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = function() {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
var DEFAULT_VALUES$a = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};
function extend$b(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$a, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var newInstance$a = macro.newInstance(extend$b, "vtkWebGPUStorageBuffer");
var vtkWebGPUStorageBuffer$1 = {
  newInstance: newInstance$a,
  extend: extend$b
};
var BufferUsage = vtkWebGPUBufferManager$1.BufferUsage;
var vtkErrorMacro$1 = macro.vtkErrorMacro;
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro$1("entry named ".concat(name, " already exists"));
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = function() {
    if (!model.sortDirty) {
      return;
    }
    var currOffset = 0;
    var newEntries = [];
    var maxAlignment = 4;
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (var _i = 0; _i < model.bufferEntries.length; _i++) {
      var _entry = model.bufferEntries[_i];
      if (_entry.packed === false && _entry.sizeInBytes % 16 === 0) {
        _entry.packed = true;
        _entry.offset = currOffset;
        newEntries.push(_entry);
        currOffset += _entry.sizeInBytes;
      }
    }
    for (var _i2 = 0; _i2 < model.bufferEntries.length; _i2++) {
      var _entry2 = model.bufferEntries[_i2];
      if (_entry2.packed === false && _entry2.sizeInBytes === 12) {
        for (var i2 = 0; i2 < model.bufferEntries.length; i2++) {
          var entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            _entry2.packed = true;
            _entry2.offset = currOffset;
            newEntries.push(_entry2);
            currOffset += _entry2.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i3 = 0; _i3 < model.bufferEntries.length; _i3++) {
      var _entry3 = model.bufferEntries[_i3];
      if (!_entry3.packed && _entry3.sizeInBytes % 8 === 0) {
        for (var _i4 = _i3 + 1; _i4 < model.bufferEntries.length; _i4++) {
          var _entry4 = model.bufferEntries[_i4];
          if (!_entry4.packed && _entry4.sizeInBytes % 8 === 0) {
            _entry3.packed = true;
            _entry3.offset = currOffset;
            newEntries.push(_entry3);
            currOffset += _entry3.sizeInBytes;
            _entry4.packed = true;
            _entry4.offset = currOffset;
            newEntries.push(_entry4);
            currOffset += _entry4.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i5 = 0; _i5 < model.bufferEntries.length; _i5++) {
      var _entry5 = model.bufferEntries[_i5];
      if (!_entry5.packed && _entry5.sizeInBytes % 8 === 0) {
        var found = false;
        for (var _i6 = 0; !found && _i6 < model.bufferEntries.length; _i6++) {
          var _entry6 = model.bufferEntries[_i6];
          if (!_entry6.packed && _entry6.sizeInBytes === 4) {
            for (var i3 = _i6 + 1; i3 < model.bufferEntries.length; i3++) {
              var entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                _entry5.packed = true;
                _entry5.offset = currOffset;
                newEntries.push(_entry5);
                currOffset += _entry5.sizeInBytes;
                _entry6.packed = true;
                _entry6.offset = currOffset;
                newEntries.push(_entry6);
                currOffset += _entry6.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (var _i7 = 0; _i7 < model.bufferEntries.length; _i7++) {
      var _entry7 = model.bufferEntries[_i7];
      if (!_entry7.packed && _entry7.sizeInBytes > 4) {
        _entry7.packed = true;
        _entry7.offset = currOffset;
        newEntries.push(_entry7);
        currOffset += _entry7.sizeInBytes;
      }
    }
    for (var _i8 = 0; _i8 < model.bufferEntries.length; _i8++) {
      var _entry8 = model.bufferEntries[_i8];
      if (!_entry8.packed) {
        _entry8.packed = true;
        _entry8.offset = currOffset;
        newEntries.push(_entry8);
        currOffset += _entry8.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (var _i9 = 0; _i9 < model.bufferEntries.length; _i9++) {
      model._bufferEntryNames.set(model.bufferEntries[_i9].name, _i9);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = function(device) {
    if (!model.UBO) {
      var req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, val) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$1("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = function(name, arr) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro$1("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var changed = false;
    for (var i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = _toConsumableArray(arr);
    }
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = function() {
    return model.sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding2, group) {
    publicAPI.sortBufferEntries();
    var lines = ["struct ".concat(model.label, "Struct\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ","));
    }
    lines.push("};\n@binding(".concat(binding2, ") @group(").concat(group, ") var<uniform> ").concat(model.label, ": ").concat(model.label, "Struct;"));
    return lines.join("\n");
  };
}
var DEFAULT_VALUES$9 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};
function extend$a(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$9, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var newInstance$9 = macro.newInstance(extend$a, "vtkWebGPUUniformBuffer");
var vtkWebGPUUniformBuffer$1 = {
  newInstance: newInstance$9,
  extend: extend$a
};
var vtkDebugMacro$1 = vtkDebugMacro$8;
var clearFragColorTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
var clearFragTextureTemplate = "\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);\n  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);\n  // textureSampleLevel gets rid of some ugly artifacts\n  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0);\n  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
var _fsqClearMat4 = new Float64Array(16);
var _tNormalMat4 = new Float64Array(16);
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = function() {
    var clipRange = model.camera.getClippingRange();
    var pos = model.camera.getPositionByReference();
    var dop = model.camera.getDirectionOfProjectionByReference();
    var center = [];
    var offset = [];
    scale$1(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    add$2(center, pos, offset);
    sub$1(offset, center, model.stabilizedCenter);
    var length2 = len(offset);
    if (length2 / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = function() {
    var count = 0;
    var lights = model.renderable.getLightsByReference();
    for (var index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro$1("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = function() {
    var utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      var _model$renderable$get;
      var keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      model.UBO.setValue("LightCount", model.renderable.getLights().length);
      model.UBO.setValue("MaxEnvironmentMipLevel", (_model$renderable$get = model.renderable.getEnvironmentTexture()) === null || _model$renderable$get === void 0 ? void 0 : _model$renderable$get.getMipLevel());
      model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
      var tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      var device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = function() {
    var lights = model.renderable.getLights();
    var keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    var lightTimeString = "".concat(model.renderable.getMTime());
    for (var i = 0; i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      var lightPosArray = new Float32Array(lights.length * 4);
      var lightDirArray = new Float32Array(lights.length * 4);
      var lightColorArray = new Float32Array(lights.length * 4);
      var lightTypeArray = new Float32Array(lights.length * 4);
      for (var _i = 0; _i < lights.length; _i++) {
        var offset = _i * 4;
        var viewCoordinatePosition = lights[_i].getPosition();
        transformMat4$1(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;
        lightDirArray[offset] = -lights[_i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[_i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[_i].getDirection()[2];
        lightDirArray[offset + 3] = 0;
        lightColorArray[offset] = lights[_i].getColor()[0];
        lightColorArray[offset + 1] = lights[_i].getColor()[1];
        lightColorArray[offset + 2] = lights[_i].getColor()[2];
        lightColorArray[offset + 3] = lights[_i].getIntensity() * 5;
        lightTypeArray[offset] = getLightTypeIndex(lights[_i]);
        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[_i].getConeAngle()));
        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[_i].getConeAngle() + lights[_i].getConeFalloff()));
        lightTypeArray[offset + 3] = 0;
      }
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry("LightPos", "vec4<f32>");
      model.SSBO.addEntry("LightDir", "vec4<f32>");
      model.SSBO.addEntry("LightColor", "vec4<f32>");
      model.SSBO.addEntry("LightData", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
      model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
      model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
      model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
      var device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = function(encoder) {
    var tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = function(renderEncoder) {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = function() {
    var _model$backgroundTex;
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    var device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      var ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && (_model$backgroundTex = model.backgroundTex) !== null && _model$backgroundTex !== void 0 && _model$backgroundTex.getImageLoaded()) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      var _ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      _ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      _ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(_ubo);
      var environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
      if (environmentTextureHash.getReady()) {
        var tview = environmentTextureHash.createView("EnvironmentTexture");
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        var interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
        tview.addSampler(device, {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge",
          addressModeW: "repeat",
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: "linear"
        });
      }
      model.clearFSQ.setPipelineHash("clearfsqwithtexture");
    } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      var _ubo2 = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      _ubo2.addEntry("FSQMatrix", "mat4x4<f32>");
      _ubo2.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(_ubo2);
    }
    var keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    var background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    transpose(_tNormalMat4, keyMats.normalMatrix);
    mul$1(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    mul$1(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = function(prepass) {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = function(prepass) {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = function() {
    var size2 = model._parent.getSizeByReference();
    var viewport = model.renderable.getViewportByReference();
    return size2[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size2[1]);
  };
  publicAPI.convertToOpenGLDepth = function(val) {
    return model.webgpuCamera.convertToOpenGLDepth(val);
  };
  publicAPI.getYInvertedTiledSizeAndOrigin = function() {
    var res = publicAPI.getTiledSizeAndOrigin();
    var size2 = model._parent.getSizeByReference();
    res.lowerLeftV = size2[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = function() {
    var vport = model.renderable.getViewportByReference();
    var tileViewPort = [0, 0, 1, 1];
    var vpu = vport[0] - tileViewPort[0];
    var vpv = vport[1] - tileViewPort[1];
    var ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    var lowerLeftU = Math.round(ndvp[0]);
    var lowerLeftV = Math.round(ndvp[1]);
    var vpu2 = vport[2] - tileViewPort[0];
    var vpv2 = vport[3] - tileViewPort[1];
    var ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    var usize = Math.round(ndvp2[0]) - lowerLeftU;
    var vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = function(id) {
    for (var i = 0; i < model.children.length; i++) {
      var res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = function() {
    return model.stabilizedTime.getMTime();
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
var DEFAULT_VALUES$8 = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20,
  suppressClear: false,
  stabilizedCenter: [0, 0, 0]
};
function extend$9(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$8, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("LightCount", "i32");
  model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
  model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
  model.UBO.addEntry("BackgroundSpecularStrength", "f32");
  model.UBO.addEntry("cameraParallel", "u32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "rendererLightSSBO"
  });
  model.lightTimeString = "";
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = identity$1(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var newInstance$8 = newInstance$X(extend$9, "vtkWebGPURenderer");
registerOverride("vtkRenderer", newInstance$8);
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
    model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
    model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = function(binding2, group) {
    var result = "@binding(".concat(binding2, ") @group(").concat(group, ") var ").concat(model.label, ": sampler;");
    return result;
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: model.handle
    };
    return foo;
  };
}
var DEFAULT_VALUES$7 = {
  device: null,
  handle: null,
  label: null,
  options: null
};
function extend$8(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$7, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    sampler: {}
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var newInstance$7 = macro.newInstance(extend$8);
var vtkWebGPUSampler$1 = {
  newInstance: newInstance$7,
  extend: extend$8
};
var SlicingMode$1 = Constants$3.SlicingMode;
var imgFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Image::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  //VTK::Image::Sample\n\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\n\n//VTK::RenderEncoder::Impl\n\n  return output;\n}\n";
function computeFnToString(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
var tmp3Mat4 = new Float64Array(16);
var ptsArray1 = new Float64Array(4);
var ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      var ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = function() {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = function() {
    var ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = function() {
    var utime = model.UBO.getSendTime();
    var actor = model.WebGPUImageSlice.getRenderable();
    var volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      var image = volMapr.getInputData();
      var center = model.WebGPURenderer.getStabilizedCenterByReference();
      identity$1(tmpMat4);
      translate(tmpMat4, tmpMat4, center);
      var mcwcmat = actor.getMatrix();
      transpose(tmp2Mat4, mcwcmat);
      invert(tmp2Mat4, tmp2Mat4);
      multiply$2(tmpMat4, tmp2Mat4, tmpMat4);
      var modelToIndex = image.getWorldToIndex();
      multiply$2(tmpMat4, modelToIndex, tmpMat4);
      invert(tmp3Mat4, tmpMat4);
      fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      multiply$2(tmpMat4, tmp2Mat4, tmpMat4);
      var dims = image.getDimensions();
      identity$1(tmp2Mat4);
      scale$2(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      multiply$2(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      var ext = model.currentInput.getExtent();
      var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
      var nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      var axis0 = 2;
      var axis1 = 0;
      var axis2 = 1;
      if (ijkMode === SlicingMode$1.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode$1.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1;
      transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1;
      transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      subtract$2(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1;
      transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      subtract$2(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      var cScale = [1, 1, 1, 1];
      var cShift = [0, 0, 0, 0];
      var tView = model.textureViews[0];
      var tScale = tView.getTexture().getScale();
      var numComp = tView.getTexture().getNumberOfComponents();
      var iComps = false;
      for (var i = 0; i < numComp; i++) {
        var cw = actor.getProperty().getColorWindow();
        var cl = actor.getProperty().getColorLevel();
        var target = iComps ? i : 0;
        var cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          var cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = function() {
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    var numIComps = 1;
    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(model.rowLength * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (var _i = 0; _i < model.rowLength; _i++) {
              var _idx = c * model.rowLength * 8 + _i * 4;
              colorArray[_idx] = 255 * tmpTable[_i * 3];
              colorArray[_idx + 1] = 255 * tmpTable[_i * 3 + 1];
              colorArray[_idx + 2] = 255 * tmpTable[_i * 3 + 2];
              colorArray[_idx + 3] = 255;
              for (var _j = 0; _j < 4; _j++) {
                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];
              }
            }
          }
        }
      } else {
        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {
          var grey = 255 * _i2 / (model.rowLength - 1);
          colorArray[_i2 * 4] = grey;
          colorArray[_i2 * 4 + 1] = grey;
          colorArray[_i2 * 4 + 2] = grey;
          colorArray[_i2 * 4 + 3] = 255;
          for (var _j2 = 0; _j2 < 4; _j2++) {
            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];
          }
        }
      }
      {
        var treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        var newTex = model.device.getTextureManager().getTexture(treq);
        var tview = newTex.createView("tfunTexture");
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  var superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = function() {
    superClassUpdateBuffers();
    var newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    var tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      var tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var iType = actorProperty.getInterpolationType() === InterpolationType$3.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  var sr2 = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    var lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr2.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr2.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = function(hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription("fragment");
    var code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var coord: vec2<f32> =", "      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);", "    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);"]).result;
    fDesc.setCode(code);
  };
  sr2.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
var DEFAULT_VALUES$6 = {
  rowLength: 1024
};
function extend$7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$6, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = identity$1(new Float64Array(16));
  model.imagematinv = identity$1(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var newInstance$6 = newInstance$X(extend$7, "vtkWebGPUImageMapper");
registerOverride("vtkImageMapper", newInstance$6);
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = function(wgpuRen) {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        identity$1(model.keyMatrices.normalMatrix);
      } else {
        copy$1(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES$5 = {
  bufferShift: void 0,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: void 0
};
function extend$6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$5, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: identity$1(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var newInstance$5 = newInstance$X(extend$6, "vtkWebGPUImageSlice");
registerOverride("vtkImageSlice", newInstance$5);
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      var bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  var idx = new Float64Array(3);
  var vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = function(result, offset) {
    var input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    var extent = input.getExtent();
    var m = model.renderable.getMatrix();
    var count = 0;
    for (var iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (var iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (var ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          var poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      transpose(model.keyMatrices.bcwc, mcwc);
      translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES$4 = {
  propID: void 0,
  keyMatricesTime: null
};
function extend$5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var newInstance$4 = macro.newInstance(extend$5, "vtkWebGPUVolume");
registerOverride("vtkVolume", newInstance$4);
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = function(prepass, renderPass) {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    var aspectRatio = model.WebGPURenderer.getAspectRatio();
    var camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    var tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    var texels = null;
    if (model.renderable.getUseZValues())
      ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
var DEFAULT_VALUES$3 = {};
function extend$4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$3, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance$3 = macro.newInstance(extend$4, "vtkWebGPUPixelSpaceCallbackMapper");
registerOverride("vtkPixelSpaceCallbackMapper", newInstance$3);
function createInternalVTKRepresentation({ dimensions, metadata, spacing, direction, origin, scalarData }) {
  const { PhotometricInterpretation } = metadata;
  let numComponents = 1;
  if (PhotometricInterpretation === "RGB") {
    numComponents = 3;
  }
  const scalarArray = vtkDataArray$1.newInstance({
    name: "Pixels",
    numberOfComponents: numComponents,
    values: scalarData
  });
  const imageData = vtkImageData$1.newInstance();
  imageData.setDimensions(dimensions);
  imageData.setSpacing(spacing);
  imageData.setDirection(direction);
  imageData.setOrigin(origin);
  imageData.getPointData().setScalars(scalarArray);
  return imageData;
}
const volumeLoaders = {};
function loadVolumeFromVolumeLoader(volumeId, options) {
  const colonIndex = volumeId.indexOf(":");
  const scheme = volumeId.substring(0, colonIndex);
  const loader = volumeLoaders[scheme];
  if (loader === void 0 || loader === null) {
    throw new Error("loadVolumeFromVolumeLoader: no volume loader for volumeId");
  }
  const volumeLoadObject = loader(volumeId, options);
  volumeLoadObject.promise.then(function(volume) {
    triggerEvent(eventTarget$1, Events$2.VOLUME_LOADED, { volume });
  }, function(error) {
    const errorObject = {
      volumeId,
      error
    };
    triggerEvent(eventTarget$1, Events$2.VOLUME_LOADED_FAILED, errorObject);
  });
  return volumeLoadObject;
}
function loadVolume(volumeId, options = { imageIds: [] }) {
  if (volumeId === void 0) {
    throw new Error("loadVolume: parameter volumeId must not be undefined");
  }
  let volumeLoadObject = cache$1.getVolumeLoadObject(volumeId);
  if (volumeLoadObject !== void 0) {
    return volumeLoadObject.promise;
  }
  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);
  return volumeLoadObject.promise.then((volume) => {
    volume.imageData = createInternalVTKRepresentation(volume);
    return volume;
  });
}
function createVolumeMapper(imageData, vtkOpenGLTexture2) {
  const volumeMapper = vtkSharedVolumeMapper$1.newInstance();
  volumeMapper.setInputData(imageData);
  const spacing = imageData.getSpacing();
  const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;
  volumeMapper.setMaximumSamplesPerRay(4e3);
  volumeMapper.setSampleDistance(sampleDistance);
  volumeMapper.setScalarTexture(vtkOpenGLTexture2);
  return volumeMapper;
}
const PRIORITY = 0;
const REQUEST_TYPE = RequestType$1.Prefetch;
async function setDefaultVolumeVOI(volumeActor, imageVolume) {
  let voi = getVOIFromMetadata(imageVolume);
  if (!voi) {
    voi = await getVOIFromMinMax(imageVolume);
  }
  if (!voi || voi.lower === void 0 || voi.upper === void 0) {
    throw new Error("Could not get VOI from metadata, nor from the min max of the image middle slice");
  }
  voi = handlePreScaledVolume(imageVolume, voi);
  const { lower, upper } = voi;
  volumeActor.getProperty().getRGBTransferFunction(0).setMappingRange(lower, upper);
}
function handlePreScaledVolume(imageVolume, voi) {
  const imageIds = imageVolume.imageIds;
  const imageIdIndex = Math.floor(imageIds.length / 2);
  const imageId = imageIds[imageIdIndex];
  const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
  if (generalSeriesModule.modality === "PT" && imageVolume.isPrescaled) {
    return {
      lower: 0,
      upper: 5
    };
  }
  return voi;
}
function getVOIFromMetadata(imageVolume) {
  const { imageIds } = imageVolume;
  const imageIdIndex = Math.floor(imageIds.length / 2);
  const imageId = imageIds[imageIdIndex];
  const voiLutModule = getMetaData("voiLutModule", imageId);
  if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {
    const { windowWidth, windowCenter } = voiLutModule;
    const voi = {
      windowWidth: Array.isArray(windowWidth) ? windowWidth[0] : windowWidth,
      windowCenter: Array.isArray(windowCenter) ? windowCenter[0] : windowCenter
    };
    const { lower, upper } = toLowHighRange(Number(voi.windowWidth), Number(voi.windowCenter));
    return {
      lower,
      upper
    };
  }
}
async function getVOIFromMinMax(imageVolume) {
  const { scalarData, imageIds } = imageVolume;
  const imageIdIndex = Math.floor(imageIds.length / 2);
  const imageId = imageVolume.imageIds[imageIdIndex];
  const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
  const { modality } = generalSeriesModule;
  const modalityLutModule = getMetaData("modalityLutModule", imageId) || {};
  const numImages = imageIds.length;
  const bytesPerImage = scalarData.byteLength / numImages;
  const voxelsPerImage = scalarData.length / numImages;
  const bytePerPixel = scalarData.BYTES_PER_ELEMENT;
  let type;
  if (scalarData instanceof Uint8Array) {
    type = "Uint8Array";
  } else if (scalarData instanceof Float32Array) {
    type = "Float32Array";
  } else {
    throw new Error("Unsupported array type");
  }
  const scalingParameters = {
    rescaleSlope: modalityLutModule.rescaleSlope,
    rescaleIntercept: modalityLutModule.rescaleIntercept,
    modality
  };
  let scalingParametersToUse;
  if (modality === "PT") {
    const suvFactor = getMetaData("scalingModule", imageId);
    if (suvFactor) {
      scalingParametersToUse = {
        ...scalingParameters,
        suvbw: suvFactor.suvbw
      };
    }
  }
  const byteOffset = imageIdIndex * bytesPerImage;
  const options = {
    targetBuffer: {
      arrayBuffer: scalarData.buffer,
      offset: byteOffset,
      length: voxelsPerImage,
      type
    },
    priority: PRIORITY,
    requestType: REQUEST_TYPE,
    preScale: {
      enabled: true,
      scalingParameters: scalingParametersToUse
    }
  };
  const image = await loadAndCacheImage(imageId, options);
  let imageScalarData;
  if (!image) {
    imageScalarData = _getImageScalarDataFromImageVolume(imageVolume, byteOffset, bytePerPixel, voxelsPerImage);
  } else {
    imageScalarData = image.getPixelData();
  }
  const { min: min2, max: max2 } = getMinMax(imageScalarData);
  return {
    lower: min2,
    upper: max2
  };
}
function _getImageScalarDataFromImageVolume(imageVolume, byteOffset, bytePerPixel, voxelsPerImage) {
  const { scalarData } = imageVolume;
  const { volumeBuffer } = scalarData;
  if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {
    byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;
  }
  const TypedArray2 = scalarData.constructor;
  const imageScalarData = new TypedArray2(voxelsPerImage);
  const volumeBufferView = new TypedArray2(volumeBuffer, byteOffset, voxelsPerImage);
  imageScalarData.set(volumeBufferView);
  return imageScalarData;
}
async function createVolumeActor(props, element, viewportId, suppressEvents = false) {
  const { volumeId, callback, blendMode } = props;
  const imageVolume = await loadVolume(volumeId);
  if (!imageVolume) {
    throw new Error(`imageVolume with id: ${imageVolume.volumeId} does not exist`);
  }
  const { imageData, vtkOpenGLTexture: vtkOpenGLTexture2 } = imageVolume;
  const volumeMapper = createVolumeMapper(imageData, vtkOpenGLTexture2);
  if (blendMode) {
    volumeMapper.setBlendMode(blendMode);
  }
  const volumeActor = vtkVolume$1.newInstance();
  volumeActor.setMapper(volumeMapper);
  if (imageVolume.imageIds) {
    await setDefaultVolumeVOI(volumeActor, imageVolume);
  }
  if (callback) {
    callback({ volumeActor, volumeId });
  }
  if (!suppressEvents) {
    triggerVOIModified(element, viewportId, volumeActor, volumeId);
  }
  return volumeActor;
}
function triggerVOIModified(element, viewportId, volumeActor, volumeId) {
  const voiRange = volumeActor.getProperty().getRGBTransferFunction(0).getRange();
  const voiModifiedEventDetail = {
    viewportId,
    range: {
      lower: voiRange[0],
      upper: voiRange[1]
    },
    volumeId
  };
  triggerEvent(element, Events$2.VOI_MODIFIED, voiModifiedEventDetail);
}
const state$1 = {};
function resetVolumeNewImageState(viewportId) {
  if (state$1[viewportId] !== void 0) {
    delete state$1[viewportId];
  }
}
function volumeNewImageEventDispatcher(cameraEvent) {
  const { renderingEngineId, viewportId } = cameraEvent.detail;
  const renderingEngine = getRenderingEngine(renderingEngineId);
  const viewport = renderingEngine.getViewport(viewportId);
  if (!(viewport instanceof BaseVolumeViewport$1)) {
    throw new Error(`volumeNewImageEventDispatcher: viewport is not a BaseVolumeViewport`);
  }
  if (state$1[viewport.id] === void 0) {
    state$1[viewport.id] = 0;
  }
  const { numberOfSlices, imageIndex } = getImageSliceDataForVolumeViewport(viewport);
  if (state$1[viewport.id] === imageIndex) {
    return;
  }
  state$1[viewport.id] = imageIndex;
  const eventDetail = {
    imageIndex,
    viewportId,
    renderingEngineId,
    numberOfSlices
  };
  triggerEvent(viewport.element, Events$2.VOLUME_NEW_IMAGE, eventDetail);
}
let useCPURendering = false;
function getShouldUseCPURendering() {
  return useCPURendering;
}
class BaseVolumeViewport extends Viewport$1 {
  constructor(props) {
    super(props);
    this.useCPURendering = false;
    this.getFrameOfReferenceUID = () => {
      return this._FrameOfReferenceUID;
    };
    this.canvasToWorld = (canvasPos) => {
      const vtkCamera2 = this.getVtkActiveCamera();
      vtkCamera2.setIsPerformingCoordinateTransformation(true);
      const renderer3 = this.getRenderer();
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size2 = openGLRenderWindow.getSize();
      const devicePixelRatio = window.devicePixelRatio || 1;
      const canvasPosWithDPR = [
        canvasPos[0] * devicePixelRatio,
        canvasPos[1] * devicePixelRatio
      ];
      const displayCoord = [
        canvasPosWithDPR[0] + this.sx,
        canvasPosWithDPR[1] + this.sy
      ];
      displayCoord[1] = size2[1] - displayCoord[1];
      const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer3);
      vtkCamera2.setIsPerformingCoordinateTransformation(false);
      return [worldCoord[0], worldCoord[1], worldCoord[2]];
    };
    this.worldToCanvas = (worldPos) => {
      const vtkCamera2 = this.getVtkActiveCamera();
      vtkCamera2.setIsPerformingCoordinateTransformation(true);
      const renderer3 = this.getRenderer();
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size2 = openGLRenderWindow.getSize();
      const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer3);
      displayCoord[1] = size2[1] - displayCoord[1];
      const canvasCoord = [
        displayCoord[0] - this.sx,
        displayCoord[1] - this.sy
      ];
      const devicePixelRatio = window.devicePixelRatio || 1;
      const canvasCoordWithDPR = [
        canvasCoord[0] / devicePixelRatio,
        canvasCoord[1] / devicePixelRatio
      ];
      vtkCamera2.setIsPerformingCoordinateTransformation(false);
      return canvasCoordWithDPR;
    };
    this.hasImageURI = (imageURI) => {
      const volumeActors = this.getActors().filter(({ actor }) => actor.isA("vtkVolume"));
      return volumeActors.some(({ uid: uid2 }) => {
        const volume = cache$1.getVolume(uid2);
        if (!volume || !volume.imageIds) {
          return false;
        }
        const volumeImageURIs = volume.imageIds.map(imageIdToURI);
        return volumeImageURIs.includes(imageURI);
      });
    };
    this.getCurrentImageIdIndex = () => {
      throw new Error("Method not implemented.");
    };
    this.getCurrentImageId = () => {
      throw new Error("Method not implemented.");
    };
    this.useCPURendering = getShouldUseCPURendering();
    if (this.useCPURendering) {
      throw new Error("VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.");
    }
    const renderer2 = this.getRenderer();
    const camera = vtkSlabCamera$1.newInstance();
    renderer2.setActiveCamera(camera);
    switch (this.type) {
      case ViewportType$1.ORTHOGRAPHIC:
        camera.setParallelProjection(true);
        break;
      case ViewportType$1.VOLUME_3D:
        camera.setParallelProjection(true);
        break;
      case ViewportType$1.PERSPECTIVE:
        camera.setParallelProjection(false);
        break;
      default:
        throw new Error(`Unrecognized viewport type: ${this.type}`);
    }
    this.initializeVolumeNewImageEventDispatcher();
  }
  static get useCustomRenderingPipeline() {
    return false;
  }
  initializeVolumeNewImageEventDispatcher() {
    const volumeNewImageHandlerBound = volumeNewImageHandler.bind(this);
    const volumeNewImageCleanUpBound = volumeNewImageCleanUp.bind(this);
    function volumeNewImageHandler(cameraEvent) {
      const { viewportId } = cameraEvent.detail;
      if (viewportId !== this.id || this.isDisabled) {
        return;
      }
      const viewportImageData = this.getImageData();
      if (!viewportImageData) {
        return;
      }
      volumeNewImageEventDispatcher(cameraEvent);
    }
    function volumeNewImageCleanUp(evt) {
      const { viewportId } = evt.detail;
      if (viewportId !== this.id) {
        return;
      }
      this.element.removeEventListener(Events$2.CAMERA_MODIFIED, volumeNewImageHandlerBound);
      eventTarget$1.removeEventListener(Events$2.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
      resetVolumeNewImageState(viewportId);
    }
    this.element.removeEventListener(Events$2.CAMERA_MODIFIED, volumeNewImageHandlerBound);
    this.element.addEventListener(Events$2.CAMERA_MODIFIED, volumeNewImageHandlerBound);
    eventTarget$1.addEventListener(Events$2.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
  }
  setProperties({ voiRange } = {}, volumeId, suppressEvents = false) {
    if (volumeId !== void 0 && !this.getActor(volumeId)) {
      return;
    }
    const actorEntries = this.getActors();
    if (!actorEntries.length) {
      return;
    }
    let volumeActor;
    if (volumeId) {
      const actorEntry = actorEntries.find((entry) => {
        return entry.uid === volumeId;
      });
      volumeActor = actorEntry == null ? void 0 : actorEntry.actor;
    }
    if (!volumeActor) {
      volumeActor = actorEntries[0].actor;
      volumeId = actorEntries[0].uid;
    }
    if (!voiRange) {
      return;
    }
    const { lower, upper } = voiRange;
    volumeActor.getProperty().getRGBTransferFunction(0).setRange(lower, upper);
    if (!suppressEvents) {
      const eventDetail = {
        viewportId: this.id,
        range: voiRange,
        volumeId
      };
      triggerEvent(this.element, Events$2.VOI_MODIFIED, eventDetail);
    }
  }
  async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache$1.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    const FrameOfReferenceUID = firstImageVolume.metadata.FrameOfReferenceUID;
    await this._isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID);
    this._FrameOfReferenceUID = FrameOfReferenceUID;
    const volumeActors = [];
    for (let i = 0; i < volumeInputArray.length; i++) {
      const { volumeId, actorUID, slabThickness } = volumeInputArray[i];
      const actor = await createVolumeActor(volumeInputArray[i], this.element, this.id, suppressEvents);
      const uid2 = actorUID || volumeId;
      volumeActors.push({
        uid: uid2,
        actor,
        slabThickness,
        referenceId: volumeId
      });
    }
    this._setVolumeActors(volumeActors);
    triggerEvent(this.element, Events$2.VOLUME_VIEWPORT_NEW_VOLUME, {
      viewportId: this.id,
      volumeActors
    });
    if (immediate) {
      this.render();
    }
  }
  async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache$1.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    const volumeActors = [];
    await this._isValidVolumeInputArray(volumeInputArray, this._FrameOfReferenceUID);
    for (let i = 0; i < volumeInputArray.length; i++) {
      const { volumeId, visibility, actorUID, slabThickness } = volumeInputArray[i];
      const actor = await createVolumeActor(volumeInputArray[i], this.element, this.id, suppressEvents);
      if (visibility === false) {
        actor.setVisibility(false);
      }
      const uid2 = actorUID || volumeId;
      volumeActors.push({
        uid: uid2,
        actor,
        slabThickness,
        referenceId: volumeId
      });
    }
    this.addActors(volumeActors);
    if (immediate) {
      this.render();
    }
  }
  removeVolumeActors(actorUIDs, immediate = false) {
    this.removeActors(actorUIDs);
    if (immediate) {
      this.render();
    }
  }
  setOrientation(orientation, immediate = true) {
    console.warn('Method "setOrientation" needs implementation');
  }
  async _isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID) {
    const numVolumes = volumeInputArray.length;
    for (let i = 1; i < numVolumes; i++) {
      const volumeInput = volumeInputArray[i];
      const imageVolume = await loadVolume(volumeInput.volumeId);
      if (!imageVolume) {
        throw new Error(`imageVolume with id: ${imageVolume.volumeId} does not exist`);
      }
      if (FrameOfReferenceUID !== imageVolume.metadata.FrameOfReferenceUID) {
        throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
      }
    }
    return true;
  }
  getBounds() {
    const renderer2 = this.getRenderer();
    const bounds = renderer2.computeVisiblePropBounds();
    return bounds;
  }
  flip(flipDirection) {
    super.flip(flipDirection);
  }
  hasVolumeId(volumeId) {
    const actorEntries = this.getActors();
    return actorEntries.some((actorEntry) => {
      return actorEntry.uid === volumeId;
    });
  }
  getImageData(volumeId) {
    var _a2;
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    const { uid: defaultActorUID } = defaultActor;
    volumeId = volumeId ?? defaultActorUID;
    const { actor } = this.getActor(volumeId);
    if (!actor.isA("vtkVolume")) {
      return;
    }
    const volume = cache$1.getVolume(volumeId);
    const vtkImageData2 = actor.getMapper().getInputData();
    return {
      dimensions: vtkImageData2.getDimensions(),
      spacing: vtkImageData2.getSpacing(),
      origin: vtkImageData2.getOrigin(),
      direction: vtkImageData2.getDirection(),
      scalarData: vtkImageData2.getPointData().getScalars().getData(),
      imageData: actor.getMapper().getInputData(),
      metadata: {
        Modality: (_a2 = volume == null ? void 0 : volume.metadata) == null ? void 0 : _a2.Modality
      },
      scaling: volume == null ? void 0 : volume.scaling,
      hasPixelSpacing: true
    };
  }
  _setVolumeActors(volumeActorEntries) {
    this.setActors(volumeActorEntries);
  }
  resetCamera(resetPan, resetZoom, resetToCenter) {
    return super.resetCamera(resetPan, resetZoom, resetToCenter);
  }
  getIntensityFromWorld(point) {
    throw new Error("Method not implemented.");
  }
  setBlendMode(blendMode, filterActorUIDs, immediate) {
    throw new Error("Method not implemented.");
  }
  setSlabThickness(slabThickness, filterActorUIDs) {
    throw new Error("Method not implemented.");
  }
  getSlabThickness() {
    throw new Error("Method not implemented.");
  }
}
const BaseVolumeViewport$1 = BaseVolumeViewport;
class VolumeViewport extends BaseVolumeViewport$1 {
  constructor(props) {
    super(props);
    this._useAcquisitionPlaneForViewPlane = false;
    this.getCurrentImageIdIndex = () => {
      return this._getImageIdIndex();
    };
    this.getCurrentImageId = () => {
      const index2 = this._getImageIdIndex();
      if (isNaN(index2)) {
        return;
      }
      const { uid: uid2, actor } = this.getDefaultActor();
      if (!actor.isA("vtkVolume")) {
        return;
      }
      const volume = cache$1.getVolume(uid2);
      if (!volume) {
        return;
      }
      const imageIds = volume.imageIds;
      return imageIds[index2];
    };
    this._getImageIdIndex = () => {
      const { viewPlaneNormal, focalPoint } = this.getCamera();
      const { direction, origin, spacing } = this.getImageData();
      const dir = direction.slice(direction.length - 3);
      const dot2 = Math.abs(dir[0] * viewPlaneNormal[0] + dir[1] * viewPlaneNormal[1] + dir[2] * viewPlaneNormal[2]);
      if (dot2 - 1 > EPSILON$7) {
        return;
      }
      const spacingInNormal = spacing[2];
      const sub2 = create$3();
      sub$1(sub2, focalPoint, origin);
      const distance2 = dot$1(sub2, viewPlaneNormal);
      return Math.round(Math.abs(distance2) / spacingInNormal);
    };
    const { orientation } = this.options;
    if (orientation && orientation !== OrientationAxis$1.ACQUISITION) {
      const { viewPlaneNormal, viewUp } = this._getOrientationVectors(orientation);
      const camera = this.getVtkActiveCamera();
      camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
      camera.setViewUpFrom(viewUp);
      this.resetCamera();
      return;
    }
    this._useAcquisitionPlaneForViewPlane = true;
  }
  async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache$1.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    if (this._useAcquisitionPlaneForViewPlane) {
      this._setViewPlaneToAcquisitionPlane(firstImageVolume);
      this._useAcquisitionPlaneForViewPlane = false;
    }
    return super.setVolumes(volumeInputArray, immediate, suppressEvents);
  }
  async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache$1.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    if (this._useAcquisitionPlaneForViewPlane) {
      this._setViewPlaneToAcquisitionPlane(firstImageVolume);
      this._useAcquisitionPlaneForViewPlane = false;
    }
    return super.addVolumes(volumeInputArray, immediate, suppressEvents);
  }
  setOrientation(orientation, immediate = true) {
    let viewPlaneNormal, viewUp;
    if (MPR_CAMERA_VALUES$1[orientation]) {
      ({ viewPlaneNormal, viewUp } = MPR_CAMERA_VALUES$1[orientation]);
    } else if (orientation === "acquisition") {
      ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
    } else {
      throw new Error(`Invalid orientation: ${orientation}. Use Enums.OrientationAxis instead.`);
    }
    this.setCamera({
      viewPlaneNormal,
      viewUp
    });
    this.resetCamera();
    if (immediate) {
      this.render();
    }
  }
  _getOrientationVectors(orientation) {
    if (typeof orientation === "object") {
      if (orientation.viewPlaneNormal && orientation.viewUp) {
        return orientation;
      } else {
        throw new Error("Invalid orientation object. It must contain viewPlaneNormal and viewUp");
      }
    } else if (typeof orientation === "string" && MPR_CAMERA_VALUES$1[orientation]) {
      return MPR_CAMERA_VALUES$1[orientation];
    } else {
      throw new Error(`Invalid orientation: ${orientation}. Valid orientations are: ${Object.keys(MPR_CAMERA_VALUES$1).join(", ")}`);
    }
  }
  _getAcquisitionPlaneOrientation() {
    const actorEntry = this.getDefaultActor();
    if (!actorEntry) {
      return;
    }
    const volumeId = actorEntry.uid;
    const imageVolume = cache$1.getVolume(volumeId);
    if (!imageVolume) {
      throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
    }
    const { direction } = imageVolume;
    const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
    const viewUp = direction.slice(3, 6).map((x) => -x);
    return {
      viewPlaneNormal,
      viewUp
    };
  }
  _setViewPlaneToAcquisitionPlane(imageVolume) {
    let viewPlaneNormal, viewUp;
    if (imageVolume) {
      const { direction } = imageVolume;
      viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
      viewUp = direction.slice(3, 6).map((x) => -x);
    } else {
      ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
    }
    this.setCamera({
      viewPlaneNormal,
      viewUp
    });
    this.resetCamera();
  }
  getIntensityFromWorld(point) {
    const { actor, uid: uid2 } = this.getDefaultActor();
    if (!actor.isA("vtkVolume")) {
      return;
    }
    const imageData = actor.getMapper().getInputData();
    const volume = cache$1.getVolume(uid2);
    const { dimensions } = volume;
    const index2 = transformWorldToIndex(imageData, point);
    const voxelIndex = index2[2] * dimensions[0] * dimensions[1] + index2[1] * dimensions[0] + index2[0];
    return volume.scalarData[voxelIndex];
  }
  setBlendMode(blendMode, filterActorUIDs = [], immediate = false) {
    let actorEntries = this.getActors();
    if (filterActorUIDs && filterActorUIDs.length > 0) {
      actorEntries = actorEntries.filter((actorEntry) => {
        return filterActorUIDs.includes(actorEntry.uid);
      });
    }
    actorEntries.forEach((actorEntry) => {
      const { actor } = actorEntry;
      const mapper = actor.getMapper();
      mapper.setBlendMode(blendMode);
    });
    if (immediate) {
      this.render();
    }
  }
  resetCamera(resetPan = true, resetZoom = true, resetToCenter = true) {
    super.resetCamera(resetPan, resetZoom, resetToCenter);
    const activeCamera = this.getVtkActiveCamera();
    if (activeCamera.getParallelProjection()) {
      activeCamera.setClippingRange(-RENDERING_DEFAULTS$2.MAXIMUM_RAY_DISTANCE, RENDERING_DEFAULTS$2.MAXIMUM_RAY_DISTANCE);
    } else {
      activeCamera.setClippingRange(RENDERING_DEFAULTS$2.MINIMUM_SLAB_THICKNESS, RENDERING_DEFAULTS$2.MAXIMUM_RAY_DISTANCE);
    }
    const viewPlaneNormal = activeCamera.getViewPlaneNormal();
    const focalPoint = activeCamera.getFocalPoint();
    const actorEntries = this.getActors();
    actorEntries.forEach((actorEntry) => {
      if (!actorEntry.actor || !actorEntry.actor.isA("vtkVolume")) {
        return;
      }
      const mapper = actorEntry.actor.getMapper();
      const vtkPlanes = mapper.getClippingPlanes();
      if (vtkPlanes.length === 0) {
        const clipPlane1 = vtkPlane$1.newInstance();
        const clipPlane2 = vtkPlane$1.newInstance();
        const newVtkPlanes = [clipPlane1, clipPlane2];
        let slabThickness = RENDERING_DEFAULTS$2.MINIMUM_SLAB_THICKNESS;
        if (actorEntry.slabThickness) {
          slabThickness = actorEntry.slabThickness;
        }
        this.setOrientationOfClippingPlanes(newVtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
        mapper.addClippingPlane(clipPlane1);
        mapper.addClippingPlane(clipPlane2);
      }
    });
    return true;
  }
  setSlabThickness(slabThickness, filterActorUIDs = []) {
    let actorEntries = this.getActors();
    if (filterActorUIDs && filterActorUIDs.length > 0) {
      actorEntries = actorEntries.filter((actorEntry) => {
        return filterActorUIDs.includes(actorEntry.uid);
      });
    }
    actorEntries.forEach((actorEntry) => {
      const { actor } = actorEntry;
      if (actor.isA("vtkVolume")) {
        actorEntry.slabThickness = slabThickness;
      }
    });
    const currentCamera = this.getCamera();
    this.updateClippingPlanesForActors(currentCamera);
    this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
  }
  getSlabThickness() {
    const actors = this.getActors();
    let slabThickness = RENDERING_DEFAULTS$2.MINIMUM_SLAB_THICKNESS;
    actors.forEach((actor) => {
      if (actor.slabThickness > slabThickness) {
        slabThickness = actor.slabThickness;
      }
    });
    return slabThickness;
  }
}
const VolumeViewport$1 = VolumeViewport;
function ownKeys(object3, enumerableOnly) {
  var keys4 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI, otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;
var vtkWarningMacro = macro.vtkWarningMacro;
var SlicingMode = Constants$3.SlicingMode;
function vtkImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkImageMapper");
  publicAPI.getSliceAtPosition = function(pos) {
    var image = publicAPI.getInputData();
    var pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      var bds = image.getBounds();
      switch (model.slicingMode) {
        case SlicingMode.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    var ijk = [0, 0, 0];
    image.worldToIndex(pos3, ijk);
    var ex = image.getExtent();
    var _publicAPI$getClosest = publicAPI.getClosestIJKAxis(), ijkMode = _publicAPI$getClosest.ijkMode;
    var slice2 = 0;
    switch (ijkMode) {
      case SlicingMode.I:
        slice2 = clampValue(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode.J:
        slice2 = clampValue(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode.K:
        slice2 = clampValue(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice2;
  };
  publicAPI.setSliceFromCamera = function(cam) {
    var fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode.I:
      case SlicingMode.J:
      case SlicingMode.K:
        {
          var slice2 = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice2);
        }
        break;
      case SlicingMode.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = function(id) {
    publicAPI.setSlicingMode(SlicingMode.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = function() {
    var out = [0, 0, 0];
    var a = publicAPI.getInputData().getDirection();
    var mat3 = [[a[0], a[1], a[2]], [a[3], a[4], a[5]], [a[6], a[7], a[8]]];
    switch (model.slicingMode) {
      case SlicingMode.X:
        out[0] = 1;
        break;
      case SlicingMode.Y:
        out[1] = 1;
        break;
      case SlicingMode.Z:
        out[2] = 1;
        break;
      case SlicingMode.I:
        multiply3x3_vect3(mat3, [1, 0, 0], out);
        break;
      case SlicingMode.J:
        multiply3x3_vect3(mat3, [0, 1, 0], out);
        break;
      case SlicingMode.K:
        multiply3x3_vect3(mat3, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    var inVec3;
    switch (model.slicingMode) {
      case SlicingMode.X:
        inVec3 = [1, 0, 0];
        break;
      case SlicingMode.Y:
        inVec3 = [0, 1, 0];
        break;
      case SlicingMode.Z:
        inVec3 = [0, 0, 1];
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }
    var out = [0, 0, 0];
    var a = publicAPI.getInputData().getDirection();
    multiply3x3_vect3(a, inVec3, out);
    var maxAbs = 0;
    var ijkMode = -1;
    var flip = false;
    for (var axis = 0; axis < out.length; ++axis) {
      var absValue = Math.abs(out[axis]);
      if (absValue > maxAbs) {
        maxAbs = absValue;
        flip = out[axis] < 0;
        ijkMode = axis;
      }
    }
    if (maxAbs !== 1) {
      var xyzLabel = "IJKXYZ"[model.slicingMode];
      var ijkLabel = "IJKXYZ"[ijkMode];
      vtkWarningMacro("Unaccurate slicing along ".concat(xyzLabel, " axis which ") + "is not aligned with any IJK axis of the image data. " + "Using ".concat(ijkLabel, " axis  as a fallback (").concat(maxAbs, "% aligned). ") + "Necessitates slice reformat that is not yet implemented.  You can switch the slicing mode on your mapper to do IJK slicing instead.");
    }
    model.closestIJKAxis = {
      ijkMode,
      flip
    };
  }
  publicAPI.setSlicingMode = function(mode) {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getInputData()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = function() {
    if ((model.closestIJKAxis === void 0 || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getInputData()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = function() {
    var image = publicAPI.getInputData();
    if (!image) {
      return createUninitializedBounds();
    }
    if (!model.useCustomExtents) {
      return image.getBounds();
    }
    var ex = model.customDisplayExtent.slice();
    var _publicAPI$getClosest2 = publicAPI.getClosestIJKAxis(), ijkMode = _publicAPI$getClosest2.ijkMode;
    var nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function() {
    var slice2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.slice;
    var halfThickness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var image = publicAPI.getInputData();
    if (!image) {
      return createUninitializedBounds();
    }
    var extent = image.getSpatialExtent();
    var _publicAPI$getClosest3 = publicAPI.getClosestIJKAxis(), ijkMode = _publicAPI$getClosest3.ijkMode;
    var nSlice = slice2;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(slice2);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image.extentToBounds(extent);
  };
  publicAPI.getIsOpaque = function() {
    return true;
  };
  function doPicking(p1, p2) {
    var imageData = publicAPI.getInputData();
    var extent = imageData.getExtent();
    var ijk = [extent[0], extent[2], extent[4]];
    var _publicAPI$getClosest4 = publicAPI.getClosestIJKAxis(), ijkMode = _publicAPI$getClosest4.ijkMode;
    var nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(nSlice);
    }
    ijk[ijkMode] += nSlice;
    var worldOrigin = [0, 0, 0];
    imageData.indexToWorld(ijk, worldOrigin);
    ijk[ijkMode] += 1;
    var worldNormal = [0, 0, 0];
    imageData.indexToWorld(ijk, worldNormal);
    worldNormal[0] -= worldOrigin[0];
    worldNormal[1] -= worldOrigin[1];
    worldNormal[2] -= worldOrigin[2];
    normalize$4(worldNormal, worldNormal);
    var intersect = vtkPlane$1.intersectWithLine(p1, p2, worldOrigin, worldNormal);
    if (intersect.intersection) {
      var point = intersect.x;
      var absoluteIJK = [0, 0, 0];
      imageData.worldToIndex(point, absoluteIJK);
      return {
        t: intersect.t,
        absoluteIJK
      };
    }
    return null;
  }
  publicAPI.intersectWithLineForPointPicking = function(p1, p2) {
    var pickingData = doPicking(p1, p2);
    if (pickingData) {
      var imageData = publicAPI.getInputData();
      var extent = imageData.getExtent();
      var ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];
      if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
        return null;
      }
      return {
        t: pickingData.t,
        ijk
      };
    }
    return null;
  };
  publicAPI.intersectWithLineForCellPicking = function(p1, p2) {
    var pickingData = doPicking(p1, p2);
    if (pickingData) {
      var imageData = publicAPI.getInputData();
      var extent = imageData.getExtent();
      var absIJK = pickingData.absoluteIJK;
      var ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];
      if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] || ijk[2] > extent[5] - 1) {
        return null;
      }
      var pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
      return {
        t: pickingData.t,
        ijk,
        pCoords
      };
    }
    return null;
  };
}
var DEFAULT_VALUES$2 = {
  displayExtent: [0, 0, 0, 0, 0, 0],
  customDisplayExtent: [0, 0, 0, 0],
  useCustomExtents: false,
  slice: 0,
  slicingMode: SlicingMode.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false
};
function extend$3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$2, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode"]);
  macro.setGet(publicAPI, model, ["slice", "closestIJKAxis", "useCustomExtents", "renderToRectangle", "sliceAtFocalPoint"]);
  macro.setGetArray(publicAPI, model, ["customDisplayExtent"], 4);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkImageMapper(publicAPI, model);
}
var newInstance$2 = macro.newInstance(extend$3, "vtkImageMapper");
var vtkImageMapper$1 = _objectSpread(_objectSpread(_objectSpread({
  newInstance: newInstance$2,
  extend: extend$3
}, staticOffsetAPI), otherStaticMethods), Constants$3);
var InterpolationType = Constants$2.InterpolationType;
var vtkErrorMacro = macro.vtkErrorMacro;
var VTK_MAX_VRCOMP = 4;
function vtkImageProperty(publicAPI, model) {
  model.classHierarchy.push("vtkImageProperty");
  publicAPI.getMTime = function() {
    var mTime = model.mtime;
    var time;
    for (var index2 = 0; index2 < VTK_MAX_VRCOMP; index2++) {
      if (model.componentData[index2].rGBTransferFunction) {
        time = model.componentData[index2].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index2].piecewiseFunction) {
        time = model.componentData[index2].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };
  publicAPI.setRGBTransferFunction = function(index2, func) {
    var idx = index2;
    var transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getRGBTransferFunction = function() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };
  publicAPI.setPiecewiseFunction = function(index2, func) {
    var idx = index2;
    var transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getPiecewiseFunction = function() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };
  publicAPI.setScalarOpacity = function(index2, func) {
    var idx = index2;
    var transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };
  publicAPI.getScalarOpacity = function() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function(index2, value) {
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro("Invalid index");
      return false;
    }
    var val = Math.min(1, Math.max(0, value));
    if (model.componentData[index2].componentWeight !== val) {
      model.componentData[index2].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function(index2) {
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro("Invalid index");
      return 0;
    }
    return model.componentData[index2].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = function() {
    return publicAPI.setInterpolationType(InterpolationType.NEAREST);
  };
  publicAPI.setInterpolationTypeToLinear = function() {
    return publicAPI.setInterpolationType(InterpolationType.LINEAR);
  };
  publicAPI.getInterpolationTypeAsString = function() {
    return macro.enumToString(InterpolationType, model.interpolationType);
  };
}
var DEFAULT_VALUES$1 = {
  independentComponents: false,
  interpolationType: InterpolationType.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1,
  diffuse: 0,
  opacity: 1,
  useLookupTableScalarRange: false
};
function extend$2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES$1, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (var i = 0; i < VTK_MAX_VRCOMP; i++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "colorWindow", "colorLevel", "ambient", "diffuse", "opacity", "useLookupTableScalarRange"]);
  vtkImageProperty(publicAPI, model);
}
var newInstance$1 = macro.newInstance(extend$2, "vtkImageProperty");
var vtkImageProperty$1 = {
  newInstance: newInstance$1,
  extend: extend$2
};
var vtkDebugMacro = macro.vtkDebugMacro;
function vtkImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkImageSlice");
  publicAPI.getActors = function() {
    return publicAPI;
  };
  publicAPI.getImages = function() {
    return publicAPI;
  };
  publicAPI.getIsOpaque = function() {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    var isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = function() {
    return false;
  };
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getProperty = function() {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = function() {
    if (model.mapper === null) {
      return model.bounds;
    }
    var bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    var zip = function zip2(rows) {
      return rows[0].map(function(_, c) {
        return rows.map(function(row) {
          return row[c];
        });
      });
    };
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce(function(a, b) {
      return a && b[0] === b[1];
    }, true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro("Recomputing bounds...");
      model.mapperBounds = bds.map(function(x) {
        return x;
      });
      var bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      var tmp4 = new Float64Array(16);
      transpose(tmp4, model.matrix);
      bbox.forEach(function(pt) {
        return transformMat4$1(pt, pt, tmp4);
      });
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map(function(d, i) {
        return i % 2 === 0 ? bbox.reduce(function(a, b) {
          return a > b[i / 2] ? b[i / 2] : a;
        }, d) : bbox.reduce(function(a, b) {
          return a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a;
        }, d);
      });
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBoundsForSlice = function(slice2) {
    var thickness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var bds = model.mapper.getBoundsForSlice(slice2, thickness);
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      return bds;
    }
    var bbox = [];
    vtkBoundingBox.getCorners(bds, bbox);
    publicAPI.computeMatrix();
    var tmp4 = new Float64Array(16);
    transpose(tmp4, model.matrix);
    bbox.forEach(function(pt) {
      return transformMat4$1(pt, pt, tmp4);
    });
    var newBounds = [Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE];
    newBounds = newBounds.map(function(d, i) {
      return i % 2 === 0 ? bbox.reduce(function(a, b) {
        return a > b[i / 2] ? b[i / 2] : a;
      }, d) : bbox.reduce(function(a, b) {
        return a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a;
      }, d);
    });
    return newBounds;
  };
  publicAPI.getMinXBound = function() {
    publicAPI.getBounds();
    return model.bounds[0];
  };
  publicAPI.getMaxXBound = function() {
    publicAPI.getBounds();
    return model.bounds[1];
  };
  publicAPI.getMinYBound = function() {
    publicAPI.getBounds();
    return model.bounds[2];
  };
  publicAPI.getMaxYBound = function() {
    publicAPI.getBounds();
    return model.bounds[3];
  };
  publicAPI.getMinZBound = function() {
    publicAPI.getBounds();
    return model.bounds[4];
  };
  publicAPI.getMaxZBound = function() {
    publicAPI.getBounds();
    return model.bounds[5];
  };
  publicAPI.getMTime = function() {
    var mt = model.mtime;
    if (model.property !== null) {
      var time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = function() {
    var mt = model.mtime;
    if (model.mapper !== null) {
      var time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    if (model.property !== null) {
      var _time = model.property.getMTime();
      mt = _time > mt ? _time : mt;
      if (model.property.getRGBTransferFunction() !== null) {
        _time = model.property.getRGBTransferFunction().getMTime();
        mt = _time > mt ? _time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = function() {
    return model.mapper ? model.mapper.getSupportsSelection() : false;
  };
}
var DEFAULT_VALUES = {
  mapper: null,
  property: null,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend$1(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkImageSlice(publicAPI, model);
}
var newInstance = macro.newInstance(extend$1, "vtkImageSlice");
var vtkImageSlice$1 = {
  newInstance,
  extend: extend$1
};
function getTransform(enabledElement) {
  return calculateTransform(enabledElement);
}
function canvasToPixel(enabledElement, pt) {
  const transform = getTransform(enabledElement);
  transform.invert();
  return transform.transformPoint(pt);
}
function pixelToCanvas(enabledElement, pt) {
  const transform = getTransform(enabledElement);
  return transform.transformPoint(pt);
}
function fitToWindow(enabledElement) {
  const { image } = enabledElement;
  enabledElement.viewport.scale = getImageFitScale(enabledElement.canvas, image, enabledElement.viewport.rotation).scaleFactor;
  enabledElement.viewport.translation.x = 0;
  enabledElement.viewport.translation.y = 0;
}
function setCanvasSize(enabledElement) {
  const { canvas } = enabledElement;
  const { clientWidth, clientHeight } = canvas;
  if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
    canvas.width = clientWidth;
    canvas.height = clientHeight;
  }
}
function wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  const scale2 = enabledElement.viewport.scale;
  const imageSize = getImageSize(enabledElement.image, enabledElement.viewport.rotation);
  const imageWidth = Math.round(imageSize.width * scale2);
  const imageHeight = Math.round(imageSize.height * scale2);
  const x = enabledElement.viewport.translation.x;
  const y = enabledElement.viewport.translation.y;
  return imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight || imageWidth <= oldCanvasWidth && imageHeight === oldCanvasHeight && x === 0 && y === 0;
}
function relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  const scale2 = enabledElement.viewport.scale;
  const canvasWidth = enabledElement.canvas.width;
  const canvasHeight = enabledElement.canvas.height;
  const relWidthChange = canvasWidth / oldCanvasWidth;
  const relHeightChange = canvasHeight / oldCanvasHeight;
  const relChange = Math.sqrt(relWidthChange * relHeightChange);
  enabledElement.viewport.scale = relChange * scale2;
}
function resize(enabledElement, forceFitToWindow = false) {
  const oldCanvasWidth = enabledElement.canvas.width;
  const oldCanvasHeight = enabledElement.canvas.height;
  setCanvasSize(enabledElement);
  if (enabledElement.image === void 0) {
    return;
  }
  if (forceFitToWindow || wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)) {
    fitToWindow(enabledElement);
  } else {
    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);
  }
}
function resetCamera(enabledElement, resetPan = true, resetZoom = true) {
  const { canvas, image, viewport } = enabledElement;
  const scale2 = getImageFitScale(canvas, image, 0).scaleFactor;
  viewport.vflip = false;
  viewport.hflip = false;
  if (resetPan) {
    viewport.translation.x = 0;
    viewport.translation.y = 0;
  }
  if (resetZoom) {
    viewport.displayedArea.tlhc.x = 1;
    viewport.displayedArea.tlhc.y = 1;
    viewport.displayedArea.brhc.x = image.columns;
    viewport.displayedArea.brhc.y = image.rows;
    viewport.scale = scale2;
  }
}
function correctShift(shift, viewportOrientation) {
  const { hflip, vflip, rotation } = viewportOrientation;
  shift.x *= hflip ? -1 : 1;
  shift.y *= vflip ? -1 : 1;
  if (rotation !== 0) {
    const angle2 = rotation * Math.PI / 180;
    const cosA = Math.cos(angle2);
    const sinA = Math.sin(angle2);
    const newX = shift.x * cosA - shift.y * sinA;
    const newY = shift.x * sinA + shift.y * cosA;
    shift.x = newX;
    shift.y = newY;
  }
  return shift;
}
const isRgbaSourceRgbDest = (src2, dest) => src2.length * 3 === dest.byteLength * 4;
const EPSILON$3 = 1;
class StackViewport extends Viewport$1 {
  constructor(props) {
    super(props);
    this.invert = false;
    this.stackInvalidated = false;
    this.voiApplied = false;
    this.rotationCache = 0;
    this._publishCalibratedEvent = false;
    this.resize = () => {
      if (this.useCPURendering) {
        this._resizeCPU();
      }
    };
    this._resizeCPU = () => {
      if (this._cpuFallbackEnabledElement.viewport) {
        resize(this._cpuFallbackEnabledElement);
      }
    };
    this.getFrameOfReferenceUID = () => {
      const imageId = this.getCurrentImageId();
      if (!imageId) {
        return;
      }
      const imagePlaneModule = getMetaData("imagePlaneModule", imageId);
      if (!imagePlaneModule) {
        return;
      }
      return imagePlaneModule.frameOfReferenceUID;
    };
    this.createActorMapper = (imageData) => {
      const mapper = vtkImageMapper$1.newInstance();
      mapper.setInputData(imageData);
      const actor = vtkImageSlice$1.newInstance();
      actor.setMapper(mapper);
      if (imageData.getPointData().getNumberOfComponents() > 1) {
        actor.getProperty().setIndependentComponents(false);
      }
      return actor;
    };
    this.getProperties = () => {
      return {
        voiRange: this.voiRange,
        rotation: this.rotationCache,
        interpolationType: this.interpolationType,
        invert: this.invert
      };
    };
    this.canvasToWorld = (canvasPos) => {
      if (this.useCPURendering) {
        return this.canvasToWorldCPU(canvasPos);
      }
      return this.canvasToWorldGPU(canvasPos);
    };
    this.worldToCanvas = (worldPos) => {
      if (this.useCPURendering) {
        return this.worldToCanvasCPU(worldPos);
      }
      return this.worldToCanvasGPU(worldPos);
    };
    this.canvasToWorldCPU = (canvasPos) => {
      if (!this._cpuFallbackEnabledElement.image) {
        return;
      }
      const [px, py] = canvasToPixel(this._cpuFallbackEnabledElement, canvasPos);
      const { origin, spacing, direction } = this.getImageData();
      const worldPos = fromValues$3(0, 0, 0);
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
      scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
      return worldPos;
    };
    this.worldToCanvasCPU = (worldPos) => {
      const { spacing, direction, origin } = this.getImageData();
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      const diff = subtract$3(create$3(), worldPos, origin);
      const worldPoint = [
        dot$1(diff, iVector) / spacing[0],
        dot$1(diff, jVector) / spacing[1]
      ];
      const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, worldPoint);
      return canvasPoint;
    };
    this.canvasToWorldGPU = (canvasPos) => {
      const renderer2 = this.getRenderer();
      const vtkCamera2 = this.getVtkActiveCamera();
      const crange = vtkCamera2.getClippingRange();
      const distance2 = vtkCamera2.getDistance();
      vtkCamera2.setClippingRange(distance2, distance2 + 0.1);
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size2 = openGLRenderWindow.getSize();
      const devicePixelRatio = window.devicePixelRatio || 1;
      const canvasPosWithDPR = [
        canvasPos[0] * devicePixelRatio,
        canvasPos[1] * devicePixelRatio
      ];
      const displayCoord = [
        canvasPosWithDPR[0] + this.sx,
        canvasPosWithDPR[1] + this.sy
      ];
      displayCoord[1] = size2[1] - displayCoord[1];
      const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer2);
      vtkCamera2.setClippingRange(crange[0], crange[1]);
      return [worldCoord[0], worldCoord[1], worldCoord[2]];
    };
    this.worldToCanvasGPU = (worldPos) => {
      const renderer2 = this.getRenderer();
      const vtkCamera2 = this.getVtkActiveCamera();
      const crange = vtkCamera2.getClippingRange();
      const distance2 = vtkCamera2.getDistance();
      vtkCamera2.setClippingRange(distance2, distance2 + 0.1);
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size2 = openGLRenderWindow.getSize();
      const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer2);
      displayCoord[1] = size2[1] - displayCoord[1];
      const canvasCoord = [
        displayCoord[0] - this.sx,
        displayCoord[1] - this.sy
      ];
      vtkCamera2.setClippingRange(crange[0], crange[1]);
      const devicePixelRatio = window.devicePixelRatio || 1;
      const canvasCoordWithDPR = [
        canvasCoord[0] / devicePixelRatio,
        canvasCoord[1] / devicePixelRatio
      ];
      return canvasCoordWithDPR;
    };
    this.getCurrentImageIdIndex = () => {
      return this.currentImageIdIndex;
    };
    this.getTargetImageIdIndex = () => {
      return this.targetImageIdIndex;
    };
    this.getImageIds = () => {
      return this.imageIds;
    };
    this.getCurrentImageId = () => {
      return this.imageIds[this.currentImageIdIndex];
    };
    this.hasImageId = (imageId) => {
      return this.imageIds.includes(imageId);
    };
    this.hasImageURI = (imageURI) => {
      const imageIds = this.imageIds;
      for (let i = 0; i < imageIds.length; i++) {
        if (imageIdToURI(imageIds[i]) === imageURI)
          return true;
      }
      return false;
    };
    this.customRenderViewportToCanvas = () => {
      if (!this.useCPURendering) {
        throw new Error("Custom cpu rendering pipeline should only be hit in CPU rendering mode");
      }
      if (this._cpuFallbackEnabledElement.image) {
        drawImageSync(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated);
        this.cpuRenderingInvalidated = false;
      } else {
        this.fillWithBackgroundColor();
      }
      return {
        canvas: this.canvas,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
    };
    this.scaling = {};
    this.modality = null;
    this.useCPURendering = getShouldUseCPURendering();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement = {
        canvas: this.canvas,
        renderingTools: {},
        transform: new Transform$1(),
        viewport: {}
      };
    } else {
      const renderer2 = this.getRenderer();
      const camera = vtkCamera$1.newInstance();
      renderer2.setActiveCamera(camera);
      const viewPlaneNormal = [0, 0, -1];
      const viewUp = [0, -1, 0];
      camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
      camera.setViewUp(...viewUp);
      camera.setParallelProjection(true);
      camera.setThicknessFromFocalPoint(0.1);
      camera.setFreezeFocalPoint(true);
    }
    this.imageIds = [];
    this.currentImageIdIndex = 0;
    this.targetImageIdIndex = 0;
    this.cameraFocalPointOnRender = [0, 0, 0];
    this.resetCamera();
    this.initializeElementDisabledHandler();
  }
  static get useCustomRenderingPipeline() {
    return getShouldUseCPURendering();
  }
  initializeElementDisabledHandler() {
    eventTarget$1.addEventListener(Events$2.ELEMENT_DISABLED, function elementDisabledHandler() {
      clearTimeout(this.debouncedTimeout);
      eventTarget$1.removeEventListener(Events$2.ELEMENT_DISABLED, elementDisabledHandler);
    });
  }
  getImageData() {
    if (this.useCPURendering) {
      return this.getImageDataCPU();
    } else {
      return this.getImageDataGPU();
    }
  }
  getImageDataGPU() {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    const { actor } = defaultActor;
    if (!isImageActor(actor)) {
      return;
    }
    const vtkImageData2 = actor.getMapper().getInputData();
    return {
      dimensions: vtkImageData2.getDimensions(),
      spacing: vtkImageData2.getSpacing(),
      origin: vtkImageData2.getOrigin(),
      direction: vtkImageData2.getDirection(),
      scalarData: vtkImageData2.getPointData().getScalars().getData(),
      imageData: actor.getMapper().getInputData(),
      metadata: { Modality: this.modality },
      scaling: this.scaling,
      hasPixelSpacing: this.hasPixelSpacing,
      preScale: {
        ...this.csImage.preScale
      }
    };
  }
  getImageDataCPU() {
    const { metadata } = this._cpuFallbackEnabledElement;
    const spacing = metadata.spacing;
    return {
      dimensions: metadata.dimensions,
      spacing,
      origin: metadata.origin,
      direction: metadata.direction,
      metadata: { Modality: this.modality },
      scaling: this.scaling,
      imageData: {
        getDirection: () => metadata.direction,
        getDimensions: () => metadata.dimensions,
        getScalarData: () => this.cpuImagePixelData,
        getSpacing: () => spacing,
        worldToIndex: (point) => {
          const canvasPoint = this.worldToCanvasCPU(point);
          const pixelCoord = canvasToPixel(this._cpuFallbackEnabledElement, canvasPoint);
          return [pixelCoord[0], pixelCoord[1], 0];
        },
        indexToWorld: (point) => {
          const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, [
            point[0],
            point[1]
          ]);
          return this.canvasToWorldCPU(canvasPoint);
        }
      },
      scalarData: this.cpuImagePixelData,
      hasPixelSpacing: this.hasPixelSpacing,
      preScale: {
        ...this.csImage.preScale
      }
    };
  }
  buildMetadata(imageId) {
    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel } = getMetaData("imagePixelModule", imageId);
    const voiLutModule = getMetaData("voiLutModule", imageId);
    let windowWidth, windowCenter;
    if (voiLutModule) {
      ({ windowWidth, windowCenter } = voiLutModule);
      if (Array.isArray(windowWidth)) {
        windowWidth = windowWidth[0];
      }
      if (Array.isArray(windowCenter)) {
        windowCenter = windowCenter[0];
      }
    }
    const { modality } = getMetaData("generalSeriesModule", imageId);
    const imageIdScalingFactor = getMetaData("scalingModule", imageId);
    if (modality === "PT" && imageIdScalingFactor) {
      this._addScalingToViewport(imageIdScalingFactor);
    }
    this.modality = modality;
    let imagePlaneModule = this._getImagePlaneModule(imageId);
    if (!this.useCPURendering) {
      imagePlaneModule = this.calibrateIfNecessary(imageId, imagePlaneModule);
    }
    return {
      imagePlaneModule,
      imagePixelModule: {
        bitsAllocated,
        bitsStored,
        samplesPerPixel,
        highBit,
        photometricInterpretation,
        pixelRepresentation,
        windowWidth,
        windowCenter,
        modality
      }
    };
  }
  calibrateIfNecessary(imageId, imagePlaneModule) {
    const calibratedPixelSpacing = getMetaData("calibratedPixelSpacing", imageId);
    if (!calibratedPixelSpacing) {
      return imagePlaneModule;
    }
    const [calibratedRowSpacing, calibratedColumnSpacing] = calibratedPixelSpacing;
    if (imagePlaneModule.rowPixelSpacing === calibratedRowSpacing && imagePlaneModule.columnPixelSpacing === calibratedColumnSpacing) {
      return imagePlaneModule;
    }
    const imageDataMetadata = this.getImageData();
    if (!imageDataMetadata && imagePlaneModule.rowPixelSpacing === calibratedRowSpacing && imagePlaneModule.columnPixelSpacing === calibratedColumnSpacing) {
      return imagePlaneModule;
    }
    if (!imageDataMetadata && (imagePlaneModule.rowPixelSpacing !== calibratedRowSpacing || imagePlaneModule.columnPixelSpacing !== calibratedColumnSpacing)) {
      this._publishCalibratedEvent = true;
      this._calibrationEvent = {
        rowScale: calibratedRowSpacing / imagePlaneModule.rowPixelSpacing,
        columnScale: calibratedColumnSpacing / imagePlaneModule.columnPixelSpacing
      };
      imagePlaneModule.rowPixelSpacing = calibratedRowSpacing;
      imagePlaneModule.columnPixelSpacing = calibratedColumnSpacing;
      return imagePlaneModule;
    }
    const { imageData } = imageDataMetadata;
    const [columnPixelSpacing, rowPixelSpacing] = imageData.getSpacing();
    imagePlaneModule.rowPixelSpacing = calibratedRowSpacing;
    imagePlaneModule.columnPixelSpacing = calibratedColumnSpacing;
    if (rowPixelSpacing === calibratedRowSpacing && columnPixelSpacing === calibratedPixelSpacing) {
      return imagePlaneModule;
    }
    this._publishCalibratedEvent = true;
    this._calibrationEvent = {
      rowScale: calibratedRowSpacing / rowPixelSpacing,
      columnScale: calibratedColumnSpacing / columnPixelSpacing
    };
    return imagePlaneModule;
  }
  setProperties({ voiRange, invert: invert2, interpolationType, rotation } = {}, suppressEvents = false) {
    if (typeof voiRange !== "undefined" || !this.voiApplied) {
      this.setVOI(voiRange, suppressEvents);
    }
    if (typeof invert2 !== "undefined") {
      this.setInvertColor(invert2);
    }
    if (typeof interpolationType !== "undefined") {
      this.setInterpolationType(interpolationType);
    }
    if (typeof rotation !== "undefined") {
      if (this.rotationCache !== rotation) {
        this.setRotation(this.rotationCache, rotation);
      }
    }
  }
  resetProperties() {
    this.cpuRenderingInvalidated = true;
    this.fillWithBackgroundColor();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement.renderingTools = {};
    }
    this._resetProperties();
    this.render();
  }
  getCamera() {
    if (this.useCPURendering) {
      return this.getCameraCPU();
    } else {
      return super.getCamera();
    }
  }
  setCamera(cameraInterface, storeAsInitialCamera = false) {
    if (this.useCPURendering) {
      this.setCameraCPU(cameraInterface);
    } else {
      super.setCamera(cameraInterface, storeAsInitialCamera);
    }
  }
  _resetProperties() {
    this.voiApplied = false;
    this.setProperties({
      voiRange: this.initialVOIRange,
      rotation: 0,
      interpolationType: InterpolationType$5.LINEAR,
      invert: false
    });
  }
  _setPropertiesFromCache() {
    const suppressEvents = true;
    this.setProperties({
      voiRange: this.voiRange,
      rotation: this.rotation,
      interpolationType: this.interpolationType,
      invert: this.invert
    }, suppressEvents);
  }
  getCameraCPU() {
    const { metadata, viewport } = this._cpuFallbackEnabledElement;
    const { direction } = metadata;
    const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
    let viewUp = direction.slice(3, 6).map((x) => -x);
    if (this.rotation) {
      const rotationMatrix = fromRotation(create$4(), this.rotation * Math.PI / 180, viewPlaneNormal);
      viewUp = transformMat4$1(create$3(), viewUp, rotationMatrix);
    }
    const canvasCenter = [
      this.element.clientWidth / 2,
      this.element.clientHeight / 2
    ];
    const canvasCenterWorld = this.canvasToWorld(canvasCenter);
    const topLeftWorld = this.canvasToWorld([0, 0]);
    const bottomLeftWorld = this.canvasToWorld([0, this.element.clientHeight]);
    const parallelScale = distance$1(topLeftWorld, bottomLeftWorld) / 2;
    return {
      parallelProjection: true,
      focalPoint: canvasCenterWorld,
      position: [0, 0, 0],
      parallelScale,
      scale: viewport.scale,
      viewPlaneNormal: [
        viewPlaneNormal[0],
        viewPlaneNormal[1],
        viewPlaneNormal[2]
      ],
      viewUp: [viewUp[0], viewUp[1], viewUp[2]],
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical
    };
  }
  setCameraCPU(cameraInterface) {
    const { viewport, image } = this._cpuFallbackEnabledElement;
    const previousCamera = this.getCameraCPU();
    const { focalPoint, parallelScale, scale: scale2, flipHorizontal, flipVertical } = cameraInterface;
    const { clientHeight } = this.element;
    if (focalPoint) {
      const focalPointCanvas = this.worldToCanvasCPU(focalPoint);
      const focalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, focalPointCanvas);
      const prevFocalPointCanvas = this.worldToCanvasCPU(previousCamera.focalPoint);
      const prevFocalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, prevFocalPointCanvas);
      const deltaPixel = create();
      subtract$1(deltaPixel, fromValues(focalPointPixel[0], focalPointPixel[1]), fromValues(prevFocalPointPixel[0], prevFocalPointPixel[1]));
      const shift = correctShift({ x: deltaPixel[0], y: deltaPixel[1] }, viewport);
      viewport.translation.x -= shift.x;
      viewport.translation.y -= shift.y;
    }
    if (parallelScale) {
      const { rowPixelSpacing } = image;
      const scale3 = clientHeight * rowPixelSpacing * 0.5 / parallelScale;
      viewport.scale = scale3;
      viewport.parallelScale = parallelScale;
    }
    if (scale2) {
      const { rowPixelSpacing } = image;
      viewport.scale = scale2;
      viewport.parallelScale = clientHeight * rowPixelSpacing * 0.5 / scale2;
    }
    if (flipHorizontal !== void 0 || flipVertical !== void 0) {
      this.setFlipCPU({ flipHorizontal, flipVertical });
    }
    this._cpuFallbackEnabledElement.transform = calculateTransform(this._cpuFallbackEnabledElement);
    const eventDetail = {
      previousCamera,
      camera: this.getCamera(),
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId,
      rotation: this.rotation
    };
    triggerEvent(this.element, Events$2.CAMERA_MODIFIED, eventDetail);
  }
  setFlipCPU({ flipHorizontal, flipVertical }) {
    const { viewport } = this._cpuFallbackEnabledElement;
    if (flipHorizontal !== void 0) {
      viewport.hflip = flipHorizontal;
      this.flipHorizontal = viewport.hflip;
    }
    if (flipVertical !== void 0) {
      viewport.vflip = flipVertical;
      this.flipVertical = viewport.vflip;
    }
  }
  setVOI(voiRange, suppressEvents) {
    if (this.useCPURendering) {
      this.setVOICPU(voiRange, suppressEvents);
      return;
    }
    this.setVOIGPU(voiRange, suppressEvents);
  }
  setRotation(rotationCache, rotation) {
    const previousCamera = this.getCamera();
    if (this.useCPURendering) {
      this.setRotationCPU(rotationCache, rotation);
    } else {
      this.setRotationGPU(rotationCache, rotation);
    }
    const camera = this.getCamera();
    const eventDetail = {
      previousCamera,
      camera,
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId,
      rotation: this.rotation
    };
    triggerEvent(this.element, Events$2.CAMERA_MODIFIED, eventDetail);
  }
  setInterpolationType(interpolationType) {
    if (this.useCPURendering) {
      this.setInterpolationTypeCPU(interpolationType);
      return;
    }
    this.setInterpolationTypeGPU(interpolationType);
  }
  setInvertColor(invert2) {
    if (this.useCPURendering) {
      this.setInvertColorCPU(invert2);
      return;
    }
    this.setInvertColorGPU(invert2);
  }
  setRotationCPU(rotationCache, rotation) {
    const { viewport } = this._cpuFallbackEnabledElement;
    viewport.rotation = rotation;
    this.rotationCache = rotation;
    this.rotation = rotation;
  }
  setRotationGPU(rotationCache, rotation) {
    this.getVtkActiveCamera().roll(rotationCache);
    this.getVtkActiveCamera().roll(-rotation);
    this.rotationCache = rotation;
    this.rotation = rotation;
  }
  setInterpolationTypeGPU(interpolationType) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    const { actor } = defaultActor;
    if (!isImageActor(actor)) {
      return;
    }
    const volumeProperty = actor.getProperty();
    volumeProperty.setInterpolationType(interpolationType);
    this.interpolationType = interpolationType;
  }
  setInterpolationTypeCPU(interpolationType) {
    const { viewport } = this._cpuFallbackEnabledElement;
    if (interpolationType === InterpolationType$5.LINEAR) {
      viewport.pixelReplication = false;
    } else {
      viewport.pixelReplication = true;
    }
    this.interpolationType = interpolationType;
  }
  setInvertColorCPU(invert2) {
    const { viewport } = this._cpuFallbackEnabledElement;
    if (!viewport) {
      return;
    }
    viewport.invert = invert2;
    this.invert = invert2;
  }
  setInvertColorGPU(invert2) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    const { actor } = defaultActor;
    if (!isImageActor(actor)) {
      return;
    }
    if (actor.isA("vtkVolume")) {
      const volumeActor = actor;
      const tfunc = volumeActor.getProperty().getRGBTransferFunction(0);
      if (!this.invert && invert2 || this.invert && !invert2) {
        invertRgbTransferFunction(tfunc);
      }
      this.invert = invert2;
    } else if (actor.isA("vtkImageSlice")) {
      const imageSliceActor = actor;
      const tfunc = imageSliceActor.getProperty().getRGBTransferFunction(0);
      if (!this.invert && invert2 || this.invert && !invert2) {
        invertRgbTransferFunction(tfunc);
      }
      this.invert = invert2;
    }
  }
  setVOICPU(voiRange, suppressEvents) {
    const { viewport, image } = this._cpuFallbackEnabledElement;
    if (!viewport || !image) {
      return;
    }
    if (typeof voiRange === "undefined") {
      const { windowWidth: ww, windowCenter: wc } = image;
      const wwToUse = Array.isArray(ww) ? ww[0] : ww;
      const wcToUse = Array.isArray(wc) ? wc[0] : wc;
      viewport.voi = {
        windowWidth: wwToUse,
        windowCenter: wcToUse
      };
      const { lower, upper } = toLowHighRange(wwToUse, wcToUse);
      voiRange = { lower, upper };
    } else {
      const { lower, upper } = voiRange;
      const { windowCenter, windowWidth } = toWindowLevel(lower, upper);
      if (!viewport.voi) {
        viewport.voi = {
          windowWidth: 0,
          windowCenter: 0
        };
      }
      viewport.voi.windowWidth = windowWidth;
      viewport.voi.windowCenter = windowCenter;
    }
    this.voiApplied = true;
    this.voiRange = voiRange;
    const eventDetail = {
      viewportId: this.id,
      range: voiRange
    };
    if (!suppressEvents) {
      triggerEvent(this.element, Events$2.VOI_MODIFIED, eventDetail);
    }
  }
  setVOIGPU(voiRange, suppressEvents) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    const { actor } = defaultActor;
    if (!isImageActor(actor)) {
      return;
    }
    const imageActor = actor;
    let voiRangeToUse = voiRange;
    if (typeof voiRangeToUse === "undefined") {
      const imageData = imageActor.getMapper().getInputData();
      const range = imageData.getPointData().getScalars().getRange();
      voiRangeToUse = { lower: range[0], upper: range[1] };
    }
    const { windowWidth, windowCenter } = toWindowLevel(voiRangeToUse.lower, voiRangeToUse.upper);
    imageActor.getProperty().setColorWindow(windowWidth);
    imageActor.getProperty().setColorLevel(windowCenter);
    this.voiApplied = true;
    this.voiRange = voiRangeToUse;
    if (!suppressEvents) {
      const eventDetail = {
        viewportId: this.id,
        range: voiRangeToUse
      };
      triggerEvent(this.element, Events$2.VOI_MODIFIED, eventDetail);
    }
  }
  _addScalingToViewport(imageIdScalingFactor) {
    if (!this.scaling.PET) {
      const { suvbw, suvlbm, suvbsa } = imageIdScalingFactor;
      const petScaling = {};
      if (suvlbm) {
        petScaling.suvbwToSuvlbm = suvlbm / suvbw;
      }
      if (suvbsa) {
        petScaling.suvbwToSuvbsa = suvbsa / suvbw;
      }
      this.scaling.PET = petScaling;
    }
  }
  _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {
    let numberOfComponents = 1;
    if (photometricInterpretation === "RGB" || photometricInterpretation.indexOf("YBR") !== -1 || photometricInterpretation === "PALETTE COLOR") {
      numberOfComponents = 3;
    }
    return numberOfComponents;
  }
  _getImageDataMetadata(image) {
    const { imagePlaneModule, imagePixelModule } = this.buildMetadata(image.imageId);
    let rowCosines, columnCosines;
    rowCosines = imagePlaneModule.rowCosines;
    columnCosines = imagePlaneModule.columnCosines;
    if (rowCosines == null || columnCosines == null) {
      rowCosines = [1, 0, 0];
      columnCosines = [0, 1, 0];
    }
    const rowCosineVec = fromValues$3(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = fromValues$3(columnCosines[0], columnCosines[1], columnCosines[2]);
    const scanAxisNormal = create$3();
    cross$1(scanAxisNormal, rowCosineVec, colCosineVec);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
      origin = [0, 0, 0];
    }
    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;
    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;
    const xVoxels = image.columns;
    const yVoxels = image.rows;
    const zSpacing = EPSILON$3;
    const zVoxels = 1;
    const numComps = image.numComps || this._getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);
    return {
      bitsAllocated: imagePixelModule.bitsAllocated,
      numComps,
      origin,
      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
      dimensions: [xVoxels, yVoxels, zVoxels],
      spacing: [xSpacing, ySpacing, zSpacing],
      numVoxels: xVoxels * yVoxels * zVoxels,
      imagePlaneModule,
      imagePixelModule
    };
  }
  _getCameraOrientation(imageDataDirection) {
    const viewPlaneNormal = imageDataDirection.slice(6, 9).map((x) => -x);
    const viewUp = imageDataDirection.slice(3, 6).map((x) => -x);
    return {
      viewPlaneNormal: [
        viewPlaneNormal[0],
        viewPlaneNormal[1],
        viewPlaneNormal[2]
      ],
      viewUp: [viewUp[0], viewUp[1], viewUp[2]]
    };
  }
  _createVTKImageData({ origin, direction, dimensions, spacing, bitsAllocated, numComps, numVoxels }) {
    let pixelArray;
    switch (bitsAllocated) {
      case 8:
        pixelArray = new Uint8Array(numVoxels * numComps);
        break;
      case 16:
        pixelArray = new Float32Array(numVoxels * numComps);
        break;
      case 24:
        pixelArray = new Uint8Array(numVoxels * 3 * numComps);
        break;
      default:
        console.log("bit allocation not implemented");
    }
    const scalarArray = vtkDataArray$1.newInstance({
      name: "Pixels",
      numberOfComponents: numComps,
      values: pixelArray
    });
    this._imageData = vtkImageData$1.newInstance();
    this._imageData.setDimensions(dimensions);
    this._imageData.setSpacing(spacing);
    this._imageData.setDirection(direction);
    this._imageData.setOrigin(origin);
    this._imageData.getPointData().setScalars(scalarArray);
  }
  async setStack(imageIds, currentImageIdIndex = 0) {
    this.imageIds = imageIds;
    this.currentImageIdIndex = currentImageIdIndex;
    this.targetImageIdIndex = currentImageIdIndex;
    this.stackInvalidated = true;
    this.rotationCache = 0;
    this.flipVertical = false;
    this.flipHorizontal = false;
    this.voiApplied = false;
    this._resetProperties();
    this.fillWithBackgroundColor();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement.renderingTools = {};
      delete this._cpuFallbackEnabledElement.viewport.colormap;
    }
    const imageId = await this._setImageIdIndex(currentImageIdIndex);
    const eventDetail = {
      imageIds,
      viewportId: this.id,
      element: this.element,
      currentImageIdIndex
    };
    triggerEvent(eventTarget$1, Events$2.STACK_VIEWPORT_NEW_STACK, eventDetail);
    return imageId;
  }
  _checkVTKImageDataMatchesCornerstoneImage(image, imageData) {
    if (!imageData) {
      return false;
    }
    const [xSpacing, ySpacing] = imageData.getSpacing();
    const [xVoxels, yVoxels] = imageData.getDimensions();
    const imagePlaneModule = this._getImagePlaneModule(image.imageId);
    const direction = imageData.getDirection();
    const rowCosines = direction.slice(0, 3);
    const columnCosines = direction.slice(3, 6);
    return (xSpacing === image.rowPixelSpacing || image.rowPixelSpacing === null && xSpacing === 1) && (ySpacing === image.columnPixelSpacing || image.columnPixelSpacing === null && ySpacing === 1) && xVoxels === image.columns && yVoxels === image.rows && isEqual(imagePlaneModule.rowCosines, rowCosines) && isEqual(imagePlaneModule.columnCosines, columnCosines);
  }
  _updateVTKImageDataFromCornerstoneImage(image) {
    const imagePlaneModule = this._getImagePlaneModule(image.imageId);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
      origin = [0, 0, 0];
    }
    this._imageData.setOrigin(origin);
    const pixelData = image.getPixelData();
    const scalars = this._imageData.getPointData().getScalars();
    const scalarData = scalars.getData();
    if (image.rgba || isRgbaSourceRgbDest(pixelData, scalarData)) {
      if (!image.rgba) {
        console.warn("rgba not specified but data looks rgba ish", image);
      }
      const numPixels = pixelData.length / 4;
      let rgbIndex = 0;
      let index2 = 0;
      for (let i = 0; i < numPixels; i++) {
        scalarData[index2++] = pixelData[rgbIndex++];
        scalarData[index2++] = pixelData[rgbIndex++];
        scalarData[index2++] = pixelData[rgbIndex++];
        rgbIndex++;
      }
    } else {
      scalarData.set(pixelData);
    }
    this._imageData.modified();
  }
  async _loadAndDisplayImage(imageId, imageIdIndex) {
    if (this.useCPURendering) {
      await this._loadAndDisplayImageCPU(imageId, imageIdIndex);
    } else {
      await this._loadAndDisplayImageGPU(imageId, imageIdIndex);
    }
    return imageId;
  }
  _loadAndDisplayImageCPU(imageId, imageIdIndex) {
    return new Promise((resolve, reject) => {
      function successCallback(image, imageIdIndex2, imageId2) {
        var _a2;
        if (this.currentImageIdIndex !== imageIdIndex2) {
          return;
        }
        this.csImage = image;
        const eventDetail = {
          image,
          imageId: imageId2,
          imageIdIndex: imageIdIndex2,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId
        };
        triggerEvent(this.element, Events$2.STACK_NEW_IMAGE, eventDetail);
        const metadata = this._getImageDataMetadata(image);
        image.isPreScaled = (_a2 = image.preScale) == null ? void 0 : _a2.scaled;
        const viewport = getDefaultViewport(this.canvas, image, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
        this._cpuFallbackEnabledElement.image = image;
        this._cpuFallbackEnabledElement.metadata = {
          ...metadata
        };
        this.cpuImagePixelData = image.getPixelData();
        const viewportSettingToUse = Object.assign({}, viewport, this._cpuFallbackEnabledElement.viewport);
        this._cpuFallbackEnabledElement.viewport = this.stackInvalidated ? viewport : viewportSettingToUse;
        this.stackInvalidated = false;
        this.cpuRenderingInvalidated = true;
        this._cpuFallbackEnabledElement.transform = calculateTransform(this._cpuFallbackEnabledElement);
        this.render();
        this.currentImageIdIndex = imageIdIndex2;
        resolve(imageId2);
      }
      function errorCallback(error, imageIdIndex2, imageId2) {
        const eventDetail = {
          error,
          imageIdIndex: imageIdIndex2,
          imageId: imageId2
        };
        if (!this.suppressEvents) {
          triggerEvent(eventTarget$1, Events$2.IMAGE_LOAD_ERROR, eventDetail);
        }
        reject(error);
      }
      function sendRequest(imageId2, imageIdIndex2, options2) {
        return loadAndCacheImage(imageId2, options2).then((image) => {
          successCallback.call(this, image, imageIdIndex2, imageId2);
        }, (error) => {
          errorCallback.call(this, error, imageIdIndex2, imageId2);
        });
      }
      const type = "Float32Array";
      const priority = -5;
      const requestType = RequestType$1.Interaction;
      const additionalDetails = { imageId };
      const options = {
        targetBuffer: {
          type,
          offset: null,
          length: null
        },
        preScale: {
          enabled: true
        },
        useRGBA: false
      };
      imageLoadPoolManager$1.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
    });
  }
  _loadAndDisplayImageGPU(imageId, imageIdIndex) {
    return new Promise((resolve, reject) => {
      function successCallback(image, imageIdIndex2, imageId2) {
        if (this.currentImageIdIndex !== imageIdIndex2) {
          return;
        }
        this.csImage = image;
        const eventDetail2 = {
          image,
          imageId: imageId2,
          imageIdIndex: imageIdIndex2,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId
        };
        triggerEvent(this.element, Events$2.STACK_NEW_IMAGE, eventDetail2);
        this._updateActorToDisplayImageId(image);
        this.render();
        this.currentImageIdIndex = imageIdIndex2;
        resolve(imageId2);
      }
      function errorCallback(error, imageIdIndex2, imageId2) {
        const eventDetail2 = {
          error,
          imageIdIndex: imageIdIndex2,
          imageId: imageId2
        };
        triggerEvent(eventTarget$1, Events$2.IMAGE_LOAD_ERROR, eventDetail2);
        reject(error);
      }
      function sendRequest(imageId2, imageIdIndex2, options2) {
        return loadAndCacheImage(imageId2, options2).then((image) => {
          successCallback.call(this, image, imageIdIndex2, imageId2);
        }, (error) => {
          errorCallback.call(this, error, imageIdIndex2, imageId2);
        });
      }
      const type = "Float32Array";
      const priority = -5;
      const requestType = RequestType$1.Interaction;
      const additionalDetails = { imageId };
      const options = {
        targetBuffer: {
          type,
          offset: null,
          length: null
        },
        preScale: {
          enabled: true
        },
        useRGBA: false
      };
      const eventDetail = {
        imageId,
        imageIdIndex,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      triggerEvent(this.element, Events$2.PRE_STACK_NEW_IMAGE, eventDetail);
      imageLoadPoolManager$1.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
    });
  }
  _updateActorToDisplayImageId(image) {
    var _a2;
    const sameImageData = this._checkVTKImageDataMatchesCornerstoneImage(image, this._imageData);
    const activeCamera = this.getRenderer().getActiveCamera();
    const previousCameraProps = _cloneDeep(this.getCamera());
    if (sameImageData && !this.stackInvalidated) {
      this._updateVTKImageDataFromCornerstoneImage(image);
      const cameraProps = this.getCamera();
      const panCache = subtract$3(create$3(), this.cameraFocalPointOnRender, cameraProps.focalPoint);
      const rotationCache = this.rotationCache;
      this.resetCameraNoEvent();
      this.setRotation(rotationCache, rotationCache);
      this.setCameraNoEvent({
        flipHorizontal: previousCameraProps.flipHorizontal,
        flipVertical: previousCameraProps.flipVertical
      });
      const { focalPoint: focalPoint2 } = this.getCamera();
      this.cameraFocalPointOnRender = focalPoint2;
      activeCamera.setFreezeFocalPoint(true);
      this._restoreCameraProps(cameraProps, previousCameraProps, panCache);
      this.rotationCache = 0;
      this._setPropertiesFromCache();
      return;
    }
    const { origin, direction, dimensions, spacing, bitsAllocated, numComps, numVoxels, imagePixelModule } = this._getImageDataMetadata(image);
    this._createVTKImageData({
      origin,
      direction,
      dimensions,
      spacing,
      bitsAllocated,
      numComps,
      numVoxels
    });
    this._updateVTKImageDataFromCornerstoneImage(image);
    const actor = this.createActorMapper(this._imageData);
    const actors = [];
    actors.push({ uid: this.id, actor });
    this.setActors(actors);
    const { viewPlaneNormal, viewUp } = this._getCameraOrientation(direction);
    this.setCameraNoEvent({ viewUp, viewPlaneNormal });
    this.resetCameraNoEvent();
    this.triggerCameraEvent(this.getCamera(), previousCameraProps);
    activeCamera.setFreezeFocalPoint(true);
    const { windowCenter, windowWidth } = imagePixelModule;
    let voiRange = typeof windowCenter === "number" && typeof windowWidth === "number" ? toLowHighRange(windowWidth, windowCenter) : void 0;
    const isPreScaled = this.csImage.isPreScaled || ((_a2 = this.csImage.preScale) == null ? void 0 : _a2.scaled);
    if (imagePixelModule.modality === "PT" && isPreScaled) {
      voiRange = { lower: 0, upper: 5 };
    }
    this.initialVOIRange = voiRange;
    if (this.voiApplied && typeof voiRange === "undefined") {
      voiRange = this.voiRange;
    }
    this.setProperties({ voiRange });
    const cfun = vtkColorTransferFunction$1.newInstance();
    let lower = 0;
    let upper = 1024;
    if (voiRange && voiRange.lower !== void 0 && voiRange.upper !== void 0) {
      lower = voiRange.lower;
      upper = voiRange.upper;
    }
    cfun.addRGBPoint(lower, 0, 0, 0);
    cfun.addRGBPoint(upper, 1, 1, 1);
    actor.getProperty().setRGBTransferFunction(0, cfun);
    const { focalPoint } = this.getCamera();
    this.cameraFocalPointOnRender = focalPoint;
    this.stackInvalidated = false;
    if (this._publishCalibratedEvent) {
      this.triggerCalibrationEvent();
    }
  }
  async _setImageIdIndex(imageIdIndex) {
    if (imageIdIndex >= this.imageIds.length) {
      throw new Error(`ImageIdIndex provided ${imageIdIndex} is invalid, the stack only has ${this.imageIds.length} elements`);
    }
    this.currentImageIdIndex = imageIdIndex;
    this.hasPixelSpacing = true;
    const imageId = await this._loadAndDisplayImage(this.imageIds[imageIdIndex], imageIdIndex);
    return imageId;
  }
  resetCamera(resetPan = true, resetZoom = true) {
    if (this.useCPURendering) {
      this.resetCameraCPU(resetPan, resetZoom);
    } else {
      this.resetCameraGPU(resetPan, resetZoom);
    }
    this.rotation = 0;
    this.rotationCache = 0;
    return true;
  }
  resetCameraCPU(resetPan, resetZoom) {
    const { image } = this._cpuFallbackEnabledElement;
    if (!image) {
      return;
    }
    resetCamera(this._cpuFallbackEnabledElement, resetPan, resetZoom);
    const { scale: scale2 } = this._cpuFallbackEnabledElement.viewport;
    const { clientWidth, clientHeight } = this.element;
    const center = [clientWidth / 2, clientHeight / 2];
    const centerWorld = this.canvasToWorldCPU(center);
    this.setCameraCPU({
      focalPoint: centerWorld,
      scale: scale2
    });
  }
  resetCameraGPU(resetPan, resetZoom) {
    this.getVtkActiveCamera().roll(this.rotationCache);
    const resetToCenter = true;
    return super.resetCamera(resetPan, resetZoom, resetToCenter);
  }
  scroll(delta, debounce2 = true, loop = false) {
    const imageIds = this.imageIds;
    const currentTargetImageIdIndex = this.targetImageIdIndex;
    const numberOfFrames = imageIds.length;
    let newTargetImageIdIndex = currentTargetImageIdIndex + delta;
    newTargetImageIdIndex = Math.max(0, newTargetImageIdIndex);
    if (loop) {
      newTargetImageIdIndex = newTargetImageIdIndex % numberOfFrames;
    } else {
      newTargetImageIdIndex = Math.min(numberOfFrames - 1, newTargetImageIdIndex);
    }
    this.targetImageIdIndex = newTargetImageIdIndex;
    const targetImageId = imageIds[newTargetImageIdIndex];
    const imageAlreadyLoaded = cache$1.isImageIdCached(targetImageId);
    if (imageAlreadyLoaded || !debounce2) {
      this.setImageIdIndex(newTargetImageIdIndex);
    } else {
      clearTimeout(this.debouncedTimeout);
      this.debouncedTimeout = window.setTimeout(() => {
        this.setImageIdIndex(newTargetImageIdIndex);
      }, 40);
    }
    const eventData = {
      newImageIdIndex: newTargetImageIdIndex,
      imageId: targetImageId,
      direction: delta
    };
    if (newTargetImageIdIndex !== currentTargetImageIdIndex) {
      triggerEvent(this.element, Events$2.STACK_VIEWPORT_SCROLL, eventData);
    }
  }
  async setImageIdIndex(imageIdIndex) {
    if (this.currentImageIdIndex === imageIdIndex) {
      return this.getCurrentImageId();
    }
    const imageId = this._setImageIdIndex(imageIdIndex);
    return imageId;
  }
  calibrateSpacing(imageId) {
    const imageIdIndex = this.getImageIds().indexOf(imageId);
    this.stackInvalidated = true;
    this._loadAndDisplayImage(imageId, imageIdIndex);
  }
  _restoreCameraProps({ parallelScale: prevScale }, previousCamera, panCache) {
    const renderer2 = this.getRenderer();
    const { position, focalPoint } = this.getCamera();
    const newPosition = subtract$3(create$3(), position, panCache);
    const newFocal = subtract$3(create$3(), focalPoint, panCache);
    this.setCameraNoEvent({
      parallelScale: prevScale,
      position: newPosition,
      focalPoint: newFocal
    });
    const camera = this.getCamera();
    this.triggerCameraEvent(camera, previousCamera);
    const RESET_CAMERA_EVENT = {
      type: "ResetCameraEvent",
      renderer: renderer2
    };
    renderer2.invokeEvent(RESET_CAMERA_EVENT);
  }
  triggerCameraEvent(camera, previousCamera) {
    const eventDetail = {
      previousCamera,
      camera,
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId
    };
    if (!this.suppressEvents) {
      triggerEvent(this.element, Events$2.CAMERA_MODIFIED, eventDetail);
    }
  }
  triggerCalibrationEvent() {
    const { imageData } = this.getImageData();
    const eventDetail = {
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId,
      imageId: this.getCurrentImageId(),
      imageData,
      worldToIndex: imageData.getWorldToIndex(),
      ...this._calibrationEvent
    };
    if (!this.suppressEvents) {
      triggerEvent(this.element, Events$2.IMAGE_SPACING_CALIBRATED, eventDetail);
    }
    this._publishCalibratedEvent = false;
  }
  getRenderer() {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("getRenderer");
    }
    return super.getRenderer();
  }
  getDefaultActor() {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("getDefaultActor");
    }
    return super.getDefaultActor();
  }
  getActors() {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("getActors");
    }
    return super.getActors();
  }
  getActor(actorUID) {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("getActor");
    }
    return super.getActor(actorUID);
  }
  setActors(actors) {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("setActors");
    }
    return super.setActors(actors);
  }
  addActors(actors) {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("addActors");
    }
    return super.addActors(actors);
  }
  addActor(actorEntry) {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("addActor");
    }
    return super.addActor(actorEntry);
  }
  removeAllActors() {
    if (this.useCPURendering) {
      throw this.getCPUFallbackError("removeAllActors");
    }
    return super.removeAllActors();
  }
  getCPUFallbackError(method) {
    return new Error(`method ${method} cannot be used during CPU Fallback mode`);
  }
  fillWithBackgroundColor() {
    const renderingEngine = this.getRenderingEngine();
    if (renderingEngine) {
      renderingEngine.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
    }
  }
  setColormap(colormap) {
    if (this.useCPURendering) {
      this.setColormapCPU(colormap);
    } else {
      this.setColormapGPU(colormap);
    }
  }
  unsetColormap() {
    if (this.useCPURendering) {
      this.unsetColormapCPU();
    } else {
      this.unsetColormapGPU();
    }
  }
  unsetColormapCPU() {
    delete this._cpuFallbackEnabledElement.viewport.colormap;
    this._cpuFallbackEnabledElement.renderingTools = {};
    this.cpuRenderingInvalidated = true;
    this.fillWithBackgroundColor();
    this.render();
  }
  setColormapCPU(colormapData) {
    const colormap = getColormap(colormapData.name, colormapData);
    this._cpuFallbackEnabledElement.viewport.colormap = colormap;
    this._cpuFallbackEnabledElement.renderingTools = {};
    this.fillWithBackgroundColor();
    this.cpuRenderingInvalidated = true;
    this.render();
  }
  setColormapGPU(colormap) {
    throw new Error("setColorMapGPU not implemented.");
  }
  unsetColormapGPU() {
    throw new Error("unsetColormapGPU not implemented.");
  }
  _getImagePlaneModule(imageId) {
    const imagePlaneModule = getMetaData("imagePlaneModule", imageId);
    const newImagePlaneModule = {
      ...imagePlaneModule
    };
    if (!newImagePlaneModule.columnPixelSpacing) {
      newImagePlaneModule.columnPixelSpacing = 1;
      this.hasPixelSpacing = false;
    }
    if (!newImagePlaneModule.rowPixelSpacing) {
      newImagePlaneModule.rowPixelSpacing = 1;
      this.hasPixelSpacing = false;
    }
    if (!newImagePlaneModule.columnCosines) {
      newImagePlaneModule.columnCosines = [0, 1, 0];
    }
    if (!newImagePlaneModule.rowCosines) {
      newImagePlaneModule.rowCosines = [1, 0, 0];
    }
    if (!newImagePlaneModule.imagePositionPatient) {
      newImagePlaneModule.imagePositionPatient = [0, 0, 0];
    }
    if (!newImagePlaneModule.imageOrientationPatient) {
      newImagePlaneModule.imageOrientationPatient = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    return newImagePlaneModule;
  }
}
const StackViewport$1 = StackViewport;
function getEnabledElement(element) {
  if (!element) {
    return;
  }
  const { viewportUid, renderingEngineUid } = element.dataset;
  return getEnabledElementByIds(viewportUid, renderingEngineUid);
}
function getEnabledElementByIds(viewportId, renderingEngineId) {
  if (!renderingEngineId || !viewportId) {
    return;
  }
  const renderingEngine = getRenderingEngine(renderingEngineId);
  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
    return;
  }
  const viewport = renderingEngine.getViewport(viewportId);
  if (!viewport) {
    return;
  }
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  return {
    viewport,
    renderingEngine,
    viewportId,
    renderingEngineId,
    FrameOfReferenceUID
  };
}
var ToolModes;
(function(ToolModes2) {
  ToolModes2["Active"] = "Active";
  ToolModes2["Passive"] = "Passive";
  ToolModes2["Enabled"] = "Enabled";
  ToolModes2["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
const ToolModes$1 = ToolModes;
var AnnotationStyleStates;
(function(AnnotationStyleStates2) {
  AnnotationStyleStates2["Default"] = "";
  AnnotationStyleStates2["Highlighted"] = "Highlighted";
  AnnotationStyleStates2["Selected"] = "Selected";
  AnnotationStyleStates2["Locked"] = "Locked";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
const AnnotationStyleStates$1 = AnnotationStyleStates;
var Events;
(function(Events2) {
  Events2["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
  Events2["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
  Events2["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
  Events2["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
  Events2["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
  Events2["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
  Events2["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
  Events2["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
  Events2["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
  Events2["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
  Events2["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
  Events2["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
  Events2["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
  Events2["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
  Events2["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
  Events2["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
  Events2["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
  Events2["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
  Events2["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
  Events2["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
  Events2["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
  Events2["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
  Events2["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
  Events2["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
})(Events || (Events = {}));
const TOOLS_EVENTS = Events;
const globalLockedAnnotationsSet = /* @__PURE__ */ new Set();
function setAnnotationLocked(annotation, locked = true) {
  const detail = makeEventDetail$2();
  if (annotation) {
    if (locked) {
      lock(annotation, globalLockedAnnotationsSet, detail);
    } else {
      unlock(annotation, globalLockedAnnotationsSet, detail);
    }
  }
  publish$2(detail, globalLockedAnnotationsSet);
}
function isAnnotationLocked(annotation) {
  return globalLockedAnnotationsSet.has(annotation);
}
function checkAndDefineIsLockedProperty(annotation) {
  if (annotation) {
    const isLocked = !!annotation.isLocked;
    if (shouldDefineIsLockedProperty(annotation)) {
      Object.defineProperty(annotation, "isLocked", {
        configurable: false,
        enumerable: true,
        set: setIsLocked,
        get: getIsLocked
      });
    }
    setAnnotationLocked(annotation, isLocked);
  }
}
function makeEventDetail$2() {
  return Object.freeze({
    added: [],
    removed: [],
    locked: []
  });
}
function lock(annotation, lockedAnnotationsSet, detail) {
  if (!lockedAnnotationsSet.has(annotation)) {
    lockedAnnotationsSet.add(annotation);
    detail.added.push(annotation);
  }
}
function unlock(annotation, lockedAnnotationsSet, detail) {
  if (lockedAnnotationsSet.delete(annotation)) {
    detail.removed.push(annotation);
  }
}
function publish$2(detail, lockedAnnotationsSet) {
  if (detail.added.length > 0 || detail.removed.length > 0) {
    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));
    triggerEvent(eventTarget$1, TOOLS_EVENTS.ANNOTATION_LOCK_CHANGE, detail);
  }
}
function shouldDefineIsLockedProperty(annotation) {
  const descriptor = Object.getOwnPropertyDescriptor(annotation, "isLocked");
  if (descriptor) {
    return descriptor.configurable && (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked);
  }
  return Object.isExtensible(annotation);
}
function setIsLocked(locked) {
  setAnnotationLocked(this, locked);
}
function getIsLocked() {
  return isAnnotationLocked(this);
}
const selectedAnnotationUIDs = /* @__PURE__ */ new Set();
function deselectAnnotation(annotationUID) {
  const detail = makeEventDetail$1();
  if (annotationUID) {
    if (selectedAnnotationUIDs.delete(annotationUID)) {
      detail.removed.push(annotationUID);
    }
  } else {
    clearSelectionSet(selectedAnnotationUIDs, detail);
  }
  publish$1(detail, selectedAnnotationUIDs);
}
function isAnnotationSelected(annotationUID) {
  return selectedAnnotationUIDs.has(annotationUID);
}
function makeEventDetail$1() {
  return Object.freeze({
    added: [],
    removed: [],
    selection: []
  });
}
function clearSelectionSet(selectionSet, detail) {
  selectionSet.forEach((value) => {
    if (selectionSet.delete(value)) {
      detail.removed.push(value);
    }
  });
}
function publish$1(detail, selectionSet) {
  if (detail.added.length > 0 || detail.removed.length > 0) {
    selectionSet.forEach((item) => void detail.selection.push(item));
    triggerEvent(eventTarget$1, TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, detail);
  }
}
const globalHiddenAnnotationUIDsSet = /* @__PURE__ */ new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
  const detail = makeEventDetail();
  if (annotationUID) {
    if (visible) {
      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    } else {
      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    }
  }
  publish(detail);
}
function isAnnotationVisible(annotationUID) {
  const annotation = getAnnotation(annotationUID);
  if (annotation) {
    return !globalHiddenAnnotationUIDsSet.has(annotationUID);
  }
}
function checkAndDefineIsVisibleProperty(annotation) {
  if (annotation) {
    const isVisible = annotation.isVisible ?? true;
    if (shouldDefineIsVisibleProperty(annotation)) {
      Object.defineProperty(annotation, "isVisible", {
        configurable: false,
        enumerable: true,
        set: setIsVisible,
        get: getIsVisible
      });
    }
    setAnnotationVisibility(annotation.annotationUID, isVisible);
  }
}
function makeEventDetail() {
  return Object.freeze({
    lastVisible: [],
    lastHidden: [],
    hidden: []
  });
}
function show(annotationUID, annotationUIDsSet, detail) {
  if (annotationUIDsSet.delete(annotationUID)) {
    detail.lastVisible.push(annotationUID);
  }
}
function hide(annotationUID, annotationUIDsSet, detail) {
  if (!annotationUIDsSet.has(annotationUID)) {
    annotationUIDsSet.add(annotationUID);
    if (isAnnotationSelected(annotationUID)) {
      deselectAnnotation(annotationUID);
    }
    detail.lastHidden.push(annotationUID);
  }
}
function publish(detail) {
  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
    globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
    triggerEvent(eventTarget$1, TOOLS_EVENTS.ANNOTATION_VISIBILITY_CHANGE, detail);
  }
}
function shouldDefineIsVisibleProperty(annotation) {
  const descriptor = Object.getOwnPropertyDescriptor(annotation, "isVisible");
  if (descriptor) {
    return descriptor.configurable && (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible);
  }
  return Object.isExtensible(annotation);
}
function setIsVisible(hidden) {
  setAnnotationVisibility(this.annotationUID, hidden);
}
function getIsVisible() {
  return isAnnotationVisible(this.annotationUID);
}
class FrameOfReferenceSpecificAnnotationManager {
  constructor(uid2) {
    this._imageVolumeModifiedHandler = (evt) => {
      const eventDetail = evt.detail;
      const { FrameOfReferenceUID } = eventDetail;
      const annotations = this.annotations;
      const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
      if (!frameOfReferenceSpecificAnnotations) {
        return;
      }
      Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
        toolSpecificAnnotations.forEach((annotation) => {
          const invalidated = annotation.invalidated;
          if (invalidated !== void 0) {
            annotation.invalidated = true;
          }
        });
      });
    };
    this.getFramesOfReference = () => {
      return Object.keys(this.annotations);
    };
    this.getFrameOfReferenceAnnotations = (FrameOfReferenceUID) => {
      return this.annotations[FrameOfReferenceUID];
    };
    this.get = (FrameOfReferenceUID, toolName) => {
      const frameOfReferenceSpecificAnnotations = this.annotations[FrameOfReferenceUID];
      if (!frameOfReferenceSpecificAnnotations) {
        return;
      }
      return frameOfReferenceSpecificAnnotations[toolName];
    };
    this.getAnnotation = (annotationUID, filter = {}) => {
      const toolSpecificAnnotationsAndIndex = this._getToolSpecificAnnotationsAndIndex(annotationUID, filter);
      if (!toolSpecificAnnotationsAndIndex) {
        return;
      }
      const { toolSpecificAnnotations, index: index2 } = toolSpecificAnnotationsAndIndex;
      return toolSpecificAnnotations[index2];
    };
    this.getNumberOfAnnotationsInFrameOfReference = (toolName, frameOfReferenceUID) => {
      const annotations = this.getFrameOfReferenceAnnotations(frameOfReferenceUID);
      if (!annotations) {
        return 0;
      }
      const toolSpecificAnnotations = annotations[toolName];
      if (!toolSpecificAnnotations) {
        return 0;
      }
      return toolSpecificAnnotations.length;
    };
    this.getNumberOfAnnotations = (toolName, frameOfReferenceUID) => {
      if (frameOfReferenceUID) {
        return this.getNumberOfAnnotationsInFrameOfReference(toolName, frameOfReferenceUID);
      }
      const framesOfReference = this.getFramesOfReference();
      return framesOfReference.reduce((acc, frameOfReferenceUID2) => {
        const numberOfAnnotations = this.getNumberOfAnnotationsInFrameOfReference(toolName, frameOfReferenceUID2);
        return acc + numberOfAnnotations;
      }, 0);
    };
    this.addAnnotation = (annotation) => {
      const { metadata } = annotation;
      const { FrameOfReferenceUID, toolName } = metadata;
      const annotations = this.annotations;
      let frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
      if (!frameOfReferenceSpecificAnnotations) {
        annotations[FrameOfReferenceUID] = {};
        frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
      }
      let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
      if (!toolSpecificAnnotations) {
        frameOfReferenceSpecificAnnotations[toolName] = [];
        toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
      }
      toolSpecificAnnotations.push(annotation);
      checkAndDefineIsLockedProperty(annotation);
      checkAndDefineIsVisibleProperty(annotation);
    };
    this.removeAnnotation = (annotationUID, filter = {}) => {
      const toolSpecificAnnotationsAndIndex = this._getToolSpecificAnnotationsAndIndex(annotationUID, filter);
      if (!toolSpecificAnnotationsAndIndex) {
        return;
      }
      const { toolSpecificAnnotations, index: index2 } = toolSpecificAnnotationsAndIndex;
      const { metadata } = toolSpecificAnnotations[0];
      toolSpecificAnnotations.splice(index2, 1);
      if (!toolSpecificAnnotations.length) {
        const { toolName } = metadata;
        delete this.annotations[metadata.FrameOfReferenceUID][toolName];
      }
    };
    this.saveAnnotations = (FrameOfReferenceUID, toolName) => {
      const annotations = this.annotations;
      if (FrameOfReferenceUID && toolName) {
        const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
        if (!frameOfReferenceSpecificAnnotations) {
          return;
        }
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
        return _cloneDeep(toolSpecificAnnotations);
      } else if (FrameOfReferenceUID) {
        const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
        return _cloneDeep(frameOfReferenceSpecificAnnotations);
      }
      return _cloneDeep(annotations);
    };
    this.restoreAnnotations = (state2, FrameOfReferenceUID, toolName) => {
      const annotations = this.annotations;
      if (FrameOfReferenceUID && toolName) {
        let frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
        if (!frameOfReferenceSpecificAnnotations) {
          annotations[FrameOfReferenceUID] = {};
          frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
        }
        frameOfReferenceSpecificAnnotations[toolName] = state2;
      } else if (FrameOfReferenceUID) {
        annotations[FrameOfReferenceUID] = state2;
      } else {
        this.annotations = _cloneDeep(state2);
      }
    };
    this.removeAllAnnotations = () => {
      this.annotations = {};
    };
    if (!uid2) {
      uid2 = uuidv4();
    }
    this.annotations = {};
    this.uid = uid2;
    eventTarget$1.addEventListener(Events$2.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
  }
  _getToolSpecificAnnotationsAndIndex(annotationUID, filter) {
    const { toolName, FrameOfReferenceUID } = filter;
    const annotations = this.annotations;
    let frameOfReferenceUIDKeys;
    if (FrameOfReferenceUID) {
      frameOfReferenceUIDKeys = [FrameOfReferenceUID];
    } else {
      frameOfReferenceUIDKeys = Object.keys(annotations);
    }
    const numFrameOfReferenceUIDKeys = frameOfReferenceUIDKeys.length;
    for (let i = 0; i < numFrameOfReferenceUIDKeys; i++) {
      const frameOfReferenceUID = frameOfReferenceUIDKeys[i];
      const frameOfReferenceSpecificAnnotations = annotations[frameOfReferenceUID];
      let toolNameKeys;
      if (toolName) {
        toolNameKeys = [toolName];
      } else {
        toolNameKeys = Object.keys(frameOfReferenceSpecificAnnotations);
      }
      const numToolNameKeys = toolNameKeys.length;
      for (let j = 0; j < numToolNameKeys; j++) {
        const toolName2 = toolNameKeys[j];
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName2];
        const index2 = toolSpecificAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
        if (index2 !== -1) {
          return { toolSpecificAnnotations, index: index2 };
        }
      }
    }
  }
}
const defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager("DEFAULT");
function getDefaultAnnotationManager() {
  return defaultFrameOfReferenceSpecificAnnotationManager;
}
function getViewportSpecificAnnotationManager(element) {
  return defaultFrameOfReferenceSpecificAnnotationManager;
}
function getAnnotations(element, toolName) {
  const enabledElement = getEnabledElement(element);
  const annotationManager = getViewportSpecificAnnotationManager();
  const { FrameOfReferenceUID } = enabledElement;
  return annotationManager.get(FrameOfReferenceUID, toolName);
}
function addAnnotation(element, annotation) {
  const annotationManager = getViewportSpecificAnnotationManager();
  if (annotation.annotationUID === void 0) {
    annotation.annotationUID = uuidv4();
  }
  annotationManager.addAnnotation(annotation);
  const enabledElement = getEnabledElement(element);
  const { renderingEngine } = enabledElement;
  const { viewportId } = enabledElement;
  const eventType = TOOLS_EVENTS.ANNOTATION_ADDED;
  const eventDetail = {
    annotation,
    viewportId,
    renderingEngineId: renderingEngine.id
  };
  triggerEvent(eventTarget$1, eventType, eventDetail);
  return annotation.annotationUID;
}
function removeAnnotation(annotationUID, element) {
  let annotationManager = getDefaultAnnotationManager();
  if (element) {
    annotationManager = getViewportSpecificAnnotationManager();
  }
  const annotation = annotationManager.getAnnotation(annotationUID);
  if (!annotation) {
    return;
  }
  annotationManager.removeAnnotation(annotationUID);
  const eventType = TOOLS_EVENTS.ANNOTATION_REMOVED;
  const eventDetail = {
    annotation,
    annotationManagerUID: annotationManager.uid
  };
  triggerEvent(eventTarget$1, eventType, eventDetail);
}
function getAnnotation(annotationUID, element) {
  const annotationManager = getViewportSpecificAnnotationManager();
  const annotation = annotationManager.getAnnotation(annotationUID);
  return annotation;
}
let svgNodeCache = {};
const svgNodeCache$1 = svgNodeCache;
let state = {
  isInteractingWithTool: false,
  isMultiPartToolActive: false,
  tools: {},
  toolGroups: [],
  synchronizers: [],
  svgNodeCache: svgNodeCache$1,
  enabledElements: [],
  handleRadius: 6
};
const DEFINED_CURSORS = Symbol("DefinedCursors");
const STANDARD_CURSORS = /* @__PURE__ */ new Set([
  "alias",
  "all-scroll",
  "auto",
  "cell",
  "col-resize",
  "context-menu",
  "copy",
  "crosshair",
  "default",
  "e-resize",
  "ew-resize",
  "grab",
  "grabbing",
  "help",
  "move",
  "ne-resize",
  "nesw-resize",
  "no-drop",
  "none",
  "not-allowed",
  "n-resize",
  "ns-resize",
  "nw-resize",
  "nwse-resize",
  "pointer",
  "progress",
  "row-resize",
  "se-resize",
  "s-resize",
  "sw-resize",
  "text",
  "vertical-text",
  "wait",
  "w-resize",
  "zoom-in",
  "zoom-out"
]);
class MouseCursor {
  constructor(name, fallback) {
    this.name = name + "";
    this.fallback = fallback;
  }
  getName() {
    return this.name + "";
  }
  addFallbackStyleProperty(style2) {
    const { fallback } = this;
    if (fallback instanceof MouseCursor) {
      return `${style2}, ${fallback.getStyleProperty()}`;
    }
    return style2 + "";
  }
  getStyleProperty() {
    return this.addFallbackStyleProperty(this.name) + "";
  }
  static getDefinedCursor(name) {
    const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
    let mouseCursor = definedCursors.get(name);
    if (mouseCursor instanceof MouseCursor) {
      return mouseCursor;
    }
    if (STANDARD_CURSORS.has(name)) {
      mouseCursor = new MouseCursor(name);
      definedCursors.set(name, mouseCursor);
      return mouseCursor;
    }
  }
  static setDefinedCursor(name, cursor) {
    if (cursor instanceof MouseCursor) {
      const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
      definedCursors.set(name, cursor);
      return true;
    }
    return false;
  }
}
function getDefinedCursors(context, symbol) {
  let definedCursors = context[symbol];
  if (!(definedCursors instanceof Map)) {
    definedCursors = /* @__PURE__ */ new Map();
    Object.defineProperty(context, symbol, { value: definedCursors });
  }
  return definedCursors;
}
const standardCursorNames = STANDARD_CURSORS.values();
const BASE = {
  iconContent: "",
  iconSize: 16,
  viewBox: {
    x: 16,
    y: 16
  },
  mousePoint: {
    x: 8,
    y: 8
  },
  mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `
};
const SEGMENTATION_CURSOR_BOUNDARIES = {
  x: 127,
  y: 60
};
const MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
const PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
const SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
const RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
const CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
const CursorSVG = {
  Angle: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  ArrowAnnotate: extend(BASE, {
    iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
    viewBox: {
      x: 24,
      y: 24
    }
  }),
  Bidirectional: extend(BASE, {
    iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
    viewBox: {
      x: 48,
      y: 48
    }
  }),
  CobbAngle: extend(BASE, {
    iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  CircleROI: extend(BASE, {
    iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  EllipticalROI: extend(BASE, {
    iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  FreehandROI: extend(BASE, {
    iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  FreehandROISculptor: extend(BASE, {
    iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  Length: extend(BASE, {
    iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
    viewBox: {
      x: 24,
      y: 24
    }
  }),
  Probe: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  RectangleROI: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  TextMarker: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Crosshairs: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Eraser: extend(BASE, {
    iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
    viewBox: {
      x: 2048,
      y: 1792
    }
  }),
  Magnify: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
    viewBox: {
      x: 512,
      y: 512
    }
  }),
  Pan: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Rotate: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  StackScroll: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
    viewBox: {
      x: 24,
      y: 28
    }
  }),
  WindowLevelRegion: extend(BASE, {
    iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  WindowLevel: extend(BASE, {
    iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  Zoom: extend(BASE, {
    iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
    viewBox: {
      x: 640,
      y: 512
    }
  }),
  SegmentationFreeHandEraseInside: extend(BASE, {
    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandFillInside: extend(BASE, {
    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandEraseOutside: extend(BASE, {
    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandFillOutside: extend(BASE, {
    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationRectangleEraseInside: extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  RectangleScissor: extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.FILL_INSIDE": extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.FILL_OUTSIDE": extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.ERASE_OUTSIDE": extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.ERASE_INSIDE": extend(BASE, {
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  CircleScissor: extend(BASE, {
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.FILL_INSIDE": extend(BASE, {
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.ERASE_OUTSIDE": extend(BASE, {
    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.FILL_OUTSIDE": extend(BASE, {
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  })
};
function extend(base, values) {
  return Object.assign(Object.create(base), values);
}
const svgCursorNames = Object.keys(CursorSVG);
class ToolStyle {
  constructor() {
    const defaultConfig = {
      color: "rgb(255, 255, 0)",
      colorHighlighted: "rgb(0, 255, 0)",
      colorSelected: "rgb(0, 220, 0)",
      colorLocked: "rgb(255, 255, 0)",
      lineWidth: "1",
      lineDash: "",
      shadow: true,
      textBoxFontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif",
      textBoxFontSize: "14px",
      textBoxColor: "rgb(255, 255, 0)",
      textBoxColorHighlighted: "rgb(0, 255, 0)",
      textBoxColorSelected: "rgb(0, 255, 0)",
      textBoxColorLocked: "rgb(255, 255, 0)",
      textBoxBackground: "",
      textBoxLinkLineWidth: "1",
      textBoxLinkLineDash: "2,3",
      textBoxShadow: true
    };
    this._initializeConfig(defaultConfig);
  }
  getAnnotationToolStyles(annotationUID) {
    return this.config.annotations && this.config.annotations[annotationUID];
  }
  getViewportToolStyles(viewportId) {
    return this.config.viewports && this.config.viewports[viewportId];
  }
  getToolGroupToolStyles(toolGroupId) {
    return this.config.toolGroups && this.config.toolGroups[toolGroupId];
  }
  getDefaultToolStyles() {
    return this.config.default;
  }
  setAnnotationStyles(annotationUID, styles) {
    let annotationSpecificStyles = this.config.annotations;
    if (!annotationSpecificStyles) {
      this.config = {
        ...this.config,
        annotations: {}
      };
      annotationSpecificStyles = this.config.annotations;
    }
    annotationSpecificStyles[annotationUID] = styles;
  }
  setViewportToolStyles(viewportId, styles) {
    let viewportSpecificStyles = this.config.viewports;
    if (!viewportSpecificStyles) {
      this.config = {
        ...this.config,
        viewports: {}
      };
      viewportSpecificStyles = this.config.viewports;
    }
    viewportSpecificStyles[viewportId] = styles;
  }
  setToolGroupToolStyles(toolGroupId, styles) {
    let toolGroupSpecificStyles = this.config.toolGroups;
    if (!toolGroupSpecificStyles) {
      this.config = {
        ...this.config,
        toolGroups: {}
      };
      toolGroupSpecificStyles = this.config.toolGroups;
    }
    toolGroupSpecificStyles[toolGroupId] = styles;
  }
  setDefaultToolStyles(styles) {
    this.config.default = styles;
  }
  getStyleProperty(toolStyle2, specifications) {
    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
    return this._getToolStyle(toolStyle2, annotationUID, viewportId, toolGroupId, toolName);
  }
  _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
    if (annotationUID) {
      const styles = this.getAnnotationToolStyles(annotationUID);
      if (styles) {
        if (styles[property]) {
          return styles[property];
        }
      }
    }
    if (viewportId) {
      const styles = this.getViewportToolStyles(viewportId);
      if (styles) {
        if (styles[toolName] && styles[toolName][property]) {
          return styles[toolName][property];
        }
        if (styles.global && styles.global[property]) {
          return styles.global[property];
        }
      }
    }
    if (toolGroupId) {
      const styles = this.getToolGroupToolStyles(toolGroupId);
      if (styles) {
        if (styles[toolName] && styles[toolName][property]) {
          return styles[toolName][property];
        }
        if (styles.global && styles.global[property]) {
          return styles.global[property];
        }
      }
    }
    const globalStyles = this.getDefaultToolStyles();
    if (globalStyles[toolName] && globalStyles[toolName][property]) {
      return globalStyles[toolName][property];
    }
    if (globalStyles.global && globalStyles.global[property]) {
      return globalStyles.global[property];
    }
  }
  _initializeConfig(config2) {
    const toolStyles = {};
    for (const name in config2) {
      toolStyles[name] = config2[name];
    }
    this.config = {
      default: {
        global: toolStyles
      }
    };
  }
}
const toolStyle = new ToolStyle();
const toolStyle$1 = toolStyle;
function getHierarchalPropertyStyles(property, state2, mode) {
  const list = [`${property}`];
  if (state2)
    list.push(`${list[0]}${state2}`);
  if (mode)
    list.push(`${list[list.length - 1]}${mode}`);
  return list;
}
function getStyleProperty(property, styleSpecifier, state2, mode) {
  const alternatives = getHierarchalPropertyStyles(property, state2, mode);
  for (let i = alternatives.length - 1; i >= 0; --i) {
    const style2 = toolStyle$1.getStyleProperty(alternatives[i], styleSpecifier);
    if (style2 !== void 0) {
      return style2;
    }
  }
}
const ELEMENT_CURSORS_MAP = Symbol("ElementCursorsMap");
function _setElementCursor(element, cursor) {
  const cursors = _getElementCursors(element);
  cursors[1] = cursors[0];
  cursors[0] = cursor;
  element.style.cursor = (cursor instanceof MouseCursor ? cursor : MouseCursor.getDefinedCursor("auto")).getStyleProperty();
}
function resetElementCursor(element) {
  _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
  _setElementCursor(element, MouseCursor.getDefinedCursor("none"));
}
function _getElementCursors(element) {
  let map = _getElementCursors[ELEMENT_CURSORS_MAP];
  if (!(map instanceof WeakMap)) {
    map = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
      value: map
    });
  }
  let cursors = map.get(element);
  if (!cursors) {
    cursors = [null, null];
    map.set(element, cursors);
  }
  return cursors;
}
[...svgCursorNames, ...standardCursorNames];
const isMergeableObject = (val) => {
  const nonNullObject = val && typeof val === "object";
  return nonNullObject && Object.prototype.toString.call(val) !== "[object RegExp]" && Object.prototype.toString.call(val) !== "[object Date]";
};
const emptyTarget = (val) => {
  const isEmpty = Array.isArray(val) ? [] : {};
  return isEmpty;
};
const cloneIfNecessary = (value, optionsArgument) => {
  const clone2 = optionsArgument && optionsArgument.clone === true;
  return clone2 && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
};
const defaultArrayMerge = (target, source, optionsArgument) => {
  const destination = target.slice();
  source.forEach(function(e, i) {
    if (typeof destination[i] === "undefined") {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    } else if (isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument);
    } else if (target.indexOf(e) === -1) {
      destination.push(cloneIfNecessary(e, optionsArgument));
    }
  });
  return destination;
};
const mergeObject = (target, source, optionsArgument) => {
  const destination = {};
  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument);
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
};
const deepmerge = (target = {}, source = {}, optionsArgument = void 0) => {
  const array = Array.isArray(source);
  const options = optionsArgument || { arrayMerge: defaultArrayMerge };
  const arrayMerge = options.arrayMerge || defaultArrayMerge;
  if (array) {
    return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument);
  }
  return mergeObject(target, source, optionsArgument);
};
const deepMerge = deepmerge;
const VIEWPORT_ELEMENT = "viewport-element";
function getSvgDrawingHelper(element) {
  const enabledElement = getEnabledElement(element);
  const { viewportId, renderingEngineId } = enabledElement;
  const canvasHash = `${viewportId}:${renderingEngineId}`;
  const svgLayerElement = _getSvgLayer(element);
  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
    state.svgNodeCache[canvasHash][cacheKey].touched = false;
  });
  return {
    svgLayerElement,
    svgNodeCacheForCanvas: state.svgNodeCache,
    getSvgNode: getSvgNode.bind(this, canvasHash),
    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),
    setNodeTouched: setNodeTouched.bind(this, canvasHash),
    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash)
  };
}
function _getSvgLayer(element) {
  const viewportElement = `.${VIEWPORT_ELEMENT}`;
  const internalDivElement = element.querySelector(viewportElement);
  const svgLayer = internalDivElement.querySelector(".svg-layer");
  return svgLayer;
}
function getSvgNode(canvasHash, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  if (state.svgNodeCache[canvasHash][cacheKey]) {
    return state.svgNodeCache[canvasHash][cacheKey].domRef;
  }
}
function appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return null;
  }
  state.svgNodeCache[canvasHash][cacheKey] = {
    touched: true,
    domRef: svgNode
  };
  svgLayerElement.appendChild(svgNode);
}
function setNodeTouched(canvasHash, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  if (state.svgNodeCache[canvasHash][cacheKey]) {
    state.svgNodeCache[canvasHash][cacheKey].touched = true;
  }
}
function clearUntouched(svgLayerElement, canvasHash) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];
    if (!cacheEntry.touched && cacheEntry.domRef) {
      svgLayerElement.removeChild(cacheEntry.domRef);
      delete state.svgNodeCache[canvasHash][cacheKey];
    }
  });
}
function draw(element, fn) {
  const svgDrawingHelper = getSvgDrawingHelper(element);
  fn(svgDrawingHelper);
  svgDrawingHelper.clearUntouched();
}
function _getHash(annotationUID, drawingElementType, nodeUID) {
  return `${annotationUID}::${drawingElementType}::${nodeUID}`;
}
function _setAttributesIfNecessary(attributes, svgNode) {
  Object.keys(attributes).forEach((key) => {
    const currentValue = svgNode.getAttribute(key);
    const newValue = attributes[key];
    if (newValue === void 0 || newValue === "") {
      svgNode.removeAttribute(key);
    } else if (currentValue !== newValue) {
      svgNode.setAttribute(key, newValue);
    }
  });
}
function _setNewAttributesIfValid(attributes, svgNode) {
  Object.keys(attributes).forEach((key) => {
    const newValue = attributes[key];
    if (newValue !== void 0 && newValue !== "") {
      svgNode.setAttribute(key, newValue);
    }
  });
}
function drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}) {
  const { color, fill, width, lineWidth } = Object.assign({
    color: "dodgerblue",
    fill: "transparent",
    width: "2",
    lineWidth: void 0
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = _getHash(annotationUID, "circle", circleUID);
  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
  const attributes = {
    cx: `${center[0]}`,
    cy: `${center[1]}`,
    r: `${radius}`,
    stroke: color,
    fill,
    "stroke-width": strokeWidth
  };
  if (existingCircleElement) {
    _setAttributesIfNecessary(attributes, existingCircleElement);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newCircleElement = document.createElementNS(svgns, "circle");
    _setNewAttributesIfValid(attributes, newCircleElement);
    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);
  }
}
function drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {
  const { color, handleRadius, width, lineWidth, fill, type } = Object.assign({
    color: "dodgerblue",
    handleRadius: "6",
    width: "2",
    lineWidth: void 0,
    fill: "transparent",
    type: "circle"
  }, options);
  const strokeWidth = lineWidth || width;
  for (let i = 0; i < handlePoints.length; i++) {
    const handle = handlePoints[i];
    const svgns = "http://www.w3.org/2000/svg";
    const svgNodeHash = _getHash(annotationUID, "handle", `hg-${handleGroupUID}-index-${i}`);
    let attributes;
    if (type === "circle") {
      attributes = {
        cx: `${handle[0]}`,
        cy: `${handle[1]}`,
        r: handleRadius,
        stroke: color,
        fill,
        "stroke-width": strokeWidth
      };
    } else if (type === "rect") {
      const handleRadiusFloat = parseFloat(handleRadius);
      const side = handleRadiusFloat * 1.5;
      const x = handle[0] - side * 0.5;
      const y = handle[1] - side * 0.5;
      attributes = {
        x: `${x}`,
        y: `${y}`,
        width: `${side}`,
        height: `${side}`,
        stroke: color,
        fill,
        "stroke-width": strokeWidth,
        rx: `${side * 0.1}`
      };
    } else {
      throw new Error(`Unsupported handle type: ${type}`);
    }
    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingHandleElement) {
      _setAttributesIfNecessary(attributes, existingHandleElement);
      svgDrawingHelper.setNodeTouched(svgNodeHash);
    } else {
      const newHandleElement = document.createElementNS(svgns, type);
      _setNewAttributesIfValid(attributes, newHandleElement);
      svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
    }
  }
}
function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = "") {
  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
    return;
  }
  const { color, width, lineWidth, lineDash, shadow } = Object.assign({
    color: "dodgerblue",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0,
    shadow: void 0
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = _getHash(annotationUID, "line", lineUID);
  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
  const dropShadowStyle = shadow ? "filter:url(#shadow);" : "";
  const attributes = {
    x1: `${start[0]}`,
    y1: `${start[1]}`,
    x2: `${end[0]}`,
    y2: `${end[1]}`,
    stroke: color,
    style: dropShadowStyle,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingLine) {
    _setAttributesIfNecessary(attributes, existingLine);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newLine = document.createElementNS(svgns, "line");
    if (dataId !== "") {
      newLine.setAttribute("data-id", dataId);
    }
    _setNewAttributesIfValid(attributes, newLine);
    svgDrawingHelper.appendNode(newLine, svgNodeHash);
  }
}
function findClosestPoint(sourcePoints, targetPoint) {
  let minPoint = [0, 0];
  let minDistance = Number.MAX_SAFE_INTEGER;
  sourcePoints.forEach(function(sourcePoint) {
    const distance2 = _distanceBetween(targetPoint, sourcePoint);
    if (distance2 < minDistance) {
      minDistance = distance2;
      minPoint = [...sourcePoint];
    }
  });
  return minPoint;
}
function _distanceBetween(p1, p2) {
  const [x1, y1] = p1;
  const [x2, y2] = p2;
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}
function getToolsWithModesForElement(element, modesFilter) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngineId, viewportId } = enabledElement;
  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);
  if (!toolGroup) {
    return [];
  }
  const enabledTools = [];
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const toolOptions = toolGroup.toolOptions[toolName];
    if (!toolOptions) {
      continue;
    }
    if (modesFilter.includes(toolOptions.mode)) {
      const toolInstance = toolGroup.getToolInstance(toolName);
      enabledTools.push(toolInstance);
    }
  }
  return enabledTools;
}
const { Active: Active$1, Passive: Passive$1, Enabled: Enabled$1 } = ToolModes$1;
class AnnotationRenderingEngine {
  constructor() {
    this._needsRender = /* @__PURE__ */ new Set();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this._renderFlaggedViewports = () => {
      this._throwIfDestroyed();
      const elements = Array.from(this._viewportElements.values());
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (this._needsRender.has(element)) {
          this._triggerRender(element);
          this._needsRender.delete(element);
          if (this._needsRender.size === 0) {
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            return;
          }
        }
      }
    };
    this._viewportElements = /* @__PURE__ */ new Map();
  }
  addViewportElement(viewportId, element) {
    this._viewportElements.set(viewportId, element);
  }
  removeViewportElement(viewportId, element) {
    this._viewportElements.delete(viewportId);
    this._needsRender.delete(element);
    this._reset();
  }
  renderViewport(element) {
    this._setViewportsToBeRenderedNextFrame([element]);
  }
  _throwIfDestroyed() {
    if (this.hasBeenDestroyed) {
      throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
  }
  _setAllViewportsToBeRenderedNextFrame() {
    const elements = [...this._viewportElements.values()];
    elements.forEach((element) => {
      this._needsRender.add(element);
    });
    this._renderFlaggedViewports();
  }
  _setViewportsToBeRenderedNextFrame(elements) {
    const elementsEnabled = [...this._viewportElements.values()];
    elements.forEach((element) => {
      if (elementsEnabled.indexOf(element) !== -1) {
        this._needsRender.add(element);
      }
    });
    this._render();
  }
  _render() {
    if (this._needsRender.size > 0 && this._animationFrameSet === false) {
      this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
      this._animationFrameSet = true;
    }
  }
  _triggerRender(element) {
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
      console.warn("Element has been disabled");
      return;
    }
    const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);
    if (!renderingEngine) {
      console.warn("rendering Engine has been destroyed");
      return;
    }
    const enabledTools = getToolsWithModesForElement(element, [
      Active$1,
      Passive$1,
      Enabled$1
    ]);
    const { renderingEngineId, viewportId } = enabledElement;
    const eventDetail = {
      element,
      renderingEngineId,
      viewportId
    };
    draw(element, (svgDrawingHelper) => {
      let anyRendered = false;
      const handleDrawSvg = (tool) => {
        if (tool.renderAnnotation) {
          const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
          anyRendered = anyRendered || rendered;
        }
      };
      enabledTools.forEach(handleDrawSvg);
      if (anyRendered) {
        triggerEvent(element, TOOLS_EVENTS.ANNOTATION_RENDERED, { ...eventDetail });
      }
    });
  }
  _reset() {
    window.cancelAnimationFrame(this._animationFrameHandle);
    this._needsRender.clear();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this._setAllViewportsToBeRenderedNextFrame();
  }
}
const annotationRenderingEngine = new AnnotationRenderingEngine();
function triggerAnnotationRender(element) {
  annotationRenderingEngine.renderViewport(element);
}
function triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender) {
  if (!viewportIdsToRender.length) {
    return;
  }
  viewportIdsToRender.forEach((viewportId) => {
    const { element } = renderingEngine.getViewport(viewportId);
    triggerAnnotationRender(element);
  });
}
function getState(annotation) {
  if (annotation) {
    if (annotation.data && annotation.highlighted)
      return AnnotationStyleStates$1.Highlighted;
    if (isAnnotationSelected(annotation.annotationUID))
      return AnnotationStyleStates$1.Selected;
    if (isAnnotationLocked(annotation))
      return AnnotationStyleStates$1.Locked;
  }
  return AnnotationStyleStates$1.Default;
}
class BaseTool {
  constructor(toolProps, defaultToolProps) {
    const initialProps = deepMerge(defaultToolProps, toolProps);
    const { configuration = {}, supportedInteractionTypes, toolGroupId } = initialProps;
    if (!configuration.strategies) {
      configuration.strategies = {};
      configuration.defaultStrategy = void 0;
      configuration.activeStrategy = void 0;
      configuration.strategyOptions = {};
    }
    this.toolGroupId = toolGroupId;
    this.supportedInteractionTypes = supportedInteractionTypes || [];
    this.configuration = Object.assign({}, configuration);
    this.mode = ToolModes$1.Disabled;
  }
  getToolName() {
    return this.constructor.toolName;
  }
  applyActiveStrategy(enabledElement, operationData) {
    const { strategies, activeStrategy } = this.configuration;
    return strategies[activeStrategy].call(this, enabledElement, operationData);
  }
  setConfiguration(newConfiguration) {
    this.configuration = deepMerge(this.configuration, newConfiguration);
  }
  setActiveStrategy(strategyName) {
    this.setConfiguration({ activeStrategy: strategyName });
  }
  getTargetVolumeId(viewport) {
    if (this.configuration.volumeId) {
      return this.configuration.volumeId;
    }
    const actors = viewport.getActors();
    if (!actors && !actors.length) {
      return;
    }
    return actors[0].uid;
  }
  getTargetIdImage(targetId, renderingEngine) {
    if (targetId.startsWith("imageId:")) {
      const imageId = targetId.split("imageId:")[1];
      const imageURI = imageIdToURI(imageId);
      let viewports = getViewportsWithImageURI(imageURI, renderingEngine.id);
      if (!viewports || !viewports.length) {
        return;
      }
      viewports = viewports.filter((viewport) => {
        return viewport.getCurrentImageId() === imageId;
      });
      if (!viewports || !viewports.length) {
        return;
      }
      return viewports[0].getImageData();
    } else if (targetId.startsWith("volumeId:")) {
      const volumeId = targetId.split("volumeId:")[1];
      const viewports = getViewportsWithVolumeId(volumeId, renderingEngine.id);
      if (!viewports || !viewports.length) {
        return;
      }
      return viewports[0].getImageData();
    } else {
      throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
    }
  }
  getTargetId(viewport) {
    if (viewport instanceof StackViewport$1) {
      return `imageId:${viewport.getCurrentImageId()}`;
    } else if (viewport instanceof VolumeViewport$1) {
      return `volumeId:${this.getTargetVolumeId(viewport)}`;
    } else {
      throw new Error("getTargetId: viewport must be a StackViewport or VolumeViewport");
    }
  }
}
BaseTool.toolName = "BaseTool";
const BaseTool$1 = BaseTool;
const { EPSILON: EPSILON$2 } = CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON$2;
function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
  const { viewPlaneNormal } = camera;
  const annotationsWithParallelNormals = annotations.filter((td) => {
    const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
    const isParallel = Math.abs(dot$1(viewPlaneNormal, annotationViewPlaneNormal)) > PARALLEL_THRESHOLD;
    return annotationViewPlaneNormal && isParallel;
  });
  if (!annotationsWithParallelNormals.length) {
    return [];
  }
  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
  const { focalPoint } = camera;
  const annotationsWithinSlice = [];
  for (const annotation of annotationsWithParallelNormals) {
    const data = annotation.data;
    const point = data.handles.points[0];
    if (!annotation.isVisible) {
      continue;
    }
    const dir = create$3();
    sub$1(dir, focalPoint, point);
    const dot2 = dot$1(dir, viewPlaneNormal);
    if (Math.abs(dot2) < halfSpacingInNormalDirection) {
      annotationsWithinSlice.push(annotation);
    }
  }
  return annotationsWithinSlice;
}
function filterAnnotationsForDisplay(viewport, annotations) {
  if (viewport instanceof StackViewport$1) {
    const imageId = viewport.getCurrentImageId();
    const colonIndex = imageId.indexOf(":");
    const imageURI = imageId.substring(colonIndex + 1);
    return annotations.filter((annotation) => {
      if (!annotation.isVisible) {
        return false;
      }
      const imageId2 = annotation.metadata.referencedImageId;
      if (imageId2 === void 0) {
        return false;
      }
      const colonIndex2 = imageId2.indexOf(":");
      const referenceImageURI = imageId2.substring(colonIndex2 + 1);
      return referenceImageURI === imageURI;
    });
  } else if (viewport instanceof VolumeViewport$1) {
    const camera = viewport.getCamera();
    const { spacingInNormalDirection } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);
    return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
  } else {
    throw new Error(`Viewport Type ${viewport.type} not supported`);
  }
}
class AnnotationDisplayTool extends BaseTool$1 {
  constructor() {
    super(...arguments);
    this.onImageSpacingCalibrated = (evt) => {
      const { element, rowScale, columnScale, imageId, imageData: calibratedImageData, worldToIndex: noneCalibratedWorldToIndex } = evt.detail;
      const { viewport } = getEnabledElement(element);
      if (viewport instanceof VolumeViewport$1) {
        throw new Error("Cannot calibrate a volume viewport");
      }
      const calibratedIndexToWorld = calibratedImageData.getIndexToWorld();
      const imageURI = imageIdToURI(imageId);
      const stateManager = getViewportSpecificAnnotationManager();
      const framesOfReference = stateManager.getFramesOfReference();
      framesOfReference.forEach((frameOfReference) => {
        const frameOfReferenceSpecificAnnotations = stateManager.getFrameOfReferenceAnnotations(frameOfReference);
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
        if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
          return;
        }
        toolSpecificAnnotations.forEach((annotation) => {
          const referencedImageURI = imageIdToURI(annotation.metadata.referencedImageId);
          if (referencedImageURI === imageURI) {
            annotation.invalidated = true;
            annotation.data.cachedStats = {};
            annotation.data.handles.points = annotation.data.handles.points.map((point) => {
              const p2 = fromValues$2(...point, 1);
              const pCalibrated = fromValues$2(0, 0, 0, 1);
              const nonCalibratedIndexVec4 = create$2();
              transformMat4(nonCalibratedIndexVec4, p2, noneCalibratedWorldToIndex);
              const calibratedIndex = [
                columnScale * nonCalibratedIndexVec4[0],
                rowScale * nonCalibratedIndexVec4[1],
                nonCalibratedIndexVec4[2]
              ];
              transformMat4(pCalibrated, fromValues$2(calibratedIndex[0], calibratedIndex[1], calibratedIndex[2], 1), calibratedIndexToWorld);
              return pCalibrated.slice(0, 3);
            });
          }
        });
        triggerAnnotationRender(element);
      });
    };
  }
  filterInteractableAnnotationsForElement(element, annotations) {
    if (!annotations || !annotations.length) {
      return;
    }
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    return filterAnnotationsForDisplay(viewport, annotations);
  }
  getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
    const targetId = this.getTargetId(viewport);
    let referencedImageId;
    if (viewport instanceof StackViewport$1) {
      referencedImageId = targetId.split("imageId:")[1];
    } else {
      const volumeId = targetId.split("volumeId:")[1];
      const imageVolume = cache$1.getVolume(volumeId);
      referencedImageId = getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    return referencedImageId;
  }
  getStyle(property, specifications, annotation) {
    return getStyleProperty(property, specifications, getState(annotation), this.mode);
  }
}
AnnotationDisplayTool.toolName = "AnnotationDisplayTool";
const AnnotationDisplayTool$1 = AnnotationDisplayTool;
class AnnotationTool extends AnnotationDisplayTool$1 {
  constructor() {
    super(...arguments);
    this.mouseMoveCallback = (evt, filteredAnnotations) => {
      if (!filteredAnnotations) {
        return false;
      }
      const { element, currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      let annotationsNeedToBeRedrawn = false;
      for (const annotation of filteredAnnotations) {
        if (isAnnotationLocked(annotation) || !isAnnotationVisible(annotation.annotationUID)) {
          continue;
        }
        const { data } = annotation;
        const activateHandleIndex = data.handles ? data.handles.activeHandleIndex : void 0;
        const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);
        const nearToolAndNotMarkedActive = near && !annotation.highlighted;
        const notNearToolAndMarkedActive = !near && annotation.highlighted;
        if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
          annotation.highlighted = !annotation.highlighted;
          annotationsNeedToBeRedrawn = true;
        } else if (data.handles && data.handles.activeHandleIndex !== activateHandleIndex) {
          annotationsNeedToBeRedrawn = true;
        }
      }
      return annotationsNeedToBeRedrawn;
    };
  }
  getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { data } = annotation;
    const { points, textBox } = data.handles;
    const { worldBoundingBox } = textBox;
    if (worldBoundingBox) {
      const canvasBoundingBox = {
        topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),
        topRight: viewport.worldToCanvas(worldBoundingBox.topRight),
        bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),
        bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight)
      };
      if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] && canvasCoords[0] <= canvasBoundingBox.bottomRight[0] && canvasCoords[1] >= canvasBoundingBox.topLeft[1] && canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {
        data.handles.activeHandleIndex = null;
        return textBox;
      }
    }
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      const annotationCanvasCoordinate = viewport.worldToCanvas(point);
      const near = distance(canvasCoords, annotationCanvasCoordinate) < proximity;
      if (near === true) {
        data.handles.activeHandleIndex = i;
        return point;
      }
    }
    data.handles.activeHandleIndex = null;
  }
  getLinkedTextBoxStyle(specifications, annotation) {
    return {
      fontFamily: this.getStyle("textBoxFontFamily", specifications, annotation),
      fontSize: this.getStyle("textBoxFontSize", specifications, annotation),
      color: this.getStyle("textBoxColor", specifications, annotation),
      shadow: this.getStyle("textBoxShadow", specifications, annotation),
      background: this.getStyle("textBoxBackground", specifications, annotation),
      lineWidth: this.getStyle("textBoxLinkLineWidth", specifications, annotation),
      lineDash: this.getStyle("textBoxLinkLineDash", specifications, annotation)
    };
  }
  _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {
    const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);
    if (handleNearImagePoint) {
      return true;
    }
    const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, "mouse");
    if (toolNewImagePoint) {
      return true;
    }
  }
}
AnnotationTool.toolName = "AnnotationTool";
const AnnotationTool$1 = AnnotationTool;
function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {
  const numViewports = viewports.length;
  const viewportsWithFrameOfReferenceUID = [];
  for (let vp = 0; vp < numViewports; vp++) {
    const viewport = viewports[vp];
    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {
      viewportsWithFrameOfReferenceUID.push(viewport);
    }
  }
  return viewportsWithFrameOfReferenceUID;
}
const { Active, Passive, Enabled } = ToolModes$1;
function filterViewportsWithToolEnabled(viewports, toolName) {
  const numViewports = viewports.length;
  const viewportsWithToolEnabled = [];
  for (let vp = 0; vp < numViewports; vp++) {
    const viewport = viewports[vp];
    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);
    if (!toolGroup) {
      continue;
    }
    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);
    if (hasTool) {
      viewportsWithToolEnabled.push(viewport);
    }
  }
  return viewportsWithToolEnabled;
}
function _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {
  const { toolOptions } = toolGroup;
  const tool = toolOptions[toolName];
  if (!tool) {
    return false;
  }
  const toolMode = tool.mode;
  return toolMode === Active || toolMode === Passive || toolMode === Enabled;
}
function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {
  return viewports.filter((viewport) => {
    const vpCamera = viewport.getCamera();
    const isParallel = Math.abs(dot$1(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) > EPS;
    return isParallel;
  });
}
function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngine, FrameOfReferenceUID } = enabledElement;
  let viewports = renderingEngine.getViewports();
  viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);
  viewports = filterViewportsWithToolEnabled(viewports, toolName);
  const viewport = renderingEngine.getViewport(enabledElement.viewportId);
  if (requireParallelNormals) {
    viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());
  }
  const viewportIds = viewports.map((vp) => vp.id);
  return viewportIds;
}
function dist2(p1, p2) {
  return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
}
function distanceToPointSquared(lineStart, lineEnd, point) {
  const d2 = dist2(lineStart, lineEnd);
  if (d2 === 0) {
    return dist2(point, lineStart);
  }
  const t = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) + (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) / d2;
  if (t < 0) {
    return dist2(point, lineStart);
  }
  if (t > 1) {
    return dist2(point, lineEnd);
  }
  const pt = [
    lineStart[0] + t * (lineEnd[0] - lineStart[0]),
    lineStart[1] + t * (lineEnd[1] - lineStart[1])
  ];
  return dist2(point, pt);
}
function distanceToPoint(lineStart, lineEnd, point) {
  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {
    throw Error("lineStart, lineEnd, and point should have 2 elements of [x, y]");
  }
  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));
}
const { RENDERING_DEFAULTS } = CONSTANTS;
const { liangBarksyClip } = index;
function defaultReferenceLineColor() {
  return "rgb(0, 200, 0)";
}
function defaultReferenceLineControllable() {
  return true;
}
function defaultReferenceLineDraggableRotatable() {
  return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
  return true;
}
const OPERATION = {
  DRAG: 1,
  ROTATE: 2,
  SLAB: 3
};
const EPSILON$1 = 1e-3;
class CrosshairsTool extends AnnotationTool$1 {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse"],
    configuration: {
      shadow: true,
      viewportIndicators: true,
      autoPan: {
        enabled: false,
        panSize: 10
      },
      filterActorUIDsToSetSlabThickness: [],
      slabThicknessBlendMode: BlendModes$1.MAXIMUM_INTENSITY_BLEND
    }
  }) {
    var _a2, _b, _c, _d;
    super(toolProps, defaultToolProps);
    this.toolCenter = [0, 0, 0];
    this.initializeViewport = ({ renderingEngineId, viewportId }) => {
      const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
      const { FrameOfReferenceUID, viewport } = enabledElement;
      const { element } = viewport;
      const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
      let annotations = getAnnotations(element, this.getToolName());
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (annotations.length) {
        removeAnnotation(annotations[0].annotationUID, element);
      }
      const annotation = {
        highlighted: false,
        metadata: {
          cameraPosition: [...position],
          cameraFocalPoint: [...focalPoint],
          FrameOfReferenceUID,
          toolName: this.getToolName()
        },
        data: {
          handles: {
            rotationPoints: [],
            slabThicknessPoints: [],
            toolCenter: this.toolCenter
          },
          activeOperation: null,
          activeViewportIds: [],
          viewportId
        }
      };
      addAnnotation(element, annotation);
      return {
        normal: viewPlaneNormal,
        point: viewport.canvasToWorld([
          viewport.canvas.clientWidth / 2,
          viewport.canvas.clientHeight / 2
        ])
      };
    };
    this._getViewportsInfo = () => {
      const viewports = getToolGroup(this.toolGroupId).viewportsInfo;
      return viewports;
    };
    this.computeToolCenter = (viewportsInfo) => {
      if (!viewportsInfo.length || viewportsInfo.length === 1) {
        throw new Error("For crosshairs to operate, at least two viewports must be given.");
      }
      const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
      const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
      const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
      let normal3 = [0, 0, 0];
      let point3 = create$3();
      if (thirdViewport) {
        ({ normal: normal3, point: point3 } = this.initializeViewport(thirdViewport));
      } else {
        add$2(point3, point1, point2);
        scale$1(point3, point3, 0.5);
        cross$1(normal3, normal1, normal2);
      }
      const firstPlane = planeEquation(normal1, point1);
      const secondPlane = planeEquation(normal2, point2);
      const thirdPlane = planeEquation(normal3, point3);
      this.toolCenter = threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
      const { renderingEngine } = getEnabledElementByIds(viewportsInfo[0].viewportId, viewportsInfo[0].renderingEngineId);
      triggerAnnotationRenderForViewportIds(renderingEngine, viewportsInfo.map(({ viewportId }) => viewportId));
    };
    this.addNewAnnotation = (evt, interactionType) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const jumpWorld = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this._jump(enabledElement, jumpWorld);
      const annotations = getAnnotations(element, this.getToolName());
      const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
      const { data } = filteredAnnotations[0];
      const { rotationPoints } = data.handles;
      const viewportIdArray = [];
      for (let i = 0; i < rotationPoints.length - 1; ++i) {
        const otherViewport = rotationPoints[i][1];
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
        if (!viewportControllable || !viewportDraggableRotatable) {
          continue;
        }
        viewportIdArray.push(otherViewport.id);
        i++;
      }
      data.activeViewportIds = [...viewportIdArray];
      data.handles.activeOperation = OPERATION.DRAG;
      evt.preventDefault();
      hideElementCursor(element);
      this._activateModify(element);
      return filteredAnnotations[0];
    };
    this.cancel = () => {
      console.log("Not implemented yet");
    };
    this.handleSelectedCallback = (evt, annotation, handle, interactionType = "mouse") => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation, interactionType) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
    };
    this.onCameraModified = (evt) => {
      var _a3;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewportId } = enabledElement;
      const viewport = enabledElement.viewport;
      const annotations = getAnnotations(element, this.getToolName());
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!viewportAnnotation) {
        return;
      }
      const currentCamera = viewport.getCamera();
      const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
      const deltaCameraPosition = [0, 0, 0];
      vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
      const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
      const deltaCameraFocalPoint = [0, 0, 0];
      vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
      viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
      viewportAnnotation.metadata.cameraFocalPoint = [
        ...currentCamera.focalPoint
      ];
      const viewportControllable = this._getReferenceLineControllable(viewport.id);
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
      if (!isEqual(currentCamera.position, oldCameraPosition, 1e-3) && viewportControllable && viewportDraggableRotatable) {
        let isRotation = false;
        const cameraModifiedSameForPosAndFocalPoint = isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
        if (!cameraModifiedSameForPosAndFocalPoint) {
          isRotation = true;
        }
        const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 0.01;
        if (!isRotation && !cameraModifiedInPlane) {
          this.toolCenter[0] += deltaCameraPosition[0];
          this.toolCenter[1] += deltaCameraPosition[1];
          this.toolCenter[2] += deltaCameraPosition[2];
        }
      }
      if ((_a3 = this.configuration.autoPan) == null ? void 0 : _a3.enabled) {
        const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);
        const otherViewportIds = toolGroup.getViewportIds().filter((id) => id !== viewport.id);
        otherViewportIds.forEach((viewportId2) => {
          this._autoPanViewportIfNecessary(viewportId2, renderingEngine);
        });
      }
      const requireSameOrientation = false;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);
      triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
    };
    this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
      const { element, currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      let imageNeedsUpdate = false;
      for (let i = 0; i < filteredToolAnnotations.length; i++) {
        const annotation = filteredToolAnnotations[i];
        if (isAnnotationLocked(annotation)) {
          continue;
        }
        const { data, highlighted } = annotation;
        if (!data.handles) {
          continue;
        }
        const previousActiveOperation = data.handles.activeOperation;
        const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0 ? [...data.activeViewportIds] : [];
        data.activeViewportIds = [];
        data.handles.activeOperation = null;
        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
        let near = false;
        if (handleNearImagePoint) {
          near = true;
        } else {
          near = this._pointNearTool(element, annotation, canvasCoords, 6);
        }
        const nearToolAndNotMarkedActive = near && !highlighted;
        const notNearToolAndMarkedActive = !near && highlighted;
        if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
          annotation.highlighted = !highlighted;
          imageNeedsUpdate = true;
        } else if (data.handles.activeOperation !== previousActiveOperation || !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
          imageNeedsUpdate = true;
        }
      }
      return imageNeedsUpdate;
    };
    this.filterInteractableAnnotationsForElement = (element, annotations) => {
      if (!annotations || !annotations.length) {
        return [];
      }
      const enabledElement = getEnabledElement(element);
      const { viewportId } = enabledElement;
      const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
      return viewportUIDSpecificCrosshairs;
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport, renderingEngine } = enabledElement;
      const { element } = viewport;
      const annotations = getAnnotations(element, this.getToolName());
      const camera = viewport.getCamera();
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!annotations || !viewportAnnotation || !viewportAnnotation.data) {
        return renderStatus;
      }
      const annotationUID = viewportAnnotation.annotationUID;
      const { clientWidth, clientHeight } = viewport.canvas;
      const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
      const data = viewportAnnotation.data;
      const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
      const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
      const referenceLines = [];
      otherViewportAnnotations.forEach((annotation) => {
        const { data: data2 } = annotation;
        data2.handles.toolCenter = this.toolCenter;
        const otherViewport = renderingEngine.getViewport(data2.viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
        const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
        const { clientWidth: clientWidth2, clientHeight: clientHeight2 } = otherViewport.canvas;
        const otherCanvasDiagonalLength = Math.sqrt(clientWidth2 * clientWidth2 + clientHeight2 * clientHeight2);
        const otherCanvasCenter = [
          clientWidth2 * 0.5,
          clientHeight2 * 0.5
        ];
        const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
        const direction = [0, 0, 0];
        vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
        vtkMath.normalize(direction);
        vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);
        const pointWorld0 = [0, 0, 0];
        vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);
        const pointWorld1 = [0, 0, 0];
        vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);
        const canvasBox = [0, 0, clientWidth2, clientHeight2];
        const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
        const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
        const canvasUnitVectorFromCenter = create();
        subtract$1(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
        normalize$1(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
        const canvasVectorFromCenterLong = create();
        scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
        const canvasVectorFromCenterMid = create();
        scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.25);
        const canvasVectorFromCenterShort = create();
        scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.15);
        const canvasVectorFromCenterStart = create();
        scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? canvasDiagonalLength * 0.04 : 0);
        const refLinePointOne = create();
        const refLinePointTwo = create();
        const refLinePointThree = create();
        const refLinePointFour = create();
        let refLinesCenter = clone(crosshairCenterCanvas);
        if (!otherViewportDraggableRotatable || !otherViewportControllable) {
          refLinesCenter = clone(otherViewportCenterCanvas);
        }
        add$1(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
        add$1(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
        subtract$1(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
        subtract$1(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
        liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);
        liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);
        const rotHandleOne = create();
        subtract$1(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
        const rotHandleTwo = create();
        add$1(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
        let stHandlesCenterCanvas = clone(crosshairCenterCanvas);
        if (!otherViewportDraggableRotatable && otherViewportSlabThicknessControlsOn) {
          stHandlesCenterCanvas = clone(otherViewportCenterCanvas);
        }
        let stHandlesCenterWorld = [...this.toolCenter];
        if (!otherViewportDraggableRotatable && otherViewportSlabThicknessControlsOn) {
          stHandlesCenterWorld = [...otherViewportCenterWorld];
        }
        const worldUnitVectorFromCenter = [0, 0, 0];
        vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
        vtkMath.normalize(worldUnitVectorFromCenter);
        const { viewPlaneNormal } = camera;
        const { matrix } = vtkMatrixBuilder.buildFromDegree().rotate(90, viewPlaneNormal);
        const worldUnitOrthoVectorFromCenter = [0, 0, 0];
        transformMat4$1(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
        const slabThicknessValue = otherViewport.getSlabThickness();
        const worldOrthoVectorFromCenter = [
          ...worldUnitOrthoVectorFromCenter
        ];
        vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
        const worldVerticalRefPoint = [0, 0, 0];
        vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
        const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
        const canvasOrthoVectorFromCenter = create();
        subtract$1(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
        const stLinePointOne = create();
        subtract$1(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        add$1(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
        const stLinePointTwo = create();
        add$1(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        add$1(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
        liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);
        const stLinePointThree = create();
        add$1(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        subtract$1(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
        const stLinePointFour = create();
        subtract$1(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        subtract$1(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
        liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);
        const stHandleOne = create();
        const stHandleTwo = create();
        const stHandleThree = create();
        const stHandleFour = create();
        subtract$1(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        add$1(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
        add$1(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        add$1(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
        subtract$1(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        subtract$1(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
        add$1(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        subtract$1(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
        referenceLines.push([
          otherViewport,
          refLinePointOne,
          refLinePointTwo,
          refLinePointThree,
          refLinePointFour,
          stLinePointOne,
          stLinePointTwo,
          stLinePointThree,
          stLinePointFour,
          rotHandleOne,
          rotHandleTwo,
          stHandleOne,
          stHandleTwo,
          stHandleThree,
          stHandleFour
        ]);
      });
      const newRtpoints = [];
      const newStpoints = [];
      const viewportColor = this._getReferenceLineColor(viewport.id);
      const color = viewportColor !== void 0 ? viewportColor : "rgb(200, 200, 200)";
      referenceLines.forEach((line, lineIndex) => {
        const otherViewport = line[0];
        const viewportColor2 = this._getReferenceLineColor(otherViewport.id);
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
        const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
        const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
        let color2 = viewportColor2 !== void 0 ? viewportColor2 : "rgb(200, 200, 200)";
        let lineWidth = 1;
        const lineActive = data.handles.activeOperation !== null && data.handles.activeOperation === OPERATION.DRAG && selectedViewportId;
        if (lineActive) {
          lineWidth = 2.5;
        }
        let lineUID = `${lineIndex}`;
        if (viewportControllable && viewportDraggableRotatable) {
          lineUID = `${lineIndex}One`;
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
            color: color2,
            lineWidth
          });
          lineUID = `${lineIndex}Two`;
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
            color: color2,
            lineWidth
          });
        } else {
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
            color: color2,
            lineWidth
          });
        }
        if (viewportControllable) {
          color2 = viewportColor2 !== void 0 ? viewportColor2 : "rgb(200, 200, 200)";
          const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;
          const rotationHandles = [line[9], line[10]];
          const rotHandleWorldOne = [
            viewport.canvasToWorld(line[9]),
            otherViewport,
            line[1],
            line[2]
          ];
          const rotHandleWorldTwo = [
            viewport.canvasToWorld(line[10]),
            otherViewport,
            line[3],
            line[4]
          ];
          newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
          const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;
          const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
          const slabThicknessHandleWorldOne = [
            viewport.canvasToWorld(line[11]),
            otherViewport,
            line[5],
            line[6]
          ];
          const slabThicknessHandleWorldTwo = [
            viewport.canvasToWorld(line[12]),
            otherViewport,
            line[5],
            line[6]
          ];
          const slabThicknessHandleWorldThree = [
            viewport.canvasToWorld(line[13]),
            otherViewport,
            line[7],
            line[8]
          ];
          const slabThicknessHandleWorldFour = [
            viewport.canvasToWorld(line[14]),
            otherViewport,
            line[7],
            line[8]
          ];
          newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
          if (lineActive && !rotHandlesActive && !slabThicknessHandlesActive && viewportDraggableRotatable && viewportSlabThicknessControlsOn) {
            let handleUID = `${lineIndex}One`;
            drawHandles(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: 3,
              type: "circle"
            });
            handleUID = `${lineIndex}Two`;
            drawHandles(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
              color: color2,
              handleRadius: 3,
              type: "rect"
            });
          } else if (lineActive && !rotHandlesActive && !slabThicknessHandlesActive && viewportDraggableRotatable) {
            const handleUID = `${lineIndex}`;
            drawHandles(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: 3,
              type: "circle"
            });
          } else if (selectedViewportId && !rotHandlesActive && !slabThicknessHandlesActive && viewportSlabThicknessControlsOn) {
            const handleUID = `${lineIndex}`;
            drawHandles(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
              color: color2,
              handleRadius: 3,
              type: "rect"
            });
          } else if (rotHandlesActive && viewportDraggableRotatable) {
            const handleUID = `${lineIndex}`;
            drawHandles(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: 2,
              fill: color2,
              type: "circle"
            });
          } else if (slabThicknessHandlesActive && selectedViewportId && viewportSlabThicknessControlsOn) {
            drawHandles(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
              color: color2,
              handleRadius: 2,
              fill: color2,
              type: "rect"
            });
          }
          const slabThicknessValue = otherViewport.getSlabThickness();
          if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
            lineUID = `${lineIndex}STOne`;
            drawLine(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
              color: color2,
              width: 1,
              lineDash: [2, 3]
            });
            lineUID = `${lineIndex}STTwo`;
            drawLine(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
              color: color2,
              width: line,
              lineDash: [2, 3]
            });
          }
        }
      });
      renderStatus = true;
      data.handles.rotationPoints = newRtpoints;
      data.handles.slabThicknessPoints = newStpoints;
      if (this.configuration.viewportIndicators) {
        const referenceColorCoordinates = [
          clientWidth * 0.95,
          clientHeight * 0.05
        ];
        const circleRadius = canvasDiagonalLength * 0.01;
        const circleUID = "0";
        drawCircle(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
      }
      return renderStatus;
    };
    this._onNewVolume = (e) => {
      const viewportsInfo = this._getViewportsInfo();
      this.computeToolCenter(viewportsInfo);
    };
    this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
      if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
        return false;
      }
      viewportIdArrayOne.forEach((id) => {
        let itemFound = false;
        for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
          if (id === viewportIdArrayTwo[i]) {
            itemFound = true;
            break;
          }
        }
        if (itemFound === false) {
          return false;
        }
      });
      return true;
    };
    this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
      const { viewportId, renderingEngine, viewport } = enabledElement;
      const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
      if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
        return [];
      }
      const camera = viewport.getCamera();
      const { viewPlaneNormal, position } = camera;
      const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
        const { viewportId: viewportId2 } = annotation.data;
        const targetViewport = renderingEngine.getViewport(viewportId2);
        const cameraOfTarget = targetViewport.getCamera();
        return !(isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 0.01) && isEqual(cameraOfTarget.position, position, 1));
      });
      return viewportsWithDifferentCameras;
    };
    this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
      const { renderingEngine } = enabledElement;
      const { data } = referenceAnnotation;
      const viewport = renderingEngine.getViewport(data.viewportId);
      const linkedViewportAnnotations = annotations.filter((annotation) => {
        const { data: data2 } = annotation;
        const otherViewport = renderingEngine.getViewport(data2.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return otherViewportControllable === true;
      });
      if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
        return [];
      }
      const camera = viewport.getCamera();
      const viewPlaneNormal = camera.viewPlaneNormal;
      vtkMath.normalize(viewPlaneNormal);
      const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        return isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) && isEqual(camera.viewUp, otherCamera.viewUp, 0.01);
      });
      return otherViewportsAnnotationsWithSameCameraDirection;
    };
    this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
      const { renderingEngine, viewport } = enabledElement;
      const camera = viewport.getCamera();
      const viewPlaneNormal = camera.viewPlaneNormal;
      vtkMath.normalize(viewPlaneNormal);
      const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return viewport !== otherViewport && otherViewportControllable === true;
      });
      const otherViewportsAnnotationsWithUniqueCameras = [];
      for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
        const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return viewport !== otherViewport && otherViewportControllable !== true;
      });
      for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
        const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
      for (let i = 0; i < otherViewportAnnotations.length; ++i) {
        const annotation = otherViewportAnnotations[i];
        if (otherViewportsAnnotationsWithUniqueCameras.find((element) => element === annotation) === true) {
          continue;
        }
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      return otherViewportsAnnotationsWithUniqueCameras;
    };
    this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
      const actors = viewport.getActors();
      const otherViewportActors = otherViewport.getActors();
      let sameScene = true;
      actors.forEach((actor) => {
        if (actors.length !== otherViewportActors.length || otherViewportActors.find(({ uid: uid2 }) => uid2 === actor.uid) === void 0) {
          sameScene = false;
        }
      });
      return sameScene;
    };
    this._jump = (enabledElement, jumpWorld) => {
      state.isInteractingWithTool = true;
      const { viewport, renderingEngine } = enabledElement;
      const annotations = getAnnotations(viewport.element, this.getToolName());
      const delta = [0, 0, 0];
      vtkMath.subtract(jumpWorld, this.toolCenter, delta);
      const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
        return this._getReferenceLineControllable(otherViewport.id) && this._getReferenceLineDraggableRotatable(otherViewport.id) && sameScene;
      });
      if (viewportsAnnotationsToUpdate.length === 0) {
        state.isInteractingWithTool = false;
        return false;
      }
      this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
      state.isInteractingWithTool = false;
      return true;
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(TOOLS_EVENTS.MOUSE_UP, this._mouseUpCallback);
      element.addEventListener(TOOLS_EVENTS.MOUSE_DRAG, this._mouseDragCallback);
      element.addEventListener(TOOLS_EVENTS.MOUSE_CLICK, this._mouseUpCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(TOOLS_EVENTS.MOUSE_UP, this._mouseUpCallback);
      element.removeEventListener(TOOLS_EVENTS.MOUSE_DRAG, this._mouseDragCallback);
      element.removeEventListener(TOOLS_EVENTS.MOUSE_CLICK, this._mouseUpCallback);
    };
    this._mouseUpCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      this.editData.annotation.data.handles.activeOperation = null;
      this.editData.annotation.data.activeViewportIds = [];
      this._deactivateModify(element);
      resetElementCursor(element);
      this.editData = null;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      const requireSameOrientation = false;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);
      triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
    };
    this._mouseDragCallback = (evt) => {
      const eventDetail = evt.detail;
      const delta = eventDetail.deltaPoints.world;
      if (Math.abs(delta[0]) < 1e-3 && Math.abs(delta[1]) < 1e-3 && Math.abs(delta[2]) < 1e-3) {
        return;
      }
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const annotations = getAnnotations(element, this.getToolName());
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!viewportAnnotation) {
        return;
      }
      const { handles } = viewportAnnotation.data;
      const { currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      if (handles.activeOperation === OPERATION.DRAG) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
          return otherViewportControllable === true && otherViewportDraggableRotatable === true && viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id);
        });
        this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
      } else if (handles.activeOperation === OPERATION.ROTATE) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
          return otherViewportControllable === true && otherViewportDraggableRotatable === true;
        });
        const dir1 = create();
        const dir2 = create();
        const center = [
          this.toolCenter[0],
          this.toolCenter[1],
          this.toolCenter[2]
        ];
        const centerCanvas = viewport.worldToCanvas(center);
        const finalPointCanvas = eventDetail.currentPoints.canvas;
        const originalPointCanvas = create();
        sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
        sub(dir1, originalPointCanvas, centerCanvas);
        sub(dir2, finalPointCanvas, centerCanvas);
        let angle$12 = angle(dir1, dir2);
        if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
          angle$12 *= -1;
        }
        angle$12 = Math.round(angle$12 * 100) / 100;
        const rotationAxis = viewport.getCamera().viewPlaneNormal;
        const { matrix } = vtkMatrixBuilder.buildFromRadian().translate(center[0], center[1], center[2]).rotate(angle$12, rotationAxis).translate(-center[0], -center[1], -center[2]);
        const otherViewportsIds = [];
        viewportsAnnotationsToUpdate.forEach((annotation) => {
          const { data } = annotation;
          data.handles.toolCenter = center;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const camera = otherViewport.getCamera();
          const { viewUp, position, focalPoint } = camera;
          viewUp[0] += position[0];
          viewUp[1] += position[1];
          viewUp[2] += position[2];
          transformMat4$1(focalPoint, focalPoint, matrix);
          transformMat4$1(position, position, matrix);
          transformMat4$1(viewUp, viewUp, matrix);
          viewUp[0] -= position[0];
          viewUp[1] -= position[1];
          viewUp[2] -= position[2];
          otherViewport.setCamera({
            position,
            viewUp,
            focalPoint
          });
          otherViewportsIds.push(otherViewport.id);
        });
        renderingEngine.renderViewports(otherViewportsIds);
      } else if (handles.activeOperation === OPERATION.SLAB) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
          return otherViewportControllable === true && otherViewportSlabThicknessControlsOn === true && viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id);
        });
        if (referenceAnnotations.length === 0) {
          return;
        }
        const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
        const viewportsIds = [];
        viewportsIds.push(viewport.id);
        viewportsAnnotationsToUpdate.forEach((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const camera = otherViewport.getCamera();
          const normal = camera.viewPlaneNormal;
          const dotProd = vtkMath.dot(delta, normal);
          const projectedDelta = [...normal];
          vtkMath.multiplyScalar(projectedDelta, dotProd);
          if (Math.abs(projectedDelta[0]) > 1e-3 || Math.abs(projectedDelta[1]) > 1e-3 || Math.abs(projectedDelta[2]) > 1e-3) {
            const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] + projectedDelta[1] * projectedDelta[1] + projectedDelta[2] * projectedDelta[2]);
            const currentPoint = eventDetail.lastPoints.world;
            const direction = [0, 0, 0];
            const currentCenter = [
              this.toolCenter[0],
              this.toolCenter[1],
              this.toolCenter[2]
            ];
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
              const { rotationPoints } = this.editData.annotation.data.handles;
              const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
              if (otherViewportRotationPoints.length === 2) {
                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                vtkMath.add(point1, point2, currentCenter);
                vtkMath.multiplyScalar(currentCenter, 0.5);
              }
            }
            vtkMath.subtract(currentPoint, currentCenter, direction);
            const dotProdDirection = vtkMath.dot(direction, normal);
            const projectedDirection = [...normal];
            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);
            const normalizedProjectedDirection = [
              projectedDirection[0],
              projectedDirection[1],
              projectedDirection[2]
            ];
            normalize$4(normalizedProjectedDirection, normalizedProjectedDirection);
            const normalizedProjectedDelta = [
              projectedDelta[0],
              projectedDelta[1],
              projectedDelta[2]
            ];
            normalize$4(normalizedProjectedDelta, normalizedProjectedDelta);
            let slabThicknessValue = otherViewport.getSlabThickness();
            if (isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
              slabThicknessValue -= mod;
            } else {
              slabThicknessValue += mod;
            }
            slabThicknessValue = Math.abs(slabThicknessValue);
            slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
            const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
            if (near) {
              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            }
            const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);
            const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
            crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
            viewportsIds.push(otherViewport.id);
          }
        });
        renderingEngine.renderViewports(viewportsIds);
      }
    };
    this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
      const { data } = annotation;
      const { rotationPoints } = data.handles;
      for (let i = 0; i < rotationPoints.length - 1; ++i) {
        const otherViewport = rotationPoints[i][1];
        if (otherViewport.id !== lineViewport.id) {
          continue;
        }
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        if (!viewportControllable) {
          continue;
        }
        const lineSegment1 = {
          start: {
            x: rotationPoints[i][2][0],
            y: rotationPoints[i][2][1]
          },
          end: {
            x: rotationPoints[i][3][0],
            y: rotationPoints[i][3][1]
          }
        };
        const distanceToPoint1 = distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
        const lineSegment2 = {
          start: {
            x: rotationPoints[i + 1][2][0],
            y: rotationPoints[i + 1][2][1]
          },
          end: {
            x: rotationPoints[i + 1][3][0],
            y: rotationPoints[i + 1][3][1]
          }
        };
        const distanceToPoint2 = distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
        if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
          return true;
        }
        i++;
      }
      return false;
    };
    this._getReferenceLineColor = ((_a2 = toolProps.configuration) == null ? void 0 : _a2.getReferenceLineColor) || defaultReferenceLineColor;
    this._getReferenceLineControllable = ((_b = toolProps.configuration) == null ? void 0 : _b.getReferenceLineControllable) || defaultReferenceLineControllable;
    this._getReferenceLineDraggableRotatable = ((_c = toolProps.configuration) == null ? void 0 : _c.getReferenceLineDraggableRotatable) || defaultReferenceLineDraggableRotatable;
    this._getReferenceLineSlabThicknessControlsOn = ((_d = toolProps.configuration) == null ? void 0 : _d.getReferenceLineSlabThicknessControlsOn) || defaultReferenceLineSlabThicknessControlsOn;
  }
  onSetToolActive() {
    const viewportsInfo = this._getViewportsInfo();
    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
    this._subscribeToViewportNewVolumeSet(viewportsInfo);
    this.computeToolCenter(viewportsInfo);
  }
  onSetToolPassive() {
    const viewportsInfo = this._getViewportsInfo();
    this.computeToolCenter(viewportsInfo);
  }
  onSetToolEnabled() {
    const viewportsInfo = this._getViewportsInfo();
    this.computeToolCenter(viewportsInfo);
  }
  onSetToolDisabled() {
    const viewportsInfo = this._getViewportsInfo();
    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
      const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
      if (!enabledElement) {
        return;
      }
      const { viewport } = enabledElement;
      const { element } = viewport;
      const annotations = getAnnotations(element, this.getToolName());
      if (annotations == null ? void 0 : annotations.length) {
        annotations.forEach((annotation) => {
          removeAnnotation(annotation.annotationUID, element);
        });
      }
    });
  }
  getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
    if (point !== null) {
      return point;
    }
    point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
    if (point !== null) {
      return point;
    }
  }
  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
      const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
      const { element } = viewport;
      element.removeEventListener(Events$2.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
    });
  }
  _subscribeToViewportNewVolumeSet(viewports) {
    viewports.forEach(({ viewportId, renderingEngineId }) => {
      const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
      const { element } = viewport;
      element.addEventListener(Events$2.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
    });
  }
  _autoPanViewportIfNecessary(viewportId, renderingEngine) {
    const viewport = renderingEngine.getViewport(viewportId);
    const { clientWidth, clientHeight } = viewport.canvas;
    const topLefWorld = viewport.canvasToWorld([0, 0]);
    const bottomRightWorld = viewport.canvasToWorld([
      clientWidth,
      clientHeight
    ]);
    const topRightWorld = viewport.canvasToWorld([clientWidth, 0]);
    const bottomLeftWorld = viewport.canvasToWorld([0, clientHeight]);
    const minX = Math.min(topLefWorld[0], bottomRightWorld[0], topRightWorld[0], bottomLeftWorld[0]);
    const maxX = Math.max(topLefWorld[0], bottomRightWorld[0], topRightWorld[0], bottomLeftWorld[0]);
    const minY = Math.min(topLefWorld[1], bottomRightWorld[1], topRightWorld[1], bottomLeftWorld[1]);
    const maxY = Math.max(topLefWorld[1], bottomRightWorld[1], topRightWorld[1], bottomLeftWorld[1]);
    const minZ = Math.min(topLefWorld[2], bottomRightWorld[2], topRightWorld[2], bottomLeftWorld[2]);
    const maxZ = Math.max(topLefWorld[2], bottomRightWorld[2], topRightWorld[2], bottomLeftWorld[2]);
    let deltaPointsWorld;
    const pan = this.configuration.autoPan.panSize;
    if (this.toolCenter[0] < minX - EPSILON$1) {
      deltaPointsWorld = [minX - this.toolCenter[0] + pan, 0, 0];
    } else if (this.toolCenter[0] > maxX + EPSILON$1) {
      deltaPointsWorld = [maxX - this.toolCenter[0] - pan, 0, 0];
    } else if (this.toolCenter[1] < minY - EPSILON$1) {
      deltaPointsWorld = [0, minY - this.toolCenter[1] + pan, 0];
    } else if (this.toolCenter[1] > maxY + EPSILON$1) {
      deltaPointsWorld = [0, maxY - this.toolCenter[1] - pan, 0];
    } else if (this.toolCenter[2] < minZ - EPSILON$1) {
      deltaPointsWorld = [0, 0, minZ - this.toolCenter[2] + pan];
    } else if (this.toolCenter[2] > maxZ + EPSILON$1) {
      deltaPointsWorld = [0, 0, maxZ - this.toolCenter[2] - pan];
    } else {
      return;
    }
    const camera = viewport.getCamera();
    const { focalPoint, position } = camera;
    const updatedPosition = [
      position[0] - deltaPointsWorld[0],
      position[1] - deltaPointsWorld[1],
      position[2] - deltaPointsWorld[2]
    ];
    const updatedFocalPoint = [
      focalPoint[0] - deltaPointsWorld[0],
      focalPoint[1] - deltaPointsWorld[1],
      focalPoint[2] - deltaPointsWorld[2]
    ];
    viewport.setCamera({
      focalPoint: updatedFocalPoint,
      position: updatedPosition
    });
    viewport.render();
  }
  setSlabThickness(viewport, slabThickness) {
    let actorUIDs;
    const { filterActorUIDsToSetSlabThickness } = this.configuration;
    if (filterActorUIDsToSetSlabThickness && filterActorUIDsToSetSlabThickness.length > 0) {
      actorUIDs = filterActorUIDsToSetSlabThickness;
    }
    let blendModeToUse = this.configuration.slabThicknessBlendMode;
    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
      blendModeToUse = BlendModes$1.COMPOSITE;
    }
    const immediate = false;
    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
    viewport.setSlabThickness(slabThickness, actorUIDs);
  }
  _isClockWise(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
  }
  _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
    viewportsAnnotationsToUpdate.forEach((annotation) => {
      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
    });
  }
  _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
    const { data } = annotation;
    const viewport = renderingEngine.getViewport(data.viewportId);
    const camera = viewport.getCamera();
    const normal = camera.viewPlaneNormal;
    const dotProd = vtkMath.dot(delta, normal);
    const projectedDelta = [...normal];
    vtkMath.multiplyScalar(projectedDelta, dotProd);
    if (Math.abs(projectedDelta[0]) > 1e-3 || Math.abs(projectedDelta[1]) > 1e-3 || Math.abs(projectedDelta[2]) > 1e-3) {
      const newFocalPoint = [0, 0, 0];
      const newPosition = [0, 0, 0];
      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);
      vtkMath.add(camera.position, projectedDelta, newPosition);
      viewport.setCamera({
        focalPoint: newFocalPoint,
        position: newPosition
      });
      viewport.render();
    }
  }
  _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
    const { data } = annotation;
    const { rotationPoints } = data.handles;
    for (let i = 0; i < rotationPoints.length; i++) {
      const point = rotationPoints[i][0];
      const otherViewport = rotationPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      if (!viewportControllable) {
        continue;
      }
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
      if (!viewportDraggableRotatable) {
        continue;
      }
      const annotationCanvasCoordinate = viewport.worldToCanvas(point);
      if (distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
        data.handles.activeOperation = OPERATION.ROTATE;
        this.editData = {
          annotation
        };
        return point;
      }
    }
    return null;
  }
  _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
    const { data } = annotation;
    const { slabThicknessPoints } = data.handles;
    for (let i = 0; i < slabThicknessPoints.length; i++) {
      const point = slabThicknessPoints[i][0];
      const otherViewport = slabThicknessPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      if (!viewportControllable) {
        continue;
      }
      const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
      if (!viewportSlabThicknessControlsOn) {
        continue;
      }
      const annotationCanvasCoordinate = viewport.worldToCanvas(point);
      if (distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
        data.handles.activeOperation = OPERATION.SLAB;
        data.activeViewportIds = [otherViewport.id];
        this.editData = {
          annotation
        };
        return point;
      }
    }
    return null;
  }
  _pointNearTool(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { clientWidth, clientHeight } = viewport.canvas;
    const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
    const { data } = annotation;
    const { rotationPoints } = data.handles;
    const { slabThicknessPoints } = data.handles;
    const viewportIdArray = [];
    for (let i = 0; i < rotationPoints.length - 1; ++i) {
      const otherViewport = rotationPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
      if (!viewportControllable || !viewportDraggableRotatable) {
        continue;
      }
      const lineSegment1 = {
        start: {
          x: rotationPoints[i][2][0],
          y: rotationPoints[i][2][1]
        },
        end: {
          x: rotationPoints[i][3][0],
          y: rotationPoints[i][3][1]
        }
      };
      const distanceToPoint1 = distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
      const lineSegment2 = {
        start: {
          x: rotationPoints[i + 1][2][0],
          y: rotationPoints[i + 1][2][1]
        },
        end: {
          x: rotationPoints[i + 1][3][0],
          y: rotationPoints[i + 1][3][1]
        }
      };
      const distanceToPoint2 = distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
        viewportIdArray.push(otherViewport.id);
        data.handles.activeOperation = OPERATION.DRAG;
      }
      i++;
    }
    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
      const otherViewport = slabThicknessPoints[i][1];
      if (viewportIdArray.find((id) => id === otherViewport.id)) {
        continue;
      }
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
      if (!viewportControllable || !viewportSlabThicknessControlsOn) {
        continue;
      }
      const stPointLineCanvas1 = slabThicknessPoints[i][2];
      const stPointLineCanvas2 = slabThicknessPoints[i][3];
      const centerCanvas = create();
      add$1(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
      scale(centerCanvas, centerCanvas, 0.5);
      const canvasUnitVectorFromCenter = create();
      subtract$1(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
      normalize$1(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
      const canvasVectorFromCenterStart = create();
      scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
      const stPointLineCanvas1Start = create();
      const stPointLineCanvas2Start = create();
      add$1(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
      subtract$1(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
      const lineSegment1 = {
        start: {
          x: stPointLineCanvas1Start[0],
          y: stPointLineCanvas1Start[1]
        },
        end: {
          x: stPointLineCanvas1[0],
          y: stPointLineCanvas1[1]
        }
      };
      const distanceToPoint1 = distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
      const lineSegment2 = {
        start: {
          x: stPointLineCanvas2Start[0],
          y: stPointLineCanvas2Start[1]
        },
        end: {
          x: stPointLineCanvas2[0],
          y: stPointLineCanvas2[1]
        }
      };
      const distanceToPoint2 = distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
        viewportIdArray.push(otherViewport.id);
        data.handles.activeOperation = null;
      }
      i++;
    }
    data.activeViewportIds = [...viewportIdArray];
    this.editData = {
      annotation
    };
    return data.handles.activeOperation === OPERATION.DRAG ? true : false;
  }
}
CrosshairsTool.toolName = "Crosshairs";
const CrosshairsTool$1 = CrosshairsTool;
const EPSILON = 1e-6;
const INSIDE = 1;
const OUTSIDE = 0;
function clipT(num, denom, c) {
  const [tE, tL] = c;
  if (Math.abs(denom) < EPSILON)
    return num < 0;
  const t = num / denom;
  if (denom > 0) {
    if (t > tL)
      return 0;
    if (t > tE)
      c[0] = t;
  } else {
    if (t < tE)
      return 0;
    if (t < tL)
      c[1] = t;
  }
  return 1;
}
function clip(a, b, box, da, db) {
  const [x1, y1] = a;
  const [x2, y2] = b;
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (da === void 0 || db === void 0) {
    da = a;
    db = b;
  } else {
    da[0] = a[0];
    da[1] = a[1];
    db[0] = b[0];
    db[1] = b[1];
  }
  if (Math.abs(dx) < EPSILON && Math.abs(dy) < EPSILON && x1 >= box[0] && x1 <= box[2] && y1 >= box[1] && y1 <= box[3]) {
    return INSIDE;
  }
  const c = [0, 1];
  if (clipT(box[0] - x1, dx, c) && clipT(x1 - box[2], -dx, c) && clipT(box[1] - y1, dy, c) && clipT(y1 - box[3], -dy, c)) {
    const [tE, tL] = c;
    if (tL < 1) {
      db[0] = x1 + tL * dx;
      db[1] = y1 + tL * dy;
    }
    if (tE > 0) {
      da[0] += tE * dx;
      da[1] += tE * dy;
    }
    return INSIDE;
  }
  return OUTSIDE;
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findClosestPoint,
  liangBarksyClip: clip
}, Symbol.toStringTag, { value: "Module" }));
function getToolGroup(toolGroupId) {
  return state.toolGroups.find((s) => s.id === toolGroupId);
}
function getToolGroupForViewport(viewportId, renderingEngineId) {
  const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId && (!vp.viewportId || vp.viewportId === viewportId)));
  if (!toolGroupFilteredByIds.length) {
    return;
  }
  if (toolGroupFilteredByIds.length > 1) {
    throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only
      have one tool group per viewport in a renderingEngine.`);
  }
  return toolGroupFilteredByIds[0];
}
const App_vue_vue_type_style_index_0_scoped_a2947b33_lang = "";
const _withScopeId = (n) => (pushScopeId("data-v-a2947b33"), n = n(), popScopeId(), n);
const _hoisted_1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", null, [
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://vitejs.dev",
    target: "_blank"
  }, [
    /* @__PURE__ */ createBaseVNode("img", {
      src: _imports_0,
      class: "logo",
      alt: "Vite logo"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://vuejs.org/",
    target: "_blank"
  }, [
    /* @__PURE__ */ createBaseVNode("img", {
      src: _imports_1,
      class: "logo vue",
      alt: "Vue logo"
    })
  ])
], -1));
const _sfc_main = {
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        _hoisted_1,
        createTextVNode(" CrossHairs:" + toDisplayString(CrosshairsTool$1.name) + " ", 1),
        createVNode(HelloWorld, { msg: "Vite + Vue" })
      ], 64);
    };
  }
};
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-a2947b33"]]);
createApp(App).mount("#app");
